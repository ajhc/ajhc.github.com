<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/RawFiles.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>RawFiles</span> <span class='hs-keyword'>where</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>ByteString</span><span class='hs-varop'>.</span><span class='hs-conid'>Unsafe</span>
<a name="line-4"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>ByteString</span>
<a name="line-5"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>System</span><span class='hs-varop'>.</span><span class='hs-conid'>IO</span><span class='hs-varop'>.</span><span class='hs-conid'>Unsafe</span>
<a name="line-6"></a>
<a name="line-7"></a><a name="viaghc_hs"></a><span class='hs-comment'>-- | Generated from src\/data\/ViaGhc.hs</span>
<a name="line-8"></a><span class='hs-comment'>{-# NOINLINE viaghc_hs #-}</span>
<a name="line-9"></a><span class='hs-definition'>viaghc_hs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-10"></a><span class='hs-definition'>viaghc_hs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-11"></a> \{-# OPTIONS_GHC -fglasgow-exts -fno-implicit-prelude #-}\n\
<a name="line-12"></a> \module Main(main) where\n\
<a name="line-13"></a> \\n\
<a name="line-14"></a> \import GHC.Int\n\
<a name="line-15"></a> \import GHC.Word\n\
<a name="line-16"></a> \import GHC.IOBase\n\
<a name="line-17"></a> \import GHC.Prim\n\
<a name="line-18"></a> \import GHC.Base\n\
<a name="line-19"></a> \import GHC.Ptr\n\
<a name="line-20"></a> \import GHC.Err\n\
<a name="line-21"></a> \\n\
<a name="line-22"></a> \type World__ = State# RealWorld\n\
<a name="line-23"></a> \type Array__ a = Array# a\n\
<a name="line-24"></a> \type MutArray__ a = MutableArray# RealWorld a\n\
<a name="line-25"></a> \type Ref__ a = MutVar# RealWorld a\n\
<a name="line-26"></a> \\n\
<a name="line-27"></a> \type Nothing = ()\n\
<a name="line-28"></a> \\n\
<a name="line-29"></a> \theNothing :: Nothing\n\
<a name="line-30"></a> \theNothing = ()\n\
<a name="line-31"></a> \\n\
<a name="line-32"></a> \type JIO a = World__ -&gt; (# World__, a #)\n\
<a name="line-33"></a> \\n\
<a name="line-34"></a> \main :: IO ()\n\
<a name="line-35"></a> \main = IO $ \\rw -&gt; case theRealMain rw of rw' -&gt; (# rw', () #)\n\
<a name="line-36"></a> \\n\
<a name="line-37"></a> \unPtr :: Ptr a -&gt; Addr#\n\
<a name="line-38"></a> \unPtr ptr = case ptr of\n\
<a name="line-39"></a> \    Ptr addr -&gt; addr\n\
<a name="line-40"></a> \\n\
<a name="line-41"></a> \unFunPtr :: FunPtr a -&gt; Addr#\n\
<a name="line-42"></a> \unFunPtr ptr = case ptr of\n\
<a name="line-43"></a> \    FunPtr addr -&gt; addr\n\
<a name="line-44"></a> \\n\
<a name="line-45"></a> \fromBool :: Bool -&gt; Int#\n\
<a name="line-46"></a> \fromBool b = case b of\n\
<a name="line-47"></a> \    False -&gt; 0#\n\
<a name="line-48"></a> \    True -&gt; 1#\n\
<a name="line-49"></a> \\n\
<a name="line-50"></a> \gteChar# a b = gtChar# a b || eqChar# a b\n\
<a name="line-51"></a> \lteChar# a b = ltChar# a b || eqChar# a b\n\
<a name="line-52"></a> \\n\
<a name="line-53"></a> \plusAddr__ :: Addr# -&gt; Addr# -&gt; Addr#\n\
<a name="line-54"></a> \plusAddr__ a1 a2 = plusAddr# a1 (addr2Int# a2)\n\
<a name="line-55"></a> \\n\
<a name="line-56"></a> \alloca__ :: Int# -&gt; (Addr# -&gt; JIO a) -&gt; JIO a\n\
<a name="line-57"></a> \alloca__ size action s =\n\
<a name="line-58"></a> \     case newPinnedByteArray# size s      of { (# s, mbarr# #) -&gt;\n\
<a name="line-59"></a> \     case unsafeFreezeByteArray# mbarr# s of { (# s, barr#  #) -&gt;\n\
<a name="line-60"></a> \     case action (byteArrayContents# barr#) s of { (# s, r #) -&gt;\n\
<a name="line-61"></a> \     case touch# barr# s of { s -&gt; (# s, r #) }\n\
<a name="line-62"></a> \     }}}\n\
<a name="line-63"></a> \\n\
<a name="line-64"></a> \word2Char__ x = chr# (word2Int# x)\n\
<a name="line-65"></a> \char2Word__ x = int2Word# (ord# x)\n\
<a name="line-66"></a> \addr2Word__ x = int2Word# (addr2Int# x)\n\
<a name="line-67"></a> \word2Addr__ x = int2Addr# (word2Int# x)\n\
<a name="line-68"></a> \\n\
<a name="line-69"></a> \convertString :: [Char] -&gt; ListTCon Char\n\
<a name="line-70"></a> \convertString [] = jhc_EmptyList\n\
<a name="line-71"></a> \convertString (x:xs) = jhc_Cons x (convertString xs)\n\
<a name="line-72"></a> \\n\
<a name="line-73"></a> \{-\n\
<a name="line-74"></a> \error__ :: Addr# -&gt; a\n\
<a name="line-75"></a> \error__ s = unsafePerformIO $ do\n\
<a name="line-76"></a> \    error_show s\n\
<a name="line-77"></a> \    error_exit (I# 255#)\n\
<a name="line-78"></a> \\n\
<a name="line-79"></a> \errorInt__ :: Addr# -&gt; Int#\n\
<a name="line-80"></a> \errorInt__ s = seq (unsafePerformIO $ do\n\
<a name="line-81"></a> \    error_show s\n\
<a name="line-82"></a> \    error_exit (I# 255#)) 0#\n\
<a name="line-83"></a> \\n\
<a name="line-84"></a> \errorWord__ :: Addr# -&gt; Word#\n\
<a name="line-85"></a> \errorWord__ s = seq (unsafePerformIO $ do\n\
<a name="line-86"></a> \    error_show s\n\
<a name="line-87"></a> \    error_exit (I# 255#)) (int2Word# 0#)\n\
<a name="line-88"></a> \\n\
<a name="line-89"></a> \errorAddr__ :: Addr# -&gt; Addr#\n\
<a name="line-90"></a> \errorAddr__ s = seq (unsafePerformIO $ do\n\
<a name="line-91"></a> \    error_show s\n\
<a name="line-92"></a> \    error_exit (I# 255#)) (int2Addr# 0#)\n\
<a name="line-93"></a> \foreign import ccall unsafe \"puts\" error_show :: Ptr a -&gt; IO ()\n\
<a name="line-94"></a> \foreign import ccall unsafe \"exit\" error_exit :: Int -&gt; IO a\n\
<a name="line-95"></a> \ -}\n\
<a name="line-96"></a> \\n\
<a name="line-97"></a> \{-# NOINLINE newWorld__ #-}\n\
<a name="line-98"></a> \newWorld__ :: a -&gt; World__\n\
<a name="line-99"></a> \newWorld__ a = case lazy a of\n\
<a name="line-100"></a> \    _ -&gt; realWorld#\n\
<a name="line-101"></a> \\n\
<a name="line-102"></a> \theRealMain :: World__ -&gt; World__\n\
<a name="line-103"></a> \\n\
<a name="line-104"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-105"></a>
<a name="line-106"></a><a name="prelude_m4"></a><span class='hs-comment'>-- | Generated from src\/data\/prelude.m4</span>
<a name="line-107"></a><span class='hs-comment'>{-# NOINLINE prelude_m4 #-}</span>
<a name="line-108"></a><span class='hs-definition'>prelude_m4</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-109"></a><span class='hs-definition'>prelude_m4</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-110"></a> \m4_changequote({{,}})\n\
<a name="line-111"></a> \m4_changecom({-,-})\n\
<a name="line-112"></a> \\n\
<a name="line-113"></a> \m4_define(ONCE,{{m4_ifdef(done-$1,{{m4_dnl}},{{m4_define(done-$1,1)$1}})}})\n\
<a name="line-114"></a> \\n\
<a name="line-115"></a> \m4_define({{m4_for}},{{m4_ifelse($#,0,{{{{$0}}}},{{m4_ifelse(m4_eval($2&lt;=$3),1,\n\
<a name="line-116"></a> \{{m4_pushdef({{$1}},$2)$4{{}}m4_popdef({{$1}})$0({{$1}},m4_incr($2),$3,{{$4}})}})}})}})\n\
<a name="line-117"></a> \\n\
<a name="line-118"></a> \m4_define({{m4_foreach}},{{m4_ifelse(m4_eval($#&gt;2),1,\n\
<a name="line-119"></a> \{{m4_pushdef({{$1}},{{$3}})$2{{}}m4_popdef({{$1}})m4_dnl\n\
<a name="line-120"></a> \{{}}m4_ifelse(m4_eval($#&gt;3),1,{{$0({{$1}},{{$2}},m4_shift(m4_shift(m4_shift($@))))}})}})}})\n\
<a name="line-121"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-122"></a>
<a name="line-123"></a><a name="targets_ini"></a><span class='hs-comment'>-- | Generated from src\/data\/targets.ini</span>
<a name="line-124"></a><span class='hs-comment'>{-# NOINLINE targets_ini #-}</span>
<a name="line-125"></a><span class='hs-definition'>targets_ini</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-126"></a><span class='hs-definition'>targets_ini</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-127"></a> \;\n\
<a name="line-128"></a> \; configuration file for architectures and compiler options.\n\
<a name="line-129"></a> \;\n\
<a name="line-130"></a> \; the final value set is the one used.\n\
<a name="line-131"></a> \;\n\
<a name="line-132"></a> \; all '-m' parameters on the command line are parsed and processed in order.\n\
<a name="line-133"></a> \;\n\
<a name="line-134"></a> \; there is an implicit -mdefault processed first\n\
<a name="line-135"></a> \; entries in the user config file are appended to this one.\n\
<a name="line-136"></a> \;\n\
<a name="line-137"></a> \; the cross compilation entries in this file should be treated as examples.\n\
<a name="line-138"></a> \; although they work out of the box for many systems, cross compilation\n\
<a name="line-139"></a> \; environments differ, so you may need to override them for your\n\
<a name="line-140"></a> \; specific setup.\n\
<a name="line-141"></a> \\n\
<a name="line-142"></a> \[default]\n\
<a name="line-143"></a> \cc=gcc\n\
<a name="line-144"></a> \gc=jgc\n\
<a name="line-145"></a> \cflags=-std=gnu99 -D_GNU_SOURCE -falign-functions=4 -ffast-math -Wextra -Wall -Wno-unused-parameter -fno-strict-aliasing\n\
<a name="line-146"></a> \cflags_debug=-g -lm\n\
<a name="line-147"></a> \cflags_nodebug=-DNDEBUG -O3\n\
<a name="line-148"></a> \profile=false\n\
<a name="line-149"></a> \autoload=haskell2010,haskell-extras,haskell98\n\
<a name="line-150"></a> \\n\
<a name="line-151"></a> \\n\
<a name="line-152"></a> \; cross compilation entries\n\
<a name="line-153"></a> \\n\
<a name="line-154"></a> \[win32]\n\
<a name="line-155"></a> \cc=i686-w64-mingw32-gcc\n\
<a name="line-156"></a> \executable_extension=.exe\n\
<a name="line-157"></a> \merge=i686\n\
<a name="line-158"></a> \\n\
<a name="line-159"></a> \[wii]\n\
<a name="line-160"></a> \cc=powerpc-eabi-gcc\n\
<a name="line-161"></a> \byteorder=be\n\
<a name="line-162"></a> \cflags+=-g -DGEKKO -D__WORDSIZE=32 -mrvl -mcpu=750 -meabi -mhard-float\n\
<a name="line-163"></a> \executable_extension=.elf\n\
<a name="line-164"></a> \bits=32\n\
<a name="line-165"></a> \bits_max=64\n\
<a name="line-166"></a> \merge=be32\n\
<a name="line-167"></a> \\n\
<a name="line-168"></a> \; macintosh, this is for cross compiling, not for native compilation on osx\n\
<a name="line-169"></a> \[osx]\n\
<a name="line-170"></a> \\n\
<a name="line-171"></a> \[osx-intel]\n\
<a name="line-172"></a> \cc=i686-apple-darwin9-gcc\n\
<a name="line-173"></a> \merge=i686\n\
<a name="line-174"></a> \merge=osx\n\
<a name="line-175"></a> \\n\
<a name="line-176"></a> \[osx-powerpc]\n\
<a name="line-177"></a> \cc=powerpc-apple-darwin9-gcc\n\
<a name="line-178"></a> \merge=be32\n\
<a name="line-179"></a> \merge=osx\n\
<a name="line-180"></a> \\n\
<a name="line-181"></a> \; a couple specific cpus\n\
<a name="line-182"></a> \[i686]\n\
<a name="line-183"></a> \merge=le32\n\
<a name="line-184"></a> \arch=i686\n\
<a name="line-185"></a> \bits_max=64\n\
<a name="line-186"></a> \cflags_nodebug+=-fomit-frame-pointer\n\
<a name="line-187"></a> \\n\
<a name="line-188"></a> \[x86_64]\n\
<a name="line-189"></a> \bits_max=64\n\
<a name="line-190"></a> \merge=le64\n\
<a name="line-191"></a> \\n\
<a name="line-192"></a> \[le32]\n\
<a name="line-193"></a> \\n\
<a name="line-194"></a> \byteorder=le\n\
<a name="line-195"></a> \merge=32\n\
<a name="line-196"></a> \\n\
<a name="line-197"></a> \[be32]\n\
<a name="line-198"></a> \byteorder=be\n\
<a name="line-199"></a> \merge=32\n\
<a name="line-200"></a> \\n\
<a name="line-201"></a> \[le64]\n\
<a name="line-202"></a> \byteorder=le\n\
<a name="line-203"></a> \merge=64\n\
<a name="line-204"></a> \\n\
<a name="line-205"></a> \[be64]\n\
<a name="line-206"></a> \byteorder=be\n\
<a name="line-207"></a> \merge=64\n\
<a name="line-208"></a> \\n\
<a name="line-209"></a> \[32]\n\
<a name="line-210"></a> \cflags+=-m32\n\
<a name="line-211"></a> \bits=32\n\
<a name="line-212"></a> \\n\
<a name="line-213"></a> \[64]\n\
<a name="line-214"></a> \cflags+=-m64\n\
<a name="line-215"></a> \bits=64\n\
<a name="line-216"></a> \\n\
<a name="line-217"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-218"></a>
<a name="line-219"></a><a name="constants_h"></a><span class='hs-comment'>-- | Generated from rts\/rts\/constants.h</span>
<a name="line-220"></a><span class='hs-comment'>{-# NOINLINE constants_h #-}</span>
<a name="line-221"></a><span class='hs-definition'>constants_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-222"></a><span class='hs-definition'>constants_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-223"></a> \#ifndef RTS_CONSTANTS_H\n\
<a name="line-224"></a> \#define RTS_CONSTANTS_H\n\
<a name="line-225"></a> \/* these constants are shared between jhc-prim and the rts. */\n\
<a name="line-226"></a> \\n\
<a name="line-227"></a> \// Normal memory block.\n\
<a name="line-228"></a> \#define SLAB_FLAG_NONE         0\n\
<a name="line-229"></a> \\n\
<a name="line-230"></a> \// Each element has a finalizer-list as its second word.\n\
<a name="line-231"></a> \#define SLAB_FLAG_FINALIZER    1\n\
<a name="line-232"></a> \\n\
<a name="line-233"></a> \// In addition to whatever other finalization is done, 'free' should be called\n\
<a name="line-234"></a> \// on the first word of each entry.\n\
<a name="line-235"></a> \#define SLAB_FLAG_FREE         2\n\
<a name="line-236"></a> \\n\
<a name="line-237"></a> \// Finalizers should be delayed until entire slab is freed up and individually\n\
<a name="line-238"></a> \// freed members need not be kept track of.\n\
<a name="line-239"></a> \#define SLAB_FLAG_DELAY        4\n\
<a name="line-240"></a> \\n\
<a name="line-241"></a> \// A global finalizer exists for this slab\n\
<a name="line-242"></a> \#define SLAB_GLOBAL_FINALIZER  8\n\
<a name="line-243"></a> \\n\
<a name="line-244"></a> \// slab is a monolith, should be 'free'd when done with and not returned to\n\
<a name="line-245"></a> \// cache.\n\
<a name="line-246"></a> \#define SLAB_MONOLITH          16\n\
<a name="line-247"></a> \\n\
<a name="line-248"></a> \// virtual flags are never set in a cache but are used internally to keep track\n\
<a name="line-249"></a> \// of things.\n\
<a name="line-250"></a> \\n\
<a name="line-251"></a> \// virtual flag to indicate location is a value\n\
<a name="line-252"></a> \#define SLAB_VIRTUAL_VALUE     256\n\
<a name="line-253"></a> \\n\
<a name="line-254"></a> \// virtual flag to indicate location has a special intererpretation.\n\
<a name="line-255"></a> \#define SLAB_VIRTUAL_SPECIAL   512\n\
<a name="line-256"></a> \\n\
<a name="line-257"></a> \// virtual flag to indication location is a constant.\n\
<a name="line-258"></a> \#define SLAB_VIRTUAL_CONSTANT  1024\n\
<a name="line-259"></a> \\n\
<a name="line-260"></a> \// virtual flag to indication location has been freed. (for debugging)\n\
<a name="line-261"></a> \#define SLAB_VIRTUAL_FREED     2048\n\
<a name="line-262"></a> \\n\
<a name="line-263"></a> \// virtual flag to indication location is lazy.\n\
<a name="line-264"></a> \#define SLAB_VIRTUAL_LAZY      4096\n\
<a name="line-265"></a> \\n\
<a name="line-266"></a> \// virtual flag to indication location is func.\n\
<a name="line-267"></a> \#define SLAB_VIRTUAL_FUNC      8192\n\
<a name="line-268"></a> \\n\
<a name="line-269"></a> \#endif\n\
<a name="line-270"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-271"></a>
<a name="line-272"></a><a name="stableptr_c"></a><span class='hs-comment'>-- | Generated from rts\/rts\/stableptr.c</span>
<a name="line-273"></a><span class='hs-comment'>{-# NOINLINE stableptr_c #-}</span>
<a name="line-274"></a><span class='hs-definition'>stableptr_c</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-275"></a><span class='hs-definition'>stableptr_c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-276"></a> \#include \"sys/queue.h\"\n\
<a name="line-277"></a> \#include \"jhc_rts_header.h\"\n\
<a name="line-278"></a> \\n\
<a name="line-279"></a> \struct StablePtr_list root_StablePtrs = LIST_HEAD_INITIALIZER();\n\
<a name="line-280"></a> \\n\
<a name="line-281"></a> \wptr_t c_newStablePtr(sptr_t c) {\n\
<a name="line-282"></a> \    struct StablePtr* sp = malloc(sizeof(struct StablePtr));\n\
<a name="line-283"></a> \    sp-&gt;contents = c;\n\
<a name="line-284"></a> \    LIST_INSERT_HEAD(&amp;root_StablePtrs, sp, link);\n\
<a name="line-285"></a> \    assert(GET_PTYPE(sp) == 0);\n\
<a name="line-286"></a> \    return (wptr_t)TO_SPTR(P_VALUE,(wptr_t)sp);\n\
<a name="line-287"></a> \}\n\
<a name="line-288"></a> \\n\
<a name="line-289"></a> \void c_freeStablePtr(wptr_t wp) {\n\
<a name="line-290"></a> \    struct StablePtr *sp = FROM_SPTR((HsPtr)wp);\n\
<a name="line-291"></a> \    LIST_REMOVE(sp, link);\n\
<a name="line-292"></a> \    free(sp);\n\
<a name="line-293"></a> \}\n\
<a name="line-294"></a> \\n\
<a name="line-295"></a> \sptr_t c_derefStablePtr(wptr_t wp) {\n\
<a name="line-296"></a> \    struct StablePtr *sp = FROM_SPTR((HsPtr)wp);\n\
<a name="line-297"></a> \    return sp-&gt;contents;\n\
<a name="line-298"></a> \}\n\
<a name="line-299"></a> \\n\
<a name="line-300"></a> \void hs_free_stable_ptr(HsStablePtr sp) {\n\
<a name="line-301"></a> \        c_freeStablePtr((HsStablePtr)sp);\n\
<a name="line-302"></a> \}\n\
<a name="line-303"></a> \void hs_free_fun_ptr(HsFunPtr fp) {}\n\
<a name="line-304"></a> \\n\
<a name="line-305"></a> \/*\n\
<a name="line-306"></a> \wptr_t c_castPtrToStablePtr(void *)\n\
<a name="line-307"></a> \void * c_castStablePtrToPtr(wptr_t)\n\
<a name="line-308"></a> \*/\n\
<a name="line-309"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-310"></a>
<a name="line-311"></a><a name="queue_h"></a><span class='hs-comment'>-- | Generated from rts\/sys\/queue.h</span>
<a name="line-312"></a><span class='hs-comment'>{-# NOINLINE queue_h #-}</span>
<a name="line-313"></a><span class='hs-definition'>queue_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-314"></a><span class='hs-definition'>queue_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-315"></a> \/*\n\
<a name="line-316"></a> \ * Copyright (c) 1991, 1993\n\
<a name="line-317"></a> \ *\x0009\&amp;The Regents of the University of California.  All rights reserved.\n\
<a name="line-318"></a> \ *\n\
<a name="line-319"></a> \ * Redistribution and use in source and binary forms, with or without\n\
<a name="line-320"></a> \ * modification, are permitted provided that the following conditions\n\
<a name="line-321"></a> \ * are met:\n\
<a name="line-322"></a> \ * 1. Redistributions of source code must retain the above copyright\n\
<a name="line-323"></a> \ *    notice, this list of conditions and the following disclaimer.\n\
<a name="line-324"></a> \ * 2. Redistributions in binary form must reproduce the above copyright\n\
<a name="line-325"></a> \ *    notice, this list of conditions and the following disclaimer in the\n\
<a name="line-326"></a> \ *    documentation and/or other materials provided with the distribution.\n\
<a name="line-327"></a> \ * 3. Neither the name of the University nor the names of its contributors\n\
<a name="line-328"></a> \ *    may be used to endorse or promote products derived from this software\n\
<a name="line-329"></a> \ *    without specific prior written permission.\n\
<a name="line-330"></a> \ *\n\
<a name="line-331"></a> \ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n\
<a name="line-332"></a> \ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\
<a name="line-333"></a> \ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\
<a name="line-334"></a> \ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n\
<a name="line-335"></a> \ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\
<a name="line-336"></a> \ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n\
<a name="line-337"></a> \ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n\
<a name="line-338"></a> \ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n\
<a name="line-339"></a> \ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n\
<a name="line-340"></a> \ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\
<a name="line-341"></a> \ * SUCH DAMAGE.\n\
<a name="line-342"></a> \ *\n\
<a name="line-343"></a> \ *\x0009\&amp;@(#)queue.h\x0009\&amp;8.5 (Berkeley) 8/20/94\n\
<a name="line-344"></a> \ */\n\
<a name="line-345"></a> \\n\
<a name="line-346"></a> \#ifndef\x0009\&amp;_SYS_QUEUE_H_\n\
<a name="line-347"></a> \#define\x0009\&amp;_SYS_QUEUE_H_\n\
<a name="line-348"></a> \\n\
<a name="line-349"></a> \/*\n\
<a name="line-350"></a> \ * This file defines five types of data structures: singly-linked lists,\n\
<a name="line-351"></a> \ * lists, simple queues, tail queues, and circular queues.\n\
<a name="line-352"></a> \ *\n\
<a name="line-353"></a> \ * A singly-linked list is headed by a single forward pointer. The\n\
<a name="line-354"></a> \ * elements are singly linked for minimum space and pointer manipulation\n\
<a name="line-355"></a> \ * overhead at the expense of O(n) removal for arbitrary elements. New\n\
<a name="line-356"></a> \ * elements can be added to the list after an existing element or at the\n\
<a name="line-357"></a> \ * head of the list.  Elements being removed from the head of the list\n\
<a name="line-358"></a> \ * should use the explicit macro for this purpose for optimum\n\
<a name="line-359"></a> \ * efficiency. A singly-linked list may only be traversed in the forward\n\
<a name="line-360"></a> \ * direction.  Singly-linked lists are ideal for applications with large\n\
<a name="line-361"></a> \ * datasets and few or no removals or for implementing a LIFO queue.\n\
<a name="line-362"></a> \ *\n\
<a name="line-363"></a> \ * A list is headed by a single forward pointer (or an array of forward\n\
<a name="line-364"></a> \ * pointers for a hash table header). The elements are doubly linked\n\
<a name="line-365"></a> \ * so that an arbitrary element can be removed without a need to\n\
<a name="line-366"></a> \ * traverse the list. New elements can be added to the list before\n\
<a name="line-367"></a> \ * or after an existing element or at the head of the list. A list\n\
<a name="line-368"></a> \ * may only be traversed in the forward direction.\n\
<a name="line-369"></a> \ *\n\
<a name="line-370"></a> \ * A simple queue is headed by a pair of pointers, one the head of the\n\
<a name="line-371"></a> \ * list and the other to the tail of the list. The elements are singly\n\
<a name="line-372"></a> \ * linked to save space, so elements can only be removed from the\n\
<a name="line-373"></a> \ * head of the list. New elements can be added to the list after\n\
<a name="line-374"></a> \ * an existing element, at the head of the list, or at the end of the\n\
<a name="line-375"></a> \ * list. A simple queue may only be traversed in the forward direction.\n\
<a name="line-376"></a> \ *\n\
<a name="line-377"></a> \ * A tail queue is headed by a pair of pointers, one to the head of the\n\
<a name="line-378"></a> \ * list and the other to the tail of the list. The elements are doubly\n\
<a name="line-379"></a> \ * linked so that an arbitrary element can be removed without a need to\n\
<a name="line-380"></a> \ * traverse the list. New elements can be added to the list before or\n\
<a name="line-381"></a> \ * after an existing element, at the head of the list, or at the end of\n\
<a name="line-382"></a> \ * the list. A tail queue may be traversed in either direction.\n\
<a name="line-383"></a> \ *\n\
<a name="line-384"></a> \ * A circle queue is headed by a pair of pointers, one to the head of the\n\
<a name="line-385"></a> \ * list and the other to the tail of the list. The elements are doubly\n\
<a name="line-386"></a> \ * linked so that an arbitrary element can be removed without a need to\n\
<a name="line-387"></a> \ * traverse the list. New elements can be added to the list before or after\n\
<a name="line-388"></a> \ * an existing element, at the head of the list, or at the end of the list.\n\
<a name="line-389"></a> \ * A circle queue may be traversed in either direction, but has a more\n\
<a name="line-390"></a> \ * complex end of list detection.\n\
<a name="line-391"></a> \ *\n\
<a name="line-392"></a> \ * For details on the use of these macros, see the queue(3) manual page.\n\
<a name="line-393"></a> \ */\n\
<a name="line-394"></a> \\n\
<a name="line-395"></a> \/*\n\
<a name="line-396"></a> \ * List definitions.\n\
<a name="line-397"></a> \ */\n\
<a name="line-398"></a> \#define\x0009\&amp;LIST_HEAD(name, type)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-399"></a> \struct name {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-400"></a> \\x0009\&amp;struct type *lh_first;\x0009\&amp;/* first element */\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-401"></a> \}\n\
<a name="line-402"></a> \\n\
<a name="line-403"></a> \#define\x0009\&amp;LIST_HEAD_INITIALIZER(head)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-404"></a> \\x0009\&amp;{ NULL }\n\
<a name="line-405"></a> \\n\
<a name="line-406"></a> \#define\x0009\&amp;LIST_ENTRY(type)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-407"></a> \struct {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-408"></a> \\x0009\&amp;struct type *le_next;\x0009\&amp;/* next element */\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-409"></a> \\x0009\&amp;struct type **le_prev;\x0009\&amp;/* address of previous next element */\x0009\&amp;\\\n\
<a name="line-410"></a> \}\n\
<a name="line-411"></a> \\n\
<a name="line-412"></a> \/*\n\
<a name="line-413"></a> \ * List functions.\n\
<a name="line-414"></a> \ */\n\
<a name="line-415"></a> \#define\x0009\&amp;LIST_INIT(head) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-416"></a> \\x0009\&amp;(head)-&gt;lh_first = NULL;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-417"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-418"></a> \\n\
<a name="line-419"></a> \#define\x0009\&amp;LIST_INSERT_AFTER(listelm, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-420"></a> \\x0009\&amp;if (((elm)-&gt;field.le_next = (listelm)-&gt;field.le_next) != NULL)\x0009\&amp;\\\n\
<a name="line-421"></a> \\x0009\&amp;\x0009\&amp;(listelm)-&gt;field.le_next-&gt;field.le_prev =\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-422"></a> \\x0009\&amp;\x0009\&amp;    &amp;(elm)-&gt;field.le_next;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-423"></a> \\x0009\&amp;(listelm)-&gt;field.le_next = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-424"></a> \\x0009\&amp;(elm)-&gt;field.le_prev = &amp;(listelm)-&gt;field.le_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-425"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-426"></a> \\n\
<a name="line-427"></a> \#define\x0009\&amp;LIST_INSERT_BEFORE(listelm, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-428"></a> \\x0009\&amp;(elm)-&gt;field.le_prev = (listelm)-&gt;field.le_prev;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-429"></a> \\x0009\&amp;(elm)-&gt;field.le_next = (listelm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-430"></a> \\x0009\&amp;*(listelm)-&gt;field.le_prev = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-431"></a> \\x0009\&amp;(listelm)-&gt;field.le_prev = &amp;(elm)-&gt;field.le_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-432"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-433"></a> \\n\
<a name="line-434"></a> \#define\x0009\&amp;LIST_INSERT_HEAD(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-435"></a> \\x0009\&amp;if (((elm)-&gt;field.le_next = (head)-&gt;lh_first) != NULL)\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-436"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;lh_first-&gt;field.le_prev = &amp;(elm)-&gt;field.le_next;\\\n\
<a name="line-437"></a> \\x0009\&amp;(head)-&gt;lh_first = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-438"></a> \\x0009\&amp;(elm)-&gt;field.le_prev = &amp;(head)-&gt;lh_first;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-439"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-440"></a> \\n\
<a name="line-441"></a> \#define\x0009\&amp;LIST_REMOVE(elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-442"></a> \\x0009\&amp;if ((elm)-&gt;field.le_next != NULL)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-443"></a> \\x0009\&amp;\x0009\&amp;(elm)-&gt;field.le_next-&gt;field.le_prev = \x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-444"></a> \\x0009\&amp;\x0009\&amp;    (elm)-&gt;field.le_prev;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-445"></a> \\x0009\&amp;*(elm)-&gt;field.le_prev = (elm)-&gt;field.le_next;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-446"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-447"></a> \\n\
<a name="line-448"></a> \#define\x0009\&amp;LIST_FOREACH(var, head, field)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-449"></a> \\x0009\&amp;for ((var) = ((head)-&gt;lh_first);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-450"></a> \\x0009\&amp;\x0009\&amp;(var);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-451"></a> \\x0009\&amp;\x0009\&amp;(var) = ((var)-&gt;field.le_next))\n\
<a name="line-452"></a> \\n\
<a name="line-453"></a> \/*\n\
<a name="line-454"></a> \ * List access methods.\n\
<a name="line-455"></a> \ */\n\
<a name="line-456"></a> \#define\x0009\&amp;LIST_EMPTY(head)\x0009\&amp;\x0009\&amp;((head)-&gt;lh_first == NULL)\n\
<a name="line-457"></a> \#define\x0009\&amp;LIST_FIRST(head)\x0009\&amp;\x0009\&amp;((head)-&gt;lh_first)\n\
<a name="line-458"></a> \#define\x0009\&amp;LIST_NEXT(elm, field)\x0009\&amp;\x0009\&amp;((elm)-&gt;field.le_next)\n\
<a name="line-459"></a> \\n\
<a name="line-460"></a> \/*\n\
<a name="line-461"></a> \ * Singly-linked List definitions.\n\
<a name="line-462"></a> \ */\n\
<a name="line-463"></a> \#define\x0009\&amp;SLIST_HEAD(name, type)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-464"></a> \struct name {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-465"></a> \\x0009\&amp;struct type *slh_first;\x0009\&amp;/* first element */\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-466"></a> \}\n\
<a name="line-467"></a> \\n\
<a name="line-468"></a> \#define\x0009\&amp;SLIST_HEAD_INITIALIZER(head)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-469"></a> \\x0009\&amp;{ NULL }\n\
<a name="line-470"></a> \\n\
<a name="line-471"></a> \#define\x0009\&amp;SLIST_ENTRY(type)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-472"></a> \struct {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-473"></a> \\x0009\&amp;struct type *sle_next;\x0009\&amp;/* next element */\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-474"></a> \}\n\
<a name="line-475"></a> \\n\
<a name="line-476"></a> \/*\n\
<a name="line-477"></a> \ * Singly-linked List functions.\n\
<a name="line-478"></a> \ */\n\
<a name="line-479"></a> \#define\x0009\&amp;SLIST_INIT(head) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-480"></a> \\x0009\&amp;(head)-&gt;slh_first = NULL;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-481"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-482"></a> \\n\
<a name="line-483"></a> \#define\x0009\&amp;SLIST_INSERT_AFTER(slistelm, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-484"></a> \\x0009\&amp;(elm)-&gt;field.sle_next = (slistelm)-&gt;field.sle_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-485"></a> \\x0009\&amp;(slistelm)-&gt;field.sle_next = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-486"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-487"></a> \\n\
<a name="line-488"></a> \#define\x0009\&amp;SLIST_INSERT_HEAD(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-489"></a> \\x0009\&amp;(elm)-&gt;field.sle_next = (head)-&gt;slh_first;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-490"></a> \\x0009\&amp;(head)-&gt;slh_first = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-491"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-492"></a> \\n\
<a name="line-493"></a> \#define\x0009\&amp;SLIST_REMOVE_HEAD(head, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-494"></a> \\x0009\&amp;(head)-&gt;slh_first = (head)-&gt;slh_first-&gt;field.sle_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-495"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-496"></a> \\n\
<a name="line-497"></a> \#define\x0009\&amp;SLIST_REMOVE(head, elm, type, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-498"></a> \\x0009\&amp;if ((head)-&gt;slh_first == (elm)) {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-499"></a> \\x0009\&amp;\x0009\&amp;SLIST_REMOVE_HEAD((head), field);\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-500"></a> \\x0009\&amp;}\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-501"></a> \\x0009\&amp;else {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-502"></a> \\x0009\&amp;\x0009\&amp;struct type *curelm = (head)-&gt;slh_first;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-503"></a> \\x0009\&amp;\x0009\&amp;while(curelm-&gt;field.sle_next != (elm))\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-504"></a> \\x0009\&amp;\x0009\&amp;\x0009\&amp;curelm = curelm-&gt;field.sle_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-505"></a> \\x0009\&amp;\x0009\&amp;curelm-&gt;field.sle_next =\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-506"></a> \\x0009\&amp;\x0009\&amp;    curelm-&gt;field.sle_next-&gt;field.sle_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-507"></a> \\x0009\&amp;}\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-508"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-509"></a> \\n\
<a name="line-510"></a> \#define\x0009\&amp;SLIST_FOREACH(var, head, field)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-511"></a> \\x0009\&amp;for((var) = (head)-&gt;slh_first; (var); (var) = (var)-&gt;field.sle_next)\n\
<a name="line-512"></a> \\n\
<a name="line-513"></a> \/*\n\
<a name="line-514"></a> \ * Singly-linked List access methods.\n\
<a name="line-515"></a> \ */\n\
<a name="line-516"></a> \#define\x0009\&amp;SLIST_EMPTY(head)\x0009\&amp;((head)-&gt;slh_first == NULL)\n\
<a name="line-517"></a> \#define\x0009\&amp;SLIST_FIRST(head)\x0009\&amp;((head)-&gt;slh_first)\n\
<a name="line-518"></a> \#define\x0009\&amp;SLIST_NEXT(elm, field)\x0009\&amp;((elm)-&gt;field.sle_next)\n\
<a name="line-519"></a> \\n\
<a name="line-520"></a> \/*\n\
<a name="line-521"></a> \ * Singly-linked Tail queue declarations.\n\
<a name="line-522"></a> \ */\n\
<a name="line-523"></a> \#define\x0009\&amp;STAILQ_HEAD(name, type)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-524"></a> \struct name {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-525"></a> \\x0009\&amp;struct type *stqh_first;\x0009\&amp;/* first element */\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-526"></a> \\x0009\&amp;struct type **stqh_last;\x0009\&amp;/* addr of last next element */\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-527"></a> \}\n\
<a name="line-528"></a> \\n\
<a name="line-529"></a> \#define\x0009\&amp;STAILQ_HEAD_INITIALIZER(head)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-530"></a> \\x0009\&amp;{ NULL, &amp;(head).stqh_first }\n\
<a name="line-531"></a> \\n\
<a name="line-532"></a> \#define\x0009\&amp;STAILQ_ENTRY(type)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-533"></a> \struct {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-534"></a> \\x0009\&amp;struct type *stqe_next;\x0009\&amp;/* next element */\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-535"></a> \}\n\
<a name="line-536"></a> \\n\
<a name="line-537"></a> \/*\n\
<a name="line-538"></a> \ * Singly-linked Tail queue functions.\n\
<a name="line-539"></a> \ */\n\
<a name="line-540"></a> \#define\x0009\&amp;STAILQ_INIT(head) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-541"></a> \\x0009\&amp;(head)-&gt;stqh_first = NULL;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-542"></a> \\x0009\&amp;(head)-&gt;stqh_last = &amp;(head)-&gt;stqh_first;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-543"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-544"></a> \\n\
<a name="line-545"></a> \#define\x0009\&amp;STAILQ_INSERT_HEAD(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-546"></a> \\x0009\&amp;if (((elm)-&gt;field.stqe_next = (head)-&gt;stqh_first) == NULL)\x0009\&amp;\\\n\
<a name="line-547"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;stqh_last = &amp;(elm)-&gt;field.stqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-548"></a> \\x0009\&amp;(head)-&gt;stqh_first = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-549"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-550"></a> \\n\
<a name="line-551"></a> \#define\x0009\&amp;STAILQ_INSERT_TAIL(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-552"></a> \\x0009\&amp;(elm)-&gt;field.stqe_next = NULL;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-553"></a> \\x0009\&amp;*(head)-&gt;stqh_last = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-554"></a> \\x0009\&amp;(head)-&gt;stqh_last = &amp;(elm)-&gt;field.stqe_next;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-555"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-556"></a> \\n\
<a name="line-557"></a> \#define\x0009\&amp;STAILQ_INSERT_AFTER(head, listelm, elm, field) do {\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-558"></a> \\x0009\&amp;if (((elm)-&gt;field.stqe_next = (listelm)-&gt;field.stqe_next) == NULL)\\\n\
<a name="line-559"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;stqh_last = &amp;(elm)-&gt;field.stqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-560"></a> \\x0009\&amp;(listelm)-&gt;field.stqe_next = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-561"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-562"></a> \\n\
<a name="line-563"></a> \#define\x0009\&amp;STAILQ_REMOVE_HEAD(head, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-564"></a> \\x0009\&amp;if (((head)-&gt;stqh_first = (head)-&gt;stqh_first-&gt;field.stqe_next) == NULL) \\\n\
<a name="line-565"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;stqh_last = &amp;(head)-&gt;stqh_first;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-566"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-567"></a> \\n\
<a name="line-568"></a> \#define\x0009\&amp;STAILQ_REMOVE(head, elm, type, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-569"></a> \\x0009\&amp;if ((head)-&gt;stqh_first == (elm)) {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-570"></a> \\x0009\&amp;\x0009\&amp;STAILQ_REMOVE_HEAD((head), field);\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-571"></a> \\x0009\&amp;} else {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-572"></a> \\x0009\&amp;\x0009\&amp;struct type *curelm = (head)-&gt;stqh_first;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-573"></a> \\x0009\&amp;\x0009\&amp;while (curelm-&gt;field.stqe_next != (elm))\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-574"></a> \\x0009\&amp;\x0009\&amp;\x0009\&amp;curelm = curelm-&gt;field.stqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-575"></a> \\x0009\&amp;\x0009\&amp;if ((curelm-&gt;field.stqe_next =\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-576"></a> \\x0009\&amp;\x0009\&amp;\x0009\&amp;curelm-&gt;field.stqe_next-&gt;field.stqe_next) == NULL) \\\n\
<a name="line-577"></a> \\x0009\&amp;\x0009\&amp;\x0009\&amp;    (head)-&gt;stqh_last = &amp;(curelm)-&gt;field.stqe_next; \\\n\
<a name="line-578"></a> \\x0009\&amp;}\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-579"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-580"></a> \\n\
<a name="line-581"></a> \#define\x0009\&amp;STAILQ_FOREACH(var, head, field)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-582"></a> \\x0009\&amp;for ((var) = ((head)-&gt;stqh_first);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-583"></a> \\x0009\&amp;\x0009\&amp;(var);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-584"></a> \\x0009\&amp;\x0009\&amp;(var) = ((var)-&gt;field.stqe_next))\n\
<a name="line-585"></a> \\n\
<a name="line-586"></a> \#define\x0009\&amp;STAILQ_CONCAT(head1, head2) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-587"></a> \\x0009\&amp;if (!STAILQ_EMPTY((head2))) {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-588"></a> \\x0009\&amp;\x0009\&amp;*(head1)-&gt;stqh_last = (head2)-&gt;stqh_first;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-589"></a> \\x0009\&amp;\x0009\&amp;(head1)-&gt;stqh_last = (head2)-&gt;stqh_last;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-590"></a> \\x0009\&amp;\x0009\&amp;STAILQ_INIT((head2));\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-591"></a> \\x0009\&amp;}\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-592"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-593"></a> \\n\
<a name="line-594"></a> \/*\n\
<a name="line-595"></a> \ * Singly-linked Tail queue access methods.\n\
<a name="line-596"></a> \ */\n\
<a name="line-597"></a> \#define\x0009\&amp;STAILQ_EMPTY(head)\x0009\&amp;((head)-&gt;stqh_first == NULL)\n\
<a name="line-598"></a> \#define\x0009\&amp;STAILQ_FIRST(head)\x0009\&amp;((head)-&gt;stqh_first)\n\
<a name="line-599"></a> \#define\x0009\&amp;STAILQ_NEXT(elm, field)\x0009\&amp;((elm)-&gt;field.stqe_next)\n\
<a name="line-600"></a> \\n\
<a name="line-601"></a> \/*\n\
<a name="line-602"></a> \ * Simple queue definitions.\n\
<a name="line-603"></a> \ */\n\
<a name="line-604"></a> \#define\x0009\&amp;SIMPLEQ_HEAD(name, type)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-605"></a> \struct name {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-606"></a> \\x0009\&amp;struct type *sqh_first;\x0009\&amp;/* first element */\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-607"></a> \\x0009\&amp;struct type **sqh_last;\x0009\&amp;/* addr of last next element */\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-608"></a> \}\n\
<a name="line-609"></a> \\n\
<a name="line-610"></a> \#define\x0009\&amp;SIMPLEQ_HEAD_INITIALIZER(head)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-611"></a> \\x0009\&amp;{ NULL, &amp;(head).sqh_first }\n\
<a name="line-612"></a> \\n\
<a name="line-613"></a> \#define\x0009\&amp;SIMPLEQ_ENTRY(type)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-614"></a> \struct {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-615"></a> \\x0009\&amp;struct type *sqe_next;\x0009\&amp;/* next element */\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-616"></a> \}\n\
<a name="line-617"></a> \\n\
<a name="line-618"></a> \/*\n\
<a name="line-619"></a> \ * Simple queue functions.\n\
<a name="line-620"></a> \ */\n\
<a name="line-621"></a> \#define\x0009\&amp;SIMPLEQ_INIT(head) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-622"></a> \\x0009\&amp;(head)-&gt;sqh_first = NULL;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-623"></a> \\x0009\&amp;(head)-&gt;sqh_last = &amp;(head)-&gt;sqh_first;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-624"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-625"></a> \\n\
<a name="line-626"></a> \#define\x0009\&amp;SIMPLEQ_INSERT_HEAD(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-627"></a> \\x0009\&amp;if (((elm)-&gt;field.sqe_next = (head)-&gt;sqh_first) == NULL)\x0009\&amp;\\\n\
<a name="line-628"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;sqh_last = &amp;(elm)-&gt;field.sqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-629"></a> \\x0009\&amp;(head)-&gt;sqh_first = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-630"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-631"></a> \\n\
<a name="line-632"></a> \#define\x0009\&amp;SIMPLEQ_INSERT_TAIL(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-633"></a> \\x0009\&amp;(elm)-&gt;field.sqe_next = NULL;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-634"></a> \\x0009\&amp;*(head)-&gt;sqh_last = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-635"></a> \\x0009\&amp;(head)-&gt;sqh_last = &amp;(elm)-&gt;field.sqe_next;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-636"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-637"></a> \\n\
<a name="line-638"></a> \#define\x0009\&amp;SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-639"></a> \\x0009\&amp;if (((elm)-&gt;field.sqe_next = (listelm)-&gt;field.sqe_next) == NULL)\\\n\
<a name="line-640"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;sqh_last = &amp;(elm)-&gt;field.sqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-641"></a> \\x0009\&amp;(listelm)-&gt;field.sqe_next = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-642"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-643"></a> \\n\
<a name="line-644"></a> \#define\x0009\&amp;SIMPLEQ_REMOVE_HEAD(head, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-645"></a> \\x0009\&amp;if (((head)-&gt;sqh_first = (head)-&gt;sqh_first-&gt;field.sqe_next) == NULL) \\\n\
<a name="line-646"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;sqh_last = &amp;(head)-&gt;sqh_first;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-647"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-648"></a> \\n\
<a name="line-649"></a> \#define\x0009\&amp;SIMPLEQ_REMOVE(head, elm, type, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-650"></a> \\x0009\&amp;if ((head)-&gt;sqh_first == (elm)) {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-651"></a> \\x0009\&amp;\x0009\&amp;SIMPLEQ_REMOVE_HEAD((head), field);\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-652"></a> \\x0009\&amp;} else {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-653"></a> \\x0009\&amp;\x0009\&amp;struct type *curelm = (head)-&gt;sqh_first;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-654"></a> \\x0009\&amp;\x0009\&amp;while (curelm-&gt;field.sqe_next != (elm))\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-655"></a> \\x0009\&amp;\x0009\&amp;\x0009\&amp;curelm = curelm-&gt;field.sqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-656"></a> \\x0009\&amp;\x0009\&amp;if ((curelm-&gt;field.sqe_next =\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-657"></a> \\x0009\&amp;\x0009\&amp;\x0009\&amp;curelm-&gt;field.sqe_next-&gt;field.sqe_next) == NULL) \\\n\
<a name="line-658"></a> \\x0009\&amp;\x0009\&amp;\x0009\&amp;    (head)-&gt;sqh_last = &amp;(curelm)-&gt;field.sqe_next; \\\n\
<a name="line-659"></a> \\x0009\&amp;}\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-660"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-661"></a> \\n\
<a name="line-662"></a> \#define\x0009\&amp;SIMPLEQ_FOREACH(var, head, field)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-663"></a> \\x0009\&amp;for ((var) = ((head)-&gt;sqh_first);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-664"></a> \\x0009\&amp;\x0009\&amp;(var);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-665"></a> \\x0009\&amp;\x0009\&amp;(var) = ((var)-&gt;field.sqe_next))\n\
<a name="line-666"></a> \\n\
<a name="line-667"></a> \/*\n\
<a name="line-668"></a> \ * Simple queue access methods.\n\
<a name="line-669"></a> \ */\n\
<a name="line-670"></a> \#define\x0009\&amp;SIMPLEQ_EMPTY(head)\x0009\&amp;\x0009\&amp;((head)-&gt;sqh_first == NULL)\n\
<a name="line-671"></a> \#define\x0009\&amp;SIMPLEQ_FIRST(head)\x0009\&amp;\x0009\&amp;((head)-&gt;sqh_first)\n\
<a name="line-672"></a> \#define\x0009\&amp;SIMPLEQ_NEXT(elm, field)\x0009\&amp;((elm)-&gt;field.sqe_next)\n\
<a name="line-673"></a> \\n\
<a name="line-674"></a> \/*\n\
<a name="line-675"></a> \ * Tail queue definitions.\n\
<a name="line-676"></a> \ */\n\
<a name="line-677"></a> \#define\x0009\&amp;_TAILQ_HEAD(name, type, qual)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-678"></a> \struct name {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-679"></a> \\x0009\&amp;qual type *tqh_first;\x0009\&amp;\x0009\&amp;/* first element */\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-680"></a> \\x0009\&amp;qual type *qual *tqh_last;\x0009\&amp;/* addr of last next element */\x0009\&amp;\\\n\
<a name="line-681"></a> \}\n\
<a name="line-682"></a> \#define TAILQ_HEAD(name, type)\x0009\&amp;_TAILQ_HEAD(name, struct type,)\n\
<a name="line-683"></a> \\n\
<a name="line-684"></a> \#define\x0009\&amp;TAILQ_HEAD_INITIALIZER(head)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-685"></a> \\x0009\&amp;{ NULL, &amp;(head).tqh_first }\n\
<a name="line-686"></a> \\n\
<a name="line-687"></a> \#define\x0009\&amp;_TAILQ_ENTRY(type, qual)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-688"></a> \struct {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-689"></a> \\x0009\&amp;qual type *tqe_next;\x0009\&amp;\x0009\&amp;/* next element */\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-690"></a> \\x0009\&amp;qual type *qual *tqe_prev;\x0009\&amp;/* address of previous next element */\\\n\
<a name="line-691"></a> \}\n\
<a name="line-692"></a> \#define TAILQ_ENTRY(type)\x0009\&amp;_TAILQ_ENTRY(struct type,)\n\
<a name="line-693"></a> \\n\
<a name="line-694"></a> \/*\n\
<a name="line-695"></a> \ * Tail queue functions.\n\
<a name="line-696"></a> \ */\n\
<a name="line-697"></a> \#define\x0009\&amp;TAILQ_INIT(head) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-698"></a> \\x0009\&amp;(head)-&gt;tqh_first = NULL;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-699"></a> \\x0009\&amp;(head)-&gt;tqh_last = &amp;(head)-&gt;tqh_first;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-700"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-701"></a> \\n\
<a name="line-702"></a> \#define\x0009\&amp;TAILQ_INSERT_HEAD(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-703"></a> \\x0009\&amp;if (((elm)-&gt;field.tqe_next = (head)-&gt;tqh_first) != NULL)\x0009\&amp;\\\n\
<a name="line-704"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;tqh_first-&gt;field.tqe_prev =\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-705"></a> \\x0009\&amp;\x0009\&amp;    &amp;(elm)-&gt;field.tqe_next;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-706"></a> \\x0009\&amp;else\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-707"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-708"></a> \\x0009\&amp;(head)-&gt;tqh_first = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-709"></a> \\x0009\&amp;(elm)-&gt;field.tqe_prev = &amp;(head)-&gt;tqh_first;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-710"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-711"></a> \\n\
<a name="line-712"></a> \#define\x0009\&amp;TAILQ_INSERT_TAIL(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-713"></a> \\x0009\&amp;(elm)-&gt;field.tqe_next = NULL;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-714"></a> \\x0009\&amp;(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-715"></a> \\x0009\&amp;*(head)-&gt;tqh_last = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-716"></a> \\x0009\&amp;(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-717"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-718"></a> \\n\
<a name="line-719"></a> \#define\x0009\&amp;TAILQ_INSERT_AFTER(head, listelm, elm, field) do {\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-720"></a> \\x0009\&amp;if (((elm)-&gt;field.tqe_next = (listelm)-&gt;field.tqe_next) != NULL)\\\n\
<a name="line-721"></a> \\x0009\&amp;\x0009\&amp;(elm)-&gt;field.tqe_next-&gt;field.tqe_prev = \x0009\&amp;\x0009\&amp;\\\n\
<a name="line-722"></a> \\x0009\&amp;\x0009\&amp;    &amp;(elm)-&gt;field.tqe_next;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-723"></a> \\x0009\&amp;else\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-724"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-725"></a> \\x0009\&amp;(listelm)-&gt;field.tqe_next = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-726"></a> \\x0009\&amp;(elm)-&gt;field.tqe_prev = &amp;(listelm)-&gt;field.tqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-727"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-728"></a> \\n\
<a name="line-729"></a> \#define\x0009\&amp;TAILQ_INSERT_BEFORE(listelm, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-730"></a> \\x0009\&amp;(elm)-&gt;field.tqe_prev = (listelm)-&gt;field.tqe_prev;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-731"></a> \\x0009\&amp;(elm)-&gt;field.tqe_next = (listelm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-732"></a> \\x0009\&amp;*(listelm)-&gt;field.tqe_prev = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-733"></a> \\x0009\&amp;(listelm)-&gt;field.tqe_prev = &amp;(elm)-&gt;field.tqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-734"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-735"></a> \\n\
<a name="line-736"></a> \#define\x0009\&amp;TAILQ_REMOVE(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-737"></a> \\x0009\&amp;if (((elm)-&gt;field.tqe_next) != NULL)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-738"></a> \\x0009\&amp;\x0009\&amp;(elm)-&gt;field.tqe_next-&gt;field.tqe_prev = \x0009\&amp;\x0009\&amp;\\\n\
<a name="line-739"></a> \\x0009\&amp;\x0009\&amp;    (elm)-&gt;field.tqe_prev;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-740"></a> \\x0009\&amp;else\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-741"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-742"></a> \\x0009\&amp;*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-743"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-744"></a> \\n\
<a name="line-745"></a> \#define\x0009\&amp;TAILQ_FOREACH(var, head, field)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-746"></a> \\x0009\&amp;for ((var) = ((head)-&gt;tqh_first);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-747"></a> \\x0009\&amp;\x0009\&amp;(var);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-748"></a> \\x0009\&amp;\x0009\&amp;(var) = ((var)-&gt;field.tqe_next))\n\
<a name="line-749"></a> \\n\
<a name="line-750"></a> \#define\x0009\&amp;TAILQ_FOREACH_REVERSE(var, head, headname, field)\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-751"></a> \\x0009\&amp;for ((var) = (*(((struct headname *)((head)-&gt;tqh_last))-&gt;tqh_last));\x0009\&amp;\\\n\
<a name="line-752"></a> \\x0009\&amp;\x0009\&amp;(var);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-753"></a> \\x0009\&amp;\x0009\&amp;(var) = (*(((struct headname *)((var)-&gt;field.tqe_prev))-&gt;tqh_last)))\n\
<a name="line-754"></a> \\n\
<a name="line-755"></a> \#define\x0009\&amp;TAILQ_CONCAT(head1, head2, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-756"></a> \\x0009\&amp;if (!TAILQ_EMPTY(head2)) {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-757"></a> \\x0009\&amp;\x0009\&amp;*(head1)-&gt;tqh_last = (head2)-&gt;tqh_first;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-758"></a> \\x0009\&amp;\x0009\&amp;(head2)-&gt;tqh_first-&gt;field.tqe_prev = (head1)-&gt;tqh_last;\x0009\&amp;\\\n\
<a name="line-759"></a> \\x0009\&amp;\x0009\&amp;(head1)-&gt;tqh_last = (head2)-&gt;tqh_last;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-760"></a> \\x0009\&amp;\x0009\&amp;TAILQ_INIT((head2));\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-761"></a> \\x0009\&amp;}\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-762"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-763"></a> \\n\
<a name="line-764"></a> \/*\n\
<a name="line-765"></a> \ * Tail queue access methods.\n\
<a name="line-766"></a> \ */\n\
<a name="line-767"></a> \#define\x0009\&amp;TAILQ_EMPTY(head)\x0009\&amp;\x0009\&amp;((head)-&gt;tqh_first == NULL)\n\
<a name="line-768"></a> \#define\x0009\&amp;TAILQ_FIRST(head)\x0009\&amp;\x0009\&amp;((head)-&gt;tqh_first)\n\
<a name="line-769"></a> \#define\x0009\&amp;TAILQ_NEXT(elm, field)\x0009\&amp;\x0009\&amp;((elm)-&gt;field.tqe_next)\n\
<a name="line-770"></a> \\n\
<a name="line-771"></a> \#define\x0009\&amp;TAILQ_LAST(head, headname) \\\n\
<a name="line-772"></a> \\x0009\&amp;(*(((struct headname *)((head)-&gt;tqh_last))-&gt;tqh_last))\n\
<a name="line-773"></a> \#define\x0009\&amp;TAILQ_PREV(elm, headname, field) \\\n\
<a name="line-774"></a> \\x0009\&amp;(*(((struct headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))\n\
<a name="line-775"></a> \\n\
<a name="line-776"></a> \/*\n\
<a name="line-777"></a> \ * Circular queue definitions.\n\
<a name="line-778"></a> \ */\n\
<a name="line-779"></a> \#define\x0009\&amp;CIRCLEQ_HEAD(name, type)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-780"></a> \struct name {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-781"></a> \\x0009\&amp;struct type *cqh_first;\x0009\&amp;\x0009\&amp;/* first element */\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-782"></a> \\x0009\&amp;struct type *cqh_last;\x0009\&amp;\x0009\&amp;/* last element */\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-783"></a> \}\n\
<a name="line-784"></a> \\n\
<a name="line-785"></a> \#define\x0009\&amp;CIRCLEQ_HEAD_INITIALIZER(head)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-786"></a> \\x0009\&amp;{ (void *)&amp;head, (void *)&amp;head }\n\
<a name="line-787"></a> \\n\
<a name="line-788"></a> \#define\x0009\&amp;CIRCLEQ_ENTRY(type)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-789"></a> \struct {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-790"></a> \\x0009\&amp;struct type *cqe_next;\x0009\&amp;\x0009\&amp;/* next element */\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-791"></a> \\x0009\&amp;struct type *cqe_prev;\x0009\&amp;\x0009\&amp;/* previous element */\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-792"></a> \}\n\
<a name="line-793"></a> \\n\
<a name="line-794"></a> \/*\n\
<a name="line-795"></a> \ * Circular queue functions.\n\
<a name="line-796"></a> \ */\n\
<a name="line-797"></a> \#define\x0009\&amp;CIRCLEQ_INIT(head) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-798"></a> \\x0009\&amp;(head)-&gt;cqh_first = (void *)(head);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-799"></a> \\x0009\&amp;(head)-&gt;cqh_last = (void *)(head);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-800"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-801"></a> \\n\
<a name="line-802"></a> \#define\x0009\&amp;CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-803"></a> \\x0009\&amp;(elm)-&gt;field.cqe_next = (listelm)-&gt;field.cqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-804"></a> \\x0009\&amp;(elm)-&gt;field.cqe_prev = (listelm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-805"></a> \\x0009\&amp;if ((listelm)-&gt;field.cqe_next == (void *)(head))\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-806"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;cqh_last = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-807"></a> \\x0009\&amp;else\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-808"></a> \\x0009\&amp;\x0009\&amp;(listelm)-&gt;field.cqe_next-&gt;field.cqe_prev = (elm);\x0009\&amp;\\\n\
<a name="line-809"></a> \\x0009\&amp;(listelm)-&gt;field.cqe_next = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-810"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-811"></a> \\n\
<a name="line-812"></a> \#define\x0009\&amp;CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-813"></a> \\x0009\&amp;(elm)-&gt;field.cqe_next = (listelm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-814"></a> \\x0009\&amp;(elm)-&gt;field.cqe_prev = (listelm)-&gt;field.cqe_prev;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-815"></a> \\x0009\&amp;if ((listelm)-&gt;field.cqe_prev == (void *)(head))\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-816"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;cqh_first = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-817"></a> \\x0009\&amp;else\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-818"></a> \\x0009\&amp;\x0009\&amp;(listelm)-&gt;field.cqe_prev-&gt;field.cqe_next = (elm);\x0009\&amp;\\\n\
<a name="line-819"></a> \\x0009\&amp;(listelm)-&gt;field.cqe_prev = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-820"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-821"></a> \\n\
<a name="line-822"></a> \#define\x0009\&amp;CIRCLEQ_INSERT_HEAD(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-823"></a> \\x0009\&amp;(elm)-&gt;field.cqe_next = (head)-&gt;cqh_first;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-824"></a> \\x0009\&amp;(elm)-&gt;field.cqe_prev = (void *)(head);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-825"></a> \\x0009\&amp;if ((head)-&gt;cqh_last == (void *)(head))\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-826"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;cqh_last = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-827"></a> \\x0009\&amp;else\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-828"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;cqh_first-&gt;field.cqe_prev = (elm);\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-829"></a> \\x0009\&amp;(head)-&gt;cqh_first = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-830"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-831"></a> \\n\
<a name="line-832"></a> \#define\x0009\&amp;CIRCLEQ_INSERT_TAIL(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-833"></a> \\x0009\&amp;(elm)-&gt;field.cqe_next = (void *)(head);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-834"></a> \\x0009\&amp;(elm)-&gt;field.cqe_prev = (head)-&gt;cqh_last;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-835"></a> \\x0009\&amp;if ((head)-&gt;cqh_first == (void *)(head))\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-836"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;cqh_first = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-837"></a> \\x0009\&amp;else\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-838"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;cqh_last-&gt;field.cqe_next = (elm);\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-839"></a> \\x0009\&amp;(head)-&gt;cqh_last = (elm);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-840"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-841"></a> \\n\
<a name="line-842"></a> \#define\x0009\&amp;CIRCLEQ_REMOVE(head, elm, field) do {\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-843"></a> \\x0009\&amp;if ((elm)-&gt;field.cqe_next == (void *)(head))\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-844"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;cqh_last = (elm)-&gt;field.cqe_prev;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-845"></a> \\x0009\&amp;else\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-846"></a> \\x0009\&amp;\x0009\&amp;(elm)-&gt;field.cqe_next-&gt;field.cqe_prev =\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-847"></a> \\x0009\&amp;\x0009\&amp;    (elm)-&gt;field.cqe_prev;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-848"></a> \\x0009\&amp;if ((elm)-&gt;field.cqe_prev == (void *)(head))\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-849"></a> \\x0009\&amp;\x0009\&amp;(head)-&gt;cqh_first = (elm)-&gt;field.cqe_next;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-850"></a> \\x0009\&amp;else\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-851"></a> \\x0009\&amp;\x0009\&amp;(elm)-&gt;field.cqe_prev-&gt;field.cqe_next =\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-852"></a> \\x0009\&amp;\x0009\&amp;    (elm)-&gt;field.cqe_next;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-853"></a> \} while (/*CONSTCOND*/0)\n\
<a name="line-854"></a> \\n\
<a name="line-855"></a> \#define\x0009\&amp;CIRCLEQ_FOREACH(var, head, field)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-856"></a> \\x0009\&amp;for ((var) = ((head)-&gt;cqh_first);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-857"></a> \\x0009\&amp;\x0009\&amp;(var) != (const void *)(head);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-858"></a> \\x0009\&amp;\x0009\&amp;(var) = ((var)-&gt;field.cqe_next))\n\
<a name="line-859"></a> \\n\
<a name="line-860"></a> \#define\x0009\&amp;CIRCLEQ_FOREACH_REVERSE(var, head, field)\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-861"></a> \\x0009\&amp;for ((var) = ((head)-&gt;cqh_last);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-862"></a> \\x0009\&amp;\x0009\&amp;(var) != (const void *)(head);\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-863"></a> \\x0009\&amp;\x0009\&amp;(var) = ((var)-&gt;field.cqe_prev))\n\
<a name="line-864"></a> \\n\
<a name="line-865"></a> \/*\n\
<a name="line-866"></a> \ * Circular queue access methods.\n\
<a name="line-867"></a> \ */\n\
<a name="line-868"></a> \#define\x0009\&amp;CIRCLEQ_EMPTY(head)\x0009\&amp;\x0009\&amp;((head)-&gt;cqh_first == (void *)(head))\n\
<a name="line-869"></a> \#define\x0009\&amp;CIRCLEQ_FIRST(head)\x0009\&amp;\x0009\&amp;((head)-&gt;cqh_first)\n\
<a name="line-870"></a> \#define\x0009\&amp;CIRCLEQ_LAST(head)\x0009\&amp;\x0009\&amp;((head)-&gt;cqh_last)\n\
<a name="line-871"></a> \#define\x0009\&amp;CIRCLEQ_NEXT(elm, field)\x0009\&amp;((elm)-&gt;field.cqe_next)\n\
<a name="line-872"></a> \#define\x0009\&amp;CIRCLEQ_PREV(elm, field)\x0009\&amp;((elm)-&gt;field.cqe_prev)\n\
<a name="line-873"></a> \\n\
<a name="line-874"></a> \#define CIRCLEQ_LOOP_NEXT(head, elm, field)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-875"></a> \\x0009\&amp;(((elm)-&gt;field.cqe_next == (void *)(head))\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-876"></a> \\x0009\&amp;    ? ((head)-&gt;cqh_first)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-877"></a> \\x0009\&amp;    : (elm-&gt;field.cqe_next))\n\
<a name="line-878"></a> \#define CIRCLEQ_LOOP_PREV(head, elm, field)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-879"></a> \\x0009\&amp;(((elm)-&gt;field.cqe_prev == (void *)(head))\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-880"></a> \\x0009\&amp;    ? ((head)-&gt;cqh_last)\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\x0009\&amp;\\\n\
<a name="line-881"></a> \\x0009\&amp;    : (elm-&gt;field.cqe_prev))\n\
<a name="line-882"></a> \\n\
<a name="line-883"></a> \#endif\x0009\&amp;/* sys/queue.h */\n\
<a name="line-884"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-885"></a>
<a name="line-886"></a><a name="hsffi_h"></a><span class='hs-comment'>-- | Generated from rts\/HsFFI.h</span>
<a name="line-887"></a><span class='hs-comment'>{-# NOINLINE hsffi_h #-}</span>
<a name="line-888"></a><span class='hs-definition'>hsffi_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-889"></a><span class='hs-definition'>hsffi_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-890"></a> \/* HsFFI.h for jhc */\n\
<a name="line-891"></a> \\n\
<a name="line-892"></a> \#ifndef _JHC_HSFFI_H\n\
<a name="line-893"></a> \#define _JHC_HSFFI_H\n\
<a name="line-894"></a> \\n\
<a name="line-895"></a> \#include &lt;stdint.h&gt;\n\
<a name="line-896"></a> \#include &lt;stdbool.h&gt;\n\
<a name="line-897"></a> \#include &lt;stddef.h&gt;\n\
<a name="line-898"></a> \\n\
<a name="line-899"></a> \typedef int32_t HsInt;\n\
<a name="line-900"></a> \typedef int8_t  HsInt8;\n\
<a name="line-901"></a> \typedef int16_t HsInt16;\n\
<a name="line-902"></a> \typedef int32_t HsInt32;\n\
<a name="line-903"></a> \typedef int64_t HsInt64;\n\
<a name="line-904"></a> \\n\
<a name="line-905"></a> \typedef uint32_t HsWord;\n\
<a name="line-906"></a> \typedef uint8_t  HsWord8;\n\
<a name="line-907"></a> \typedef uint16_t HsWord16;\n\
<a name="line-908"></a> \typedef uint32_t HsWord32;\n\
<a name="line-909"></a> \typedef uint64_t HsWord64;\n\
<a name="line-910"></a> \\n\
<a name="line-911"></a> \typedef wchar_t HsChar;\n\
<a name="line-912"></a> \typedef bool HsBool;\n\
<a name="line-913"></a> \\n\
<a name="line-914"></a> \typedef double HsDouble;\n\
<a name="line-915"></a> \typedef float HsFloat;\n\
<a name="line-916"></a> \\n\
<a name="line-917"></a> \typedef void *HsPtr;\n\
<a name="line-918"></a> \typedef void (*HsFunPtr)(void);\n\
<a name="line-919"></a> \typedef void *HsStablePtr;\n\
<a name="line-920"></a> \\n\
<a name="line-921"></a> \#define HS_BOOL_FALSE 0\n\
<a name="line-922"></a> \#define HS_BOOL_TRUE 1\n\
<a name="line-923"></a> \\n\
<a name="line-924"></a> \void hs_init (int *argc, char **argv[]);\n\
<a name="line-925"></a> \void hs_exit (void);\n\
<a name="line-926"></a> \void hs_set_argv(int argc, char *argv[]);\n\
<a name="line-927"></a> \void hs_perform_gc(void);\n\
<a name="line-928"></a> \void hs_free_stable_ptr(HsStablePtr sp);\n\
<a name="line-929"></a> \void hs_free_fun_ptr(HsFunPtr fp);\n\
<a name="line-930"></a> \\n\
<a name="line-931"></a> \#endif\n\
<a name="line-932"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-933"></a>
<a name="line-934"></a><a name="wsize_h"></a><span class='hs-comment'>-- | Generated from rts\/sys\/wsize.h</span>
<a name="line-935"></a><span class='hs-comment'>{-# NOINLINE wsize_h #-}</span>
<a name="line-936"></a><span class='hs-definition'>wsize_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-937"></a><span class='hs-definition'>wsize_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-938"></a> \#ifndef WSIZE_H\n\
<a name="line-939"></a> \#define WSIZE_H\n\
<a name="line-940"></a> \\n\
<a name="line-941"></a> \/*\n\
<a name="line-942"></a> \ * wsize.h\n\
<a name="line-943"></a> \ * define appropriate __WORDSIZE and __BYTE_ORDER macros\n\
<a name="line-944"></a> \ *\n\
<a name="line-945"></a> \ * always use operating systems headers rather than checking for architectures\n\
<a name="line-946"></a> \ * when possible. if adding new cases. Checking the CPU type should be a last\n\
<a name="line-947"></a> \ * resort.\n\
<a name="line-948"></a> \ *\n\
<a name="line-949"></a> \ */\n\
<a name="line-950"></a> \\n\
<a name="line-951"></a> \#include &lt;limits.h&gt;\n\
<a name="line-952"></a> \\n\
<a name="line-953"></a> \#ifdef __linux__\n\
<a name="line-954"></a> \#include&lt;endian.h&gt;\n\
<a name="line-955"></a> \#endif\n\
<a name="line-956"></a> \\n\
<a name="line-957"></a> \#ifndef __LITTLE_ENDIAN\n\
<a name="line-958"></a> \#define\x0009\&amp;__LITTLE_ENDIAN\x0009\&amp;1234\n\
<a name="line-959"></a> \#endif\n\
<a name="line-960"></a> \#ifndef __BIG_ENDIAN\n\
<a name="line-961"></a> \#define\x0009\&amp;__BIG_ENDIAN\x0009\&amp;4321\n\
<a name="line-962"></a> \#endif\n\
<a name="line-963"></a> \#ifndef __PDP_ENDIAN\n\
<a name="line-964"></a> \#define\x0009\&amp;__PDP_ENDIAN\x0009\&amp;3412\n\
<a name="line-965"></a> \#endif\n\
<a name="line-966"></a> \\n\
<a name="line-967"></a> \#ifndef __BYTE_ORDER\n\
<a name="line-968"></a> \#ifdef _BIG_ENDIAN\n\
<a name="line-969"></a> \#define __BYTE_ORDER __BIG_ENDIAN\n\
<a name="line-970"></a> \#elif defined(__BIG_ENDIAN__)\n\
<a name="line-971"></a> \#define __BYTE_ORDER __BIG_ENDIAN\n\
<a name="line-972"></a> \#elif defined(_LITTLE_ENDIAN)\n\
<a name="line-973"></a> \#define __BYTE_ORDER __LITTLE_ENDIAN\n\
<a name="line-974"></a> \#elif defined(__LITTLE_ENDIAN__)\n\
<a name="line-975"></a> \#define __BYTE_ORDER __LITTLE_ENDIAN\n\
<a name="line-976"></a> \#elif defined(__i386__)\n\
<a name="line-977"></a> \#define __BYTE_ORDER __LITTLE_ENDIAN\n\
<a name="line-978"></a> \#else\n\
<a name="line-979"></a> \#error Could not determine Byte Order\n\
<a name="line-980"></a> \#endif\n\
<a name="line-981"></a> \#endif\n\
<a name="line-982"></a> \\n\
<a name="line-983"></a> \#ifndef __WORDSIZE\n\
<a name="line-984"></a> \#ifdef __SIZEOF_POINTER__\n\
<a name="line-985"></a> \#define __WORDSIZE (CHAR_BIT*__SIZEOF_POINTER__)\n\
<a name="line-986"></a> \#elif defined(__i386__)\n\
<a name="line-987"></a> \#define __WORDSIZE 32\n\
<a name="line-988"></a> \#elif defined(__x86_64__)\n\
<a name="line-989"></a> \#define __WORDSIZE 64\n\
<a name="line-990"></a> \#else\n\
<a name="line-991"></a> \#error Could not determine bitsize\n\
<a name="line-992"></a> \#endif\n\
<a name="line-993"></a> \#endif\n\
<a name="line-994"></a> \\n\
<a name="line-995"></a> \#ifdef TEST_WSIZE\n\
<a name="line-996"></a> \#include &lt;stdio.h&gt;\n\
<a name="line-997"></a> \int\n\
<a name="line-998"></a> \main(int argc, char *argv[])\n\
<a name="line-999"></a> \{\n\
<a name="line-1000"></a> \    printf(\"__WORDSIZE:   %i\\n\", __WORDSIZE);\n\
<a name="line-1001"></a> \    printf(\"__BYTE_ORDER: %i\\n\", __BYTE_ORDER);\n\
<a name="line-1002"></a> \    return 0;\n\
<a name="line-1003"></a> \}\n\
<a name="line-1004"></a> \#endif\n\
<a name="line-1005"></a> \\n\
<a name="line-1006"></a> \#endif\n\
<a name="line-1007"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-1008"></a>
<a name="line-1009"></a><a name="bitarray_h"></a><span class='hs-comment'>-- | Generated from rts\/sys\/bitarray.h</span>
<a name="line-1010"></a><span class='hs-comment'>{-# NOINLINE bitarray_h #-}</span>
<a name="line-1011"></a><span class='hs-definition'>bitarray_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-1012"></a><span class='hs-definition'>bitarray_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-1013"></a> \#ifndef BITARRAY_H\n\
<a name="line-1014"></a> \#define BITARRAY_H\n\
<a name="line-1015"></a> \\n\
<a name="line-1016"></a> \#include &lt;limits.h&gt;\n\
<a name="line-1017"></a> \#include &lt;stdbool.h&gt;\n\
<a name="line-1018"></a> \\n\
<a name="line-1019"></a> \typedef unsigned long bitarray_t;\n\
<a name="line-1020"></a> \\n\
<a name="line-1021"></a> \#define BITS_PER_UNIT (bitarray_t)(CHAR_BIT*sizeof(bitarray_t))\n\
<a name="line-1022"></a> \#define BITARRAY_SIZE(bits) (((bits) + (BITS_PER_UNIT - 1)) / BITS_PER_UNIT)\n\
<a name="line-1023"></a> \#define BITARRAY_SIZE_IN_BYTES(bits) (sizeof(bitarray_t)*BITARRAY_SIZE(bits))\n\
<a name="line-1024"></a> \\n\
<a name="line-1025"></a> \#define WHICH_BIT(bit)  \\\n\
<a name="line-1026"></a> \    (1UL &lt;&lt; ((((bitarray_t)(bit)) % BITS_PER_UNIT)))\n\
<a name="line-1027"></a> \\n\
<a name="line-1028"></a> \#define OFFSET_IN_ARRAY(array,bit) \\\n\
<a name="line-1029"></a> \    (((bitarray_t *)(array))[((bitarray_t)(bit)) / BITS_PER_UNIT])\n\
<a name="line-1030"></a> \\n\
<a name="line-1031"></a> \#define BIT_IS_SET(array,bit)  \\\n\
<a name="line-1032"></a> \    (OFFSET_IN_ARRAY(array,bit) &amp; WHICH_BIT(bit))\n\
<a name="line-1033"></a> \\n\
<a name="line-1034"></a> \#define BIT_IS_UNSET(array,bit) \\\n\
<a name="line-1035"></a> \    (!(BIT_IS_SET(array,bit)))\n\
<a name="line-1036"></a> \\n\
<a name="line-1037"></a> \#define BIT_SET(array,bit) \\\n\
<a name="line-1038"></a> \    (OFFSET_IN_ARRAY(array,bit) |= WHICH_BIT(bit))\n\
<a name="line-1039"></a> \\n\
<a name="line-1040"></a> \#define BIT_UNSET(array,bit) \\\n\
<a name="line-1041"></a> \    (OFFSET_IN_ARRAY(array,bit) &amp;= ~WHICH_BIT(bit))\n\
<a name="line-1042"></a> \\n\
<a name="line-1043"></a> \#define BIT_TOGGLE(array,bit) \\\n\
<a name="line-1044"></a> \    (OFFSET_IN_ARRAY(array,bit) ^= WHICH_BIT(bit))\n\
<a name="line-1045"></a> \\n\
<a name="line-1046"></a> \#define BIT_COPY(dest,src,bit)  \\\n\
<a name="line-1047"></a> \    do { BIT_IS_SET((src),(bit)) ? BIT_SET((dest),(bit)) : BIT_UNSET((dest),(bit)) } while(0)\n\
<a name="line-1048"></a> \\n\
<a name="line-1049"></a> \#define BIT_VALUE(array,bit) \\\n\
<a name="line-1050"></a> \    (BIT_IS_SET((array),(bit)) ? true : false)\n\
<a name="line-1051"></a> \\n\
<a name="line-1052"></a> \#define BIT_SET_VALUE(array,bit,value) \\\n\
<a name="line-1053"></a> \    do { (value) ? BIT_SET((array),(bit)) : BIT_UNSET((array),(bit)) } while(0)\n\
<a name="line-1054"></a> \\n\
<a name="line-1055"></a> \#endif\n\
<a name="line-1056"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-1057"></a>
<a name="line-1058"></a><a name="changelog"></a><span class='hs-comment'>-- | Generated from ChangeLog</span>
<a name="line-1059"></a><span class='hs-comment'>{-# NOINLINE changelog #-}</span>
<a name="line-1060"></a><span class='hs-definition'>changelog</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-1061"></a><span class='hs-definition'>changelog</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-1062"></a> \commit e56ab3927c0329621b546c23e07ace0a1452adf4\n\
<a name="line-1063"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1064"></a> \Date:   Sat Jun 8 04:11:23 2013 +0900\n\
<a name="line-1065"></a> \\n\
<a name="line-1066"></a> \    Add publish_haddock target.\n\
<a name="line-1067"></a> \\n\
<a name="line-1068"></a> \commit 2c3511d7c0c6d8cc53b220b3c9482de2dac74bf1\n\
<a name="line-1069"></a> \Author: Kiwamu Okabe &lt;kiwamu@gmail.com&gt;\n\
<a name="line-1070"></a> \Date:   Sat Jun 8 03:07:38 2013 +0900\n\
<a name="line-1071"></a> \\n\
<a name="line-1072"></a> \    Update README.md\n\
<a name="line-1073"></a> \\n\
<a name="line-1074"></a> \commit bc4be9e5eaae791cc7db7320e72a6040a22b8209\n\
<a name="line-1075"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1076"></a> \Date:   Sat Jun 8 03:01:33 2013 +0900\n\
<a name="line-1077"></a> \\n\
<a name="line-1078"></a> \    Add compile flow image (png).\n\
<a name="line-1079"></a> \\n\
<a name="line-1080"></a> \commit a8db1b0ec2f1af7af0a2b3d16a4c930338768aba\n\
<a name="line-1081"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1082"></a> \Date:   Sat Jun 8 02:33:40 2013 +0900\n\
<a name="line-1083"></a> \\n\
<a name="line-1084"></a> \    Bump up version 0.8.0.6.\n\
<a name="line-1085"></a> \\n\
<a name="line-1086"></a> \commit 702d796aea22d1129491bb49b66a8a9a4b8ef901\n\
<a name="line-1087"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1088"></a> \Date:   Sat Jun 8 01:53:46 2013 +0900\n\
<a name="line-1089"></a> \\n\
<a name="line-1090"></a> \    Add Ajhc 0.8.0.5 Release Notes.\n\
<a name="line-1091"></a> \\n\
<a name="line-1092"></a> \commit 07c3dfbf0300b482393dae85a6a9c52599d303fa\n\
<a name="line-1093"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1094"></a> \Date:   Sat Jun 8 01:37:12 2013 +0900\n\
<a name="line-1095"></a> \\n\
<a name="line-1096"></a> \    Add public types to haddock.\n\
<a name="line-1097"></a> \\n\
<a name="line-1098"></a> \commit 216ce6a8fe17b0fa7c64b98db04ff9d07b2c5a39\n\
<a name="line-1099"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1100"></a> \Date:   Fri Jun 7 22:48:11 2013 +0900\n\
<a name="line-1101"></a> \\n\
<a name="line-1102"></a> \    Avoid haddock parser error.\n\
<a name="line-1103"></a> \\n\
<a name="line-1104"></a> \commit b4b306d1472bba4ea7bfcf743eb7e770e2e2aa9f\n\
<a name="line-1105"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1106"></a> \Date:   Fri Jun 7 22:10:04 2013 +0900\n\
<a name="line-1107"></a> \\n\
<a name="line-1108"></a> \    Need import Prelude hiding (catch) for GHC 7.4.\n\
<a name="line-1109"></a> \\n\
<a name="line-1110"></a> \commit 7ae0f0c227d2c49f41c80e6192dbd038c3ee0416\n\
<a name="line-1111"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1112"></a> \Date:   Fri Jun 7 21:47:23 2013 +0900\n\
<a name="line-1113"></a> \\n\
<a name="line-1114"></a> \    Now run cabal haddock by hand.\n\
<a name="line-1115"></a> \\n\
<a name="line-1116"></a> \commit c6044d3b4c10aa3d5b0300684be07167f0a5e8e1\n\
<a name="line-1117"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1118"></a> \Date:   Fri Jun 7 21:42:20 2013 +0900\n\
<a name="line-1119"></a> \\n\
<a name="line-1120"></a> \    Split library and program.\n\
<a name="line-1121"></a> \\n\
<a name="line-1122"></a> \commit f5fdf2ba0f79beab7d3cb1ef4cc3180c45d7def2\n\
<a name="line-1123"></a> \Merge: b6d58e9 c019aa0\n\
<a name="line-1124"></a> \Author: Kiwamu Okabe &lt;kiwamu@gmail.com&gt;\n\
<a name="line-1125"></a> \Date:   Wed Jun 5 08:55:48 2013 -0700\n\
<a name="line-1126"></a> \\n\
<a name="line-1127"></a> \    Merge pull request #19 from master-q/feature/reentrant1\n\
<a name="line-1128"></a> \    \n\
<a name="line-1129"></a> \    Feature/reentrant1: Add arity \"arena\" to all functions. (Sometime selftest has fail without problem.)\n\
<a name="line-1130"></a> \\n\
<a name="line-1131"></a> \commit c019aa02764309b0a3364a7f54d41e671ca2b99a\n\
<a name="line-1132"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1133"></a> \Date:   Thu Jun 6 00:24:02 2013 +0900\n\
<a name="line-1134"></a> \\n\
<a name="line-1135"></a> \    Pass rtstest, again.\n\
<a name="line-1136"></a> \\n\
<a name="line-1137"></a> \commit f5aa9f87a0ad724830f3326123fabbf85995d5b5\n\
<a name="line-1138"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1139"></a> \Date:   Thu Jun 6 00:19:33 2013 +0900\n\
<a name="line-1140"></a> \\n\
<a name="line-1141"></a> \    Pass rtstest.\n\
<a name="line-1142"></a> \\n\
<a name="line-1143"></a> \commit 4f8a185bace5562e16fb9fb803a8db9d43578d54\n\
<a name="line-1144"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1145"></a> \Date:   Wed Jun 5 22:27:31 2013 +0900\n\
<a name="line-1146"></a> \\n\
<a name="line-1147"></a> \    Add arity \"arena\" to all functions.\n\
<a name="line-1148"></a> \\n\
<a name="line-1149"></a> \commit 73cedc4842866f48590ce191b3f79ea8392aba16\n\
<a name="line-1150"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1151"></a> \Date:   Wed Jun 5 16:31:54 2013 +0900\n\
<a name="line-1152"></a> \\n\
<a name="line-1153"></a> \    Assign FunPtr as CTYPE \"HsFunPtr\".\n\
<a name="line-1154"></a> \\n\
<a name="line-1155"></a> \commit b6d58e95e63be9848f267e9242dedff5e5f7b25b\n\
<a name="line-1156"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1157"></a> \Date:   Mon May 27 20:07:23 2013 +0900\n\
<a name="line-1158"></a> \\n\
<a name="line-1159"></a> \    Better NAIVEGC.\n\
<a name="line-1160"></a> \\n\
<a name="line-1161"></a> \commit 31c207fd41d9a9dc1209453606db37818045d29c\n\
<a name="line-1162"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1163"></a> \Date:   Thu May 23 21:23:53 2013 +0900\n\
<a name="line-1164"></a> \\n\
<a name="line-1165"></a> \    Update Future plan.\n\
<a name="line-1166"></a> \\n\
<a name="line-1167"></a> \commit 2f6663bff4abee55619f2a79b46b3dbb1ae11721\n\
<a name="line-1168"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1169"></a> \Date:   Thu May 23 18:30:52 2013 +0900\n\
<a name="line-1170"></a> \\n\
<a name="line-1171"></a> \    Run SelfTest with only 1 thread, and output plain text log.\n\
<a name="line-1172"></a> \\n\
<a name="line-1173"></a> \commit 8e48fc97986e7ad0c700fdaa032a4bffc4493ebb\n\
<a name="line-1174"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1175"></a> \Date:   Wed May 22 20:36:05 2013 +0900\n\
<a name="line-1176"></a> \\n\
<a name="line-1177"></a> \    Run testInfo and testBinary using hunit.\n\
<a name="line-1178"></a> \\n\
<a name="line-1179"></a> \commit 078461ca2dac8b8334f568f7197afc42eab0cd41\n\
<a name="line-1180"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1181"></a> \Date:   Wed May 22 20:23:24 2013 +0900\n\
<a name="line-1182"></a> \\n\
<a name="line-1183"></a> \    SelfTest uses test-framework-th library.\n\
<a name="line-1184"></a> \\n\
<a name="line-1185"></a> \commit 4158f4b51a5a3a7a3a6a20b5d394a8c44fb0c455\n\
<a name="line-1186"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1187"></a> \Date:   Wed May 22 16:02:10 2013 +0900\n\
<a name="line-1188"></a> \\n\
<a name="line-1189"></a> \    Skip the regress tests fail now.\n\
<a name="line-1190"></a> \\n\
<a name="line-1191"></a> \commit 715083aaed642271fc286eca50c98bb74283bf1b\n\
<a name="line-1192"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1193"></a> \Date:   Wed May 22 14:48:32 2013 +0900\n\
<a name="line-1194"></a> \\n\
<a name="line-1195"></a> \    regress.prl should return error when regress test error occured.\n\
<a name="line-1196"></a> \\n\
<a name="line-1197"></a> \commit 6759d23c08c84ae7bb0ead556049643c81cbf2d5\n\
<a name="line-1198"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1199"></a> \Date:   Tue May 21 23:40:00 2013 +0900\n\
<a name="line-1200"></a> \\n\
<a name="line-1201"></a> \    Swap running install libs and testing on travis-ci.\n\
<a name="line-1202"></a> \\n\
<a name="line-1203"></a> \commit f5db932fbd357a8330bea4daa0a770c108816c4f\n\
<a name="line-1204"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1205"></a> \Date:   Tue May 21 23:10:02 2013 +0900\n\
<a name="line-1206"></a> \\n\
<a name="line-1207"></a> \    Need valgrind to run rtstest.\n\
<a name="line-1208"></a> \\n\
<a name="line-1209"></a> \commit 667106896171c441024fcd0e13c3e9d95edc5e51\n\
<a name="line-1210"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1211"></a> \Date:   Tue May 21 23:02:22 2013 +0900\n\
<a name="line-1212"></a> \\n\
<a name="line-1213"></a> \    jhc_test and stableptr_test return number of fail.\n\
<a name="line-1214"></a> \\n\
<a name="line-1215"></a> \commit ea8de920f1714b7183315fd0192cbdb6b79ab132\n\
<a name="line-1216"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1217"></a> \Date:   Tue May 21 22:08:07 2013 +0900\n\
<a name="line-1218"></a> \\n\
<a name="line-1219"></a> \    Run rtstest on travis-ci.\n\
<a name="line-1220"></a> \\n\
<a name="line-1221"></a> \commit cfee75da539badf3b673614a902a22c4805539e8\n\
<a name="line-1222"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1223"></a> \Date:   Wed May 15 09:23:08 2013 +0900\n\
<a name="line-1224"></a> \\n\
<a name="line-1225"></a> \    Run selftest on travis-ci.\n\
<a name="line-1226"></a> \\n\
<a name="line-1227"></a> \commit feb47bbaf5e110fdebfb544d505809622b254653\n\
<a name="line-1228"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1229"></a> \Date:   Wed May 15 09:19:22 2013 +0900\n\
<a name="line-1230"></a> \\n\
<a name="line-1231"></a> \    Modify name.acc selftest code to pass it.\n\
<a name="line-1232"></a> \\n\
<a name="line-1233"></a> \commit b2c52edba05eb0ca88132a08ed4b78342c515747\n\
<a name="line-1234"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1235"></a> \Date:   Sun Apr 28 17:12:28 2013 +0900\n\
<a name="line-1236"></a> \\n\
<a name="line-1237"></a> \    No need sudo for cabal install.\n\
<a name="line-1238"></a> \\n\
<a name="line-1239"></a> \commit 6349fd5304cf68d541538a066af73e6c9165938e\n\
<a name="line-1240"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1241"></a> \Date:   Sun Apr 28 17:08:51 2013 +0900\n\
<a name="line-1242"></a> \\n\
<a name="line-1243"></a> \    GNU make same as Cabal.\n\
<a name="line-1244"></a> \\n\
<a name="line-1245"></a> \commit c2fcf3d4efa07925c0a92f0baf80bd5d998962eb\n\
<a name="line-1246"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1247"></a> \Date:   Sun Apr 28 04:17:11 2013 +0900\n\
<a name="line-1248"></a> \\n\
<a name="line-1249"></a> \    More gitignore entries.\n\
<a name="line-1250"></a> \\n\
<a name="line-1251"></a> \commit 534d3fff7f85e48a9bc2f0c80ea35f8f296d7452\n\
<a name="line-1252"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1253"></a> \Date:   Sun Apr 28 04:00:09 2013 +0900\n\
<a name="line-1254"></a> \\n\
<a name="line-1255"></a> \    Slim Makefile.\n\
<a name="line-1256"></a> \\n\
<a name="line-1257"></a> \commit 3968daca16d6e1524f899c07bbd81f931b7053cc\n\
<a name="line-1258"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1259"></a> \Date:   Sun Apr 28 01:47:09 2013 +0900\n\
<a name="line-1260"></a> \\n\
<a name="line-1261"></a> \    Run apt-get install libghc-temporary-dev libghc-haskeline-dev.\n\
<a name="line-1262"></a> \\n\
<a name="line-1263"></a> \commit be7b6dcb59df974f3b25e4b002fe1cc65565a459\n\
<a name="line-1264"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1265"></a> \Date:   Sun Apr 28 01:42:44 2013 +0900\n\
<a name="line-1266"></a> \\n\
<a name="line-1267"></a> \    Use cabal to compile me and run regress test.\n\
<a name="line-1268"></a> \\n\
<a name="line-1269"></a> \commit f1581ea0ac987b4d612160db1bc17d8159f55f29\n\
<a name="line-1270"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1271"></a> \Date:   Sat Apr 27 22:54:10 2013 +0900\n\
<a name="line-1272"></a> \\n\
<a name="line-1273"></a> \    Add jahm command to download file from Hackage DB.\n\
<a name="line-1274"></a> \    \n\
<a name="line-1275"></a> \    Usage: jahm downloadURI http://hackage.haskell.org/packages/archive/network/2.4.1.2/network-2.4.1.2.tar.gz network-2.4.1.2.tar.gz\n\
<a name="line-1276"></a> \\n\
<a name="line-1277"></a> \commit d945f1e72c54674abc1d4d04c066bdc637e34610\n\
<a name="line-1278"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1279"></a> \Date:   Sat Apr 27 22:24:07 2013 +0900\n\
<a name="line-1280"></a> \\n\
<a name="line-1281"></a> \    Jahm is cmpilable.\n\
<a name="line-1282"></a> \\n\
<a name="line-1283"></a> \commit 1de6d91b13a6b50f67a9aef9b7f91f21c278ee5c\n\
<a name="line-1284"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1285"></a> \Date:   Sat Apr 27 21:24:21 2013 +0900\n\
<a name="line-1286"></a> \\n\
<a name="line-1287"></a> \    Copy from cabal source code.\n\
<a name="line-1288"></a> \\n\
<a name="line-1289"></a> \commit d2cc0fde608a0c3362a35a59f8b7eed080707efb\n\
<a name="line-1290"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1291"></a> \Date:   Sat Apr 27 21:09:59 2013 +0900\n\
<a name="line-1292"></a> \\n\
<a name="line-1293"></a> \    Copy from cabal source code.\n\
<a name="line-1294"></a> \\n\
<a name="line-1295"></a> \commit 6d91389f1d7f95cb005d41382a8d6a15d0eccaf3\n\
<a name="line-1296"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1297"></a> \Date:   Fri Apr 19 18:51:23 2013 +0900\n\
<a name="line-1298"></a> \\n\
<a name="line-1299"></a> \    Add dummy dir and symlink to avoid CI error on travis-ci.\n\
<a name="line-1300"></a> \\n\
<a name="line-1301"></a> \commit 40348972bb1c7e38effd8316bcd3135690b7f65b\n\
<a name="line-1302"></a> \Author: Kiwamu Okabe &lt;kiwamu@gmail.com&gt;\n\
<a name="line-1303"></a> \Date:   Fri Apr 19 18:13:30 2013 +0900\n\
<a name="line-1304"></a> \\n\
<a name="line-1305"></a> \    Update README.md\n\
<a name="line-1306"></a> \\n\
<a name="line-1307"></a> \commit 2963a3de703474e85a033b80b6bdf14baa34a5af\n\
<a name="line-1308"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1309"></a> \Date:   Mon Apr 15 10:56:52 2013 +0900\n\
<a name="line-1310"></a> \\n\
<a name="line-1311"></a> \    Use metasepi.org domain name.\n\
<a name="line-1312"></a> \\n\
<a name="line-1313"></a> \commit 1953685c18607d349485d6dc679838d9bb5e03b7\n\
<a name="line-1314"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1315"></a> \Date:   Mon Apr 8 02:05:26 2013 +0900\n\
<a name="line-1316"></a> \\n\
<a name="line-1317"></a> \    Add script to dump debug infomation.\n\
<a name="line-1318"></a> \\n\
<a name="line-1319"></a> \commit a2d14fd969d51e6abdbc508e04ed97a029be5bb5\n\
<a name="line-1320"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1321"></a> \Date:   Sun Apr 7 22:14:18 2013 +0900\n\
<a name="line-1322"></a> \\n\
<a name="line-1323"></a> \    Too big stack for nofib.digits-of-e1 regress test.\n\
<a name="line-1324"></a> \\n\
<a name="line-1325"></a> \commit 71346a8fbb2bf9496ea03975a31aee5f80b7ea3d\n\
<a name="line-1326"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1327"></a> \Date:   Sun Apr 7 21:50:21 2013 +0900\n\
<a name="line-1328"></a> \\n\
<a name="line-1329"></a> \    Use ulimit command on bash.\n\
<a name="line-1330"></a> \\n\
<a name="line-1331"></a> \commit 6b7980c83a9ea17803876b5e80b166ef272fd19c\n\
<a name="line-1332"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1333"></a> \Date:   Sun Apr 7 21:42:48 2013 +0900\n\
<a name="line-1334"></a> \\n\
<a name="line-1335"></a> \    Run limit on travis-ci.\n\
<a name="line-1336"></a> \\n\
<a name="line-1337"></a> \commit ef68ae77fd85be4129974abe007ccac653aa0a35\n\
<a name="line-1338"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1339"></a> \Date:   Sun Apr 7 20:15:39 2013 +0900\n\
<a name="line-1340"></a> \\n\
<a name="line-1341"></a> \    Show meminfo on travis-ci.\n\
<a name="line-1342"></a> \\n\
<a name="line-1343"></a> \commit 4ff787bdaba39c411fb585ae4da5047c94a1d751\n\
<a name="line-1344"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1345"></a> \Date:   Sat Apr 6 17:16:12 2013 +0900\n\
<a name="line-1346"></a> \\n\
<a name="line-1347"></a> \    The selftest is runnable. But it catches error.\n\
<a name="line-1348"></a> \\n\
<a name="line-1349"></a> \commit 97c6427a1547b2c95f88788665f365c3a83e75b0\n\
<a name="line-1350"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1351"></a> \Date:   Sat Apr 6 16:50:52 2013 +0900\n\
<a name="line-1352"></a> \\n\
<a name="line-1353"></a> \    Umm.... I think we cann't use wine on travis-ci...\n\
<a name="line-1354"></a> \\n\
<a name="line-1355"></a> \commit 600ab13e6ae2817c6cc61a82cef95b5400fbd013\n\
<a name="line-1356"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1357"></a> \Date:   Sat Apr 6 16:43:41 2013 +0900\n\
<a name="line-1358"></a> \\n\
<a name="line-1359"></a> \    Run apt-get update before apt-get install.\n\
<a name="line-1360"></a> \\n\
<a name="line-1361"></a> \commit bf252a1283275600ed04e10120324bfb704170b9\n\
<a name="line-1362"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1363"></a> \Date:   Sat Apr 6 16:26:57 2013 +0900\n\
<a name="line-1364"></a> \\n\
<a name="line-1365"></a> \    Test for travis-ci.\n\
<a name="line-1366"></a> \\n\
<a name="line-1367"></a> \commit c10e974cb2a7e20de8893e70e7e30d7c32236748\n\
<a name="line-1368"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1369"></a> \Date:   Sat Apr 6 16:18:53 2013 +0900\n\
<a name="line-1370"></a> \\n\
<a name="line-1371"></a> \    Can I use wine on travis-ci? (test)\n\
<a name="line-1372"></a> \\n\
<a name="line-1373"></a> \commit 63e18e0c5009d624496af86ea8f0bb401d3a2a64\n\
<a name="line-1374"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1375"></a> \Date:   Sat Apr 6 16:06:43 2013 +0900\n\
<a name="line-1376"></a> \\n\
<a name="line-1377"></a> \    MinGW32 settings for passing rts/HelloWorld_win regress test.\n\
<a name="line-1378"></a> \\n\
<a name="line-1379"></a> \commit ea94b5db63d8ef2d3e90583ed27fc760d30243e9\n\
<a name="line-1380"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1381"></a> \Date:   Sat Apr 6 02:20:33 2013 +0900\n\
<a name="line-1382"></a> \\n\
<a name="line-1383"></a> \    Find mingw-w64.\n\
<a name="line-1384"></a> \\n\
<a name="line-1385"></a> \commit 8003050e52ddf37c912158623114176769cce6a8\n\
<a name="line-1386"></a> \Merge: 9aec7cb 2dc68c4\n\
<a name="line-1387"></a> \Author: Kiwamu Okabe &lt;kiwamu@gmail.com&gt;\n\
<a name="line-1388"></a> \Date:   Fri Apr 5 07:53:54 2013 -0700\n\
<a name="line-1389"></a> \\n\
<a name="line-1390"></a> \    Merge pull request #11 from stepcut/arafura\n\
<a name="line-1391"></a> \    \n\
<a name="line-1392"></a> \    Thank's!\n\
<a name="line-1393"></a> \\n\
<a name="line-1394"></a> \commit 2dc68c441550d09ea573da7a8800455ca4ab898e\n\
<a name="line-1395"></a> \Author: stepcut &lt;jeremy@n-heptane.com&gt;\n\
<a name="line-1396"></a> \Date:   Fri Apr 5 08:32:42 2013 -0500\n\
<a name="line-1397"></a> \\n\
<a name="line-1398"></a> \    The rest of the of lookupEnv patch\n\
<a name="line-1399"></a> \\n\
<a name="line-1400"></a> \commit 9aec7cb77a721ce09e59716ce0233daa23ee765c\n\
<a name="line-1401"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1402"></a> \Date:   Fri Apr 5 19:19:31 2013 +0900\n\
<a name="line-1403"></a> \\n\
<a name="line-1404"></a> \    File src/Options.hs need getEnv function.\n\
<a name="line-1405"></a> \\n\
<a name="line-1406"></a> \commit 210da9343b6b7e38a89eb28f85602471a325647a\n\
<a name="line-1407"></a> \Merge: ff0c404 7e958b3\n\
<a name="line-1408"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1409"></a> \Date:   Fri Apr 5 19:10:39 2013 +0900\n\
<a name="line-1410"></a> \\n\
<a name="line-1411"></a> \    Merge branch 'arafura' of github.com:ajhc/ajhc into arafura\n\
<a name="line-1412"></a> \\n\
<a name="line-1413"></a> \commit 7e958b317eaa5473321b545f83ef06f440ac893b\n\
<a name="line-1414"></a> \Merge: 474ebd5 aedd40c\n\
<a name="line-1415"></a> \Author: Kiwamu Okabe &lt;kiwamu@gmail.com&gt;\n\
<a name="line-1416"></a> \Date:   Fri Apr 5 03:09:31 2013 -0700\n\
<a name="line-1417"></a> \\n\
<a name="line-1418"></a> \    Merge pull request #10 from stepcut/arafura\n\
<a name="line-1419"></a> \    \n\
<a name="line-1420"></a> \    use explicit import lists for System.Enviroment.\n\
<a name="line-1421"></a> \\n\
<a name="line-1422"></a> \commit aedd40cd8a6c55efcb485346598bcadcbc9d4b9e\n\
<a name="line-1423"></a> \Author: stepcut &lt;jeremy@n-heptane.com&gt;\n\
<a name="line-1424"></a> \Date:   Fri Apr 5 00:26:03 2013 -0500\n\
<a name="line-1425"></a> \\n\
<a name="line-1426"></a> \    use explicit import lists for System.Enviroment to avoid conflicting definitions of lookupEnv.\n\
<a name="line-1427"></a> \\n\
<a name="line-1428"></a> \commit ff0c40426338e0ecb75cf6e4fb8c136da4bb103a\n\
<a name="line-1429"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1430"></a> \Date:   Thu Apr 4 02:21:18 2013 +0900\n\
<a name="line-1431"></a> \\n\
<a name="line-1432"></a> \    Bump up version 0.8.0.5.\n\
<a name="line-1433"></a> \\n\
<a name="line-1434"></a> \commit 474ebd5aa9dc6497f078b8b1999f0cb8d1b2b85f\n\
<a name="line-1435"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1436"></a> \Date:   Thu Apr 4 02:17:45 2013 +0900\n\
<a name="line-1437"></a> \\n\
<a name="line-1438"></a> \    Add Ajhc 0.8.0.4 Release Notes.\n\
<a name="line-1439"></a> \\n\
<a name="line-1440"></a> \commit b528b5887e5110b450fae206282c05b411c705f9\n\
<a name="line-1441"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1442"></a> \Date:   Thu Apr 4 01:28:45 2013 +0900\n\
<a name="line-1443"></a> \\n\
<a name="line-1444"></a> \    Remove test code for travis-ci.\n\
<a name="line-1445"></a> \\n\
<a name="line-1446"></a> \commit b115146bc0d8965b134a7f232070d45c5700bcdc\n\
<a name="line-1447"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1448"></a> \Date:   Thu Apr 4 01:12:52 2013 +0900\n\
<a name="line-1449"></a> \\n\
<a name="line-1450"></a> \    Need src/data/Typeable.h to cabal install.\n\
<a name="line-1451"></a> \\n\
<a name="line-1452"></a> \commit e6235203a7b0a3e2b7ce0d7ad6cf6c676218e110\n\
<a name="line-1453"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1454"></a> \Date:   Thu Apr 4 01:11:37 2013 +0900\n\
<a name="line-1455"></a> \\n\
<a name="line-1456"></a> \    Need git fetch --tags ???\n\
<a name="line-1457"></a> \\n\
<a name="line-1458"></a> \commit 7f6b19aae69d381815bb079b711f4325d2a74314\n\
<a name="line-1459"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1460"></a> \Date:   Thu Apr 4 00:32:47 2013 +0900\n\
<a name="line-1461"></a> \\n\
<a name="line-1462"></a> \    Test for travis-ci.\n\
<a name="line-1463"></a> \\n\
<a name="line-1464"></a> \commit ab602755997049b29128105203ab8c14349ac7fa\n\
<a name="line-1465"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1466"></a> \Date:   Wed Apr 3 23:39:53 2013 +0900\n\
<a name="line-1467"></a> \\n\
<a name="line-1468"></a> \    Git 1.8.2 can not use \"HEAD\" for git log????\n\
<a name="line-1469"></a> \\n\
<a name="line-1470"></a> \commit 7d6768f60c403063b25704b628f5b26f1707229f\n\
<a name="line-1471"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1472"></a> \Date:   Wed Apr 3 23:09:32 2013 +0900\n\
<a name="line-1473"></a> \\n\
<a name="line-1474"></a> \    Why error on travis-ci? Retry with printing git version.\n\
<a name="line-1475"></a> \\n\
<a name="line-1476"></a> \commit be19711376deac341f0fccd505daf3ab57e0fc5f\n\
<a name="line-1477"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1478"></a> \Date:   Wed Apr 3 21:41:59 2013 +0900\n\
<a name="line-1479"></a> \\n\
<a name="line-1480"></a> \    Need -lm option with compiling -fdebug to pass large/RayT regress test.\n\
<a name="line-1481"></a> \\n\
<a name="line-1482"></a> \commit 6f88fadf0c064de119e5a309ee27cfa272adad97\n\
<a name="line-1483"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1484"></a> \Date:   Wed Apr 3 19:30:29 2013 +0900\n\
<a name="line-1485"></a> \\n\
<a name="line-1486"></a> \    Need libgc-dev and gcc-multilib package to run regress test.\n\
<a name="line-1487"></a> \\n\
<a name="line-1488"></a> \commit 5b71f46786616d395ecdf898865d7f8c11b5c0ce\n\
<a name="line-1489"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1490"></a> \Date:   Wed Apr 3 18:39:36 2013 +0900\n\
<a name="line-1491"></a> \\n\
<a name="line-1492"></a> \    Explain Ajhc position on cabal description.\n\
<a name="line-1493"></a> \\n\
<a name="line-1494"></a> \commit a6f971f39d89b2d6ebf44bfb6f9b0d1591dd6161\n\
<a name="line-1495"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1496"></a> \Date:   Wed Apr 3 05:12:41 2013 +0900\n\
<a name="line-1497"></a> \\n\
<a name="line-1498"></a> \    Bump up version 0.8.0.4.\n\
<a name="line-1499"></a> \\n\
<a name="line-1500"></a> \commit eb0874f9543a8db6aa7eafe3d072a8d579b0b184\n\
<a name="line-1501"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1502"></a> \Date:   Wed Apr 3 05:00:19 2013 +0900\n\
<a name="line-1503"></a> \\n\
<a name="line-1504"></a> \    downcase\n\
<a name="line-1505"></a> \\n\
<a name="line-1506"></a> \commit 22787aa809d94c8642bc578d768045fb607f282e\n\
<a name="line-1507"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1508"></a> \Date:   Wed Apr 3 03:14:54 2013 +0900\n\
<a name="line-1509"></a> \\n\
<a name="line-1510"></a> \    Clean up drift_processed tmp autom4te.cache\n\
<a name="line-1511"></a> \\n\
<a name="line-1512"></a> \commit 45418eb6a70de87a9b56e73ba7234dbf4162bab4\n\
<a name="line-1513"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1514"></a> \Date:   Wed Apr 3 02:49:02 2013 +0900\n\
<a name="line-1515"></a> \\n\
<a name="line-1516"></a> \    Test cabal install on travis-ci.\n\
<a name="line-1517"></a> \\n\
<a name="line-1518"></a> \commit c7e7427a6e4cfc2a3e5ffa9939cb86d965301060\n\
<a name="line-1519"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1520"></a> \Date:   Tue Apr 2 03:36:31 2013 +0900\n\
<a name="line-1521"></a> \\n\
<a name="line-1522"></a> \    Bump up version 0.8.0.3. Support Windows MinGW32 platform.\n\
<a name="line-1523"></a> \\n\
<a name="line-1524"></a> \commit 0c4b321887b0de5f569974d8e4bd1e18d2a45477\n\
<a name="line-1525"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1526"></a> \Date:   Tue Apr 2 03:35:44 2013 +0900\n\
<a name="line-1527"></a> \\n\
<a name="line-1528"></a> \    Add Ajhc 0.8.0.3 Release Notes.\n\
<a name="line-1529"></a> \\n\
<a name="line-1530"></a> \commit f1bf6e4a473a42ac193097a84adebd6506b61209\n\
<a name="line-1531"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1532"></a> \Date:   Tue Apr 2 01:23:29 2013 +0900\n\
<a name="line-1533"></a> \\n\
<a name="line-1534"></a> \    Avoid 500 error while running LWP::Simple getstore.\n\
<a name="line-1535"></a> \\n\
<a name="line-1536"></a> \commit d256d40e5a89d37d350cdbcb8e2f9c0d00289ff4\n\
<a name="line-1537"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1538"></a> \Date:   Tue Apr 2 00:06:33 2013 +0900\n\
<a name="line-1539"></a> \\n\
<a name="line-1540"></a> \    Fix a bit miss.\n\
<a name="line-1541"></a> \\n\
<a name="line-1542"></a> \commit 959c0739d7804b064870bec1cdcce5b3ad70d379\n\
<a name="line-1543"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1544"></a> \Date:   Mon Apr 1 23:08:12 2013 +0900\n\
<a name="line-1545"></a> \\n\
<a name="line-1546"></a> \    Do not use \"ajhc\" name to avoid conflicting between jhc and Ajhc.\n\
<a name="line-1547"></a> \\n\
<a name="line-1548"></a> \commit ab4989d6e672e5488cf1ad36974e6a1cf16ddf6d\n\
<a name="line-1549"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1550"></a> \Date:   Mon Apr 1 22:17:42 2013 +0900\n\
<a name="line-1551"></a> \\n\
<a name="line-1552"></a> \    Update README.\n\
<a name="line-1553"></a> \\n\
<a name="line-1554"></a> \commit 4c66ba7dc37d103e8704fca2cb6923ae3832dc23\n\
<a name="line-1555"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1556"></a> \Date:   Mon Apr 1 21:20:23 2013 +0900\n\
<a name="line-1557"></a> \\n\
<a name="line-1558"></a> \    Do not forge to add utils/build_extlibs.prl to cabal sdist.\n\
<a name="line-1559"></a> \\n\
<a name="line-1560"></a> \commit 8a873e456a39f7b92613536a89b5205cf784f6b0\n\
<a name="line-1561"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1562"></a> \Date:   Mon Apr 1 21:00:46 2013 +0900\n\
<a name="line-1563"></a> \\n\
<a name="line-1564"></a> \    Install JHC_EXT_LIBS with cabal install.\n\
<a name="line-1565"></a> \\n\
<a name="line-1566"></a> \commit 5c043d61c5201af057089973a3c6bc0db026567d\n\
<a name="line-1567"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1568"></a> \Date:   Mon Apr 1 19:20:38 2013 +0900\n\
<a name="line-1569"></a> \\n\
<a name="line-1570"></a> \    Ready to cabal install me on Windows + MinGW32 env without JHC_EXT_LIBS.\n\
<a name="line-1571"></a> \\n\
<a name="line-1572"></a> \commit c7e2bf3f129f44a20e4350f1b7c7ad84720c9a4e\n\
<a name="line-1573"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1574"></a> \Date:   Mon Apr 1 17:24:46 2013 +0900\n\
<a name="line-1575"></a> \\n\
<a name="line-1576"></a> \    Add prefix \"sh -c \" for system function on mingw32.\n\
<a name="line-1577"></a> \\n\
<a name="line-1578"></a> \commit 7f81fb4a41f6a6f272f4a39ada258e8776a65bd4\n\
<a name="line-1579"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1580"></a> \Date:   Mon Apr 1 15:45:19 2013 +0900\n\
<a name="line-1581"></a> \\n\
<a name="line-1582"></a> \    Windows install Haskell Platform to directory  has path string include space.\n\
<a name="line-1583"></a> \\n\
<a name="line-1584"></a> \commit 012f092f7bd74a12f10a495da3c177818932653d\n\
<a name="line-1585"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1586"></a> \Date:   Mon Apr 1 15:04:43 2013 +0900\n\
<a name="line-1587"></a> \\n\
<a name="line-1588"></a> \    Fix NAIVEGC bug. Should update pg after running gc_perform_gc.\n\
<a name="line-1589"></a> \\n\
<a name="line-1590"></a> \commit 4b122fd809092c31211fdd8e18283622c3651513\n\
<a name="line-1591"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1592"></a> \Date:   Mon Apr 1 03:52:56 2013 +0900\n\
<a name="line-1593"></a> \\n\
<a name="line-1594"></a> \    Find data directory with getDataFileName function.\n\
<a name="line-1595"></a> \\n\
<a name="line-1596"></a> \commit 6b014de73f6381701bc03926f1f75683589f1694\n\
<a name="line-1597"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1598"></a> \Date:   Mon Apr 1 02:36:08 2013 +0900\n\
<a name="line-1599"></a> \\n\
<a name="line-1600"></a> \    Should write like below style for Windows + msys env.\n\
<a name="line-1601"></a> \    \n\
<a name="line-1602"></a> \      install FILES \"DESTDIR\"\n\
<a name="line-1603"></a> \\n\
<a name="line-1604"></a> \commit 232129a84378c306970b2c4ec4d5b0a3dc74958d\n\
<a name="line-1605"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1606"></a> \Date:   Mon Apr 1 01:45:02 2013 +0900\n\
<a name="line-1607"></a> \\n\
<a name="line-1608"></a> \    List up the files in \"lib\" directory to include them on cabal sdist file.\n\
<a name="line-1609"></a> \\n\
<a name="line-1610"></a> \commit 166f0b90ea3f319a1841961e4212213a1750374b\n\
<a name="line-1611"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1612"></a> \Date:   Sun Mar 31 23:42:41 2013 +0900\n\
<a name="line-1613"></a> \\n\
<a name="line-1614"></a> \    Build JHC_LIBS with cabal. (not yet JHC_EXT_LIBS)\n\
<a name="line-1615"></a> \\n\
<a name="line-1616"></a> \commit a7e0de37f89d1f8f4cdae4a873c11412c342ea8a\n\
<a name="line-1617"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1618"></a> \Date:   Sun Mar 31 21:25:17 2013 +0900\n\
<a name="line-1619"></a> \\n\
<a name="line-1620"></a> \    Update TODO.\n\
<a name="line-1621"></a> \\n\
<a name="line-1622"></a> \commit e1a0fbd87e56a8f45c127492adf9433c85df5618\n\
<a name="line-1623"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1624"></a> \Date:   Sun Mar 31 21:24:37 2013 +0900\n\
<a name="line-1625"></a> \\n\
<a name="line-1626"></a> \    Build ajhc with cabal without hl files.\n\
<a name="line-1627"></a> \\n\
<a name="line-1628"></a> \commit e4a396ef63dd26518073b789480b1c3f5268e444\n\
<a name="line-1629"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1630"></a> \Date:   Sun Mar 31 20:13:23 2013 +0900\n\
<a name="line-1631"></a> \\n\
<a name="line-1632"></a> \    No more depend on haskell98 package.\n\
<a name="line-1633"></a> \\n\
<a name="line-1634"></a> \commit 2e58f4f259507eb7eb67a894db81c23e056465d8\n\
<a name="line-1635"></a> \Merge: 8de6364 58a1bf6\n\
<a name="line-1636"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1637"></a> \Date:   Sat Mar 30 01:23:53 2013 +0900\n\
<a name="line-1638"></a> \\n\
<a name="line-1639"></a> \    Merge branch 'arafura' of github.com:ajhc/ajhc into arafura\n\
<a name="line-1640"></a> \\n\
<a name="line-1641"></a> \commit 8de63645df6cc30f9874b12b18da032acc0a28d0\n\
<a name="line-1642"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1643"></a> \Date:   Sat Mar 30 01:23:16 2013 +0900\n\
<a name="line-1644"></a> \\n\
<a name="line-1645"></a> \    Add BUGGY cabal file.\n\
<a name="line-1646"></a> \\n\
<a name="line-1647"></a> \commit 58a1bf61639157e3ac3e9c55cc2f4ba33d592eb7\n\
<a name="line-1648"></a> \Author: Kiwamu Okabe &lt;kiwamu@gmail.com&gt;\n\
<a name="line-1649"></a> \Date:   Fri Mar 29 21:53:45 2013 +0900\n\
<a name="line-1650"></a> \\n\
<a name="line-1651"></a> \    a bit change.\n\
<a name="line-1652"></a> \\n\
<a name="line-1653"></a> \commit 7675b1599fe41531b4c89a2ada947fa8f601161d\n\
<a name="line-1654"></a> \Author: Kiwamu Okabe &lt;kiwamu@gmail.com&gt;\n\
<a name="line-1655"></a> \Date:   Fri Mar 29 21:44:42 2013 +0900\n\
<a name="line-1656"></a> \\n\
<a name="line-1657"></a> \    Build on Windows (in the make)\n\
<a name="line-1658"></a> \\n\
<a name="line-1659"></a> \commit 38275f78b7ff585616e2a7846cedccbf2f0dd0b8\n\
<a name="line-1660"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1661"></a> \Date:   Fri Mar 29 20:13:56 2013 +0900\n\
<a name="line-1662"></a> \\n\
<a name="line-1663"></a> \    Add msys path to library search path.\n\
<a name="line-1664"></a> \\n\
<a name="line-1665"></a> \commit cbfe1a5cd1bc660adc126056bfe17dbce529f8bd\n\
<a name="line-1666"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1667"></a> \Date:   Fri Mar 29 19:31:22 2013 +0900\n\
<a name="line-1668"></a> \\n\
<a name="line-1669"></a> \    Update README.md.\n\
<a name="line-1670"></a> \\n\
<a name="line-1671"></a> \commit e99327bbe221b35c63e4c2639462330d1c978b6c\n\
<a name="line-1672"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1673"></a> \Date:   Fri Mar 29 17:55:26 2013 +0900\n\
<a name="line-1674"></a> \\n\
<a name="line-1675"></a> \    Explain how to build on Windows.\n\
<a name="line-1676"></a> \\n\
<a name="line-1677"></a> \commit 376103c6d2dfe3d77920b340f8295d174c274b79\n\
<a name="line-1678"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1679"></a> \Date:   Fri Mar 29 17:28:28 2013 +0900\n\
<a name="line-1680"></a> \\n\
<a name="line-1681"></a> \    Ready to build me on Windows.\n\
<a name="line-1682"></a> \\n\
<a name="line-1683"></a> \commit 6024a1823e6782f3d03c8263bcfd50bbba83ba33\n\
<a name="line-1684"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1685"></a> \Date:   Fri Mar 29 08:57:29 2013 +0900\n\
<a name="line-1686"></a> \\n\
<a name="line-1687"></a> \    Stacktrace with running \"ajhcp Foo.hs +RTS -p -xc\".\n\
<a name="line-1688"></a> \\n\
<a name="line-1689"></a> \commit 20edf78270d89fc8602e37863980bec0228bb647\n\
<a name="line-1690"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1691"></a> \Date:   Fri Mar 29 07:44:28 2013 +0900\n\
<a name="line-1692"></a> \\n\
<a name="line-1693"></a> \    Use \"DrIFT-cabalized\" command name, if use DrIFT-cabalized Haskell package.\n\
<a name="line-1694"></a> \\n\
<a name="line-1695"></a> \commit e3a1a65e326e1a3b31fc5eb03c89a611a56d1970\n\
<a name="line-1696"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1697"></a> \Date:   Thu Mar 28 22:20:22 2013 +0900\n\
<a name="line-1698"></a> \\n\
<a name="line-1699"></a> \    Find and use DrIFT-cabalized.\n\
<a name="line-1700"></a> \\n\
<a name="line-1701"></a> \commit 293eb5a89fe27f25c623996e7670cd8984768319\n\
<a name="line-1702"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1703"></a> \Date:   Wed Mar 27 13:16:56 2013 +0900\n\
<a name="line-1704"></a> \\n\
<a name="line-1705"></a> \    Use System.IO.Temp instead of mkdtemp.\n\
<a name="line-1706"></a> \\n\
<a name="line-1707"></a> \commit 8ab1f6aebdfd466be988f70611c60450664ca47b\n\
<a name="line-1708"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1709"></a> \Date:   Wed Mar 27 12:16:50 2013 +0900\n\
<a name="line-1710"></a> \\n\
<a name="line-1711"></a> \    Switch compile for Windows or UNIX with USE_WIN32 flag.\n\
<a name="line-1712"></a> \\n\
<a name="line-1713"></a> \commit 76671e2eb7b91b482a413d93d657bbd374c66f1d\n\
<a name="line-1714"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1715"></a> \Date:   Wed Mar 27 06:00:41 2013 +0900\n\
<a name="line-1716"></a> \\n\
<a name="line-1717"></a> \    Fix setting EXEEXT in Makefile.\n\
<a name="line-1718"></a> \\n\
<a name="line-1719"></a> \commit e49aebef308f40a1e8b1c9b6594c81708b4ce08b\n\
<a name="line-1720"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1721"></a> \Date:   Wed Mar 27 03:18:58 2013 +0900\n\
<a name="line-1722"></a> \\n\
<a name="line-1723"></a> \    Use haskeline haskell package instead of readline or editline. (cont.)\n\
<a name="line-1724"></a> \\n\
<a name="line-1725"></a> \commit 751f34f46df2afad207748b3d4af66155a9b1c64\n\
<a name="line-1726"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1727"></a> \Date:   Tue Mar 26 01:20:05 2013 +0900\n\
<a name="line-1728"></a> \\n\
<a name="line-1729"></a> \    Dump megablocks on gdb.\n\
<a name="line-1730"></a> \\n\
<a name="line-1731"></a> \commit c8d53949450b38555c38ce93ebd6d8003d334256\n\
<a name="line-1732"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1733"></a> \Date:   Tue Mar 26 00:25:57 2013 +0900\n\
<a name="line-1734"></a> \\n\
<a name="line-1735"></a> \    Dump s_cache on gdb.\n\
<a name="line-1736"></a> \\n\
<a name="line-1737"></a> \commit 9ceab0702c715ca3012da68c350f7e7357722c6d\n\
<a name="line-1738"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1739"></a> \Date:   Sat Mar 23 03:34:53 2013 +0900\n\
<a name="line-1740"></a> \\n\
<a name="line-1741"></a> \    Rich gdb command print_jgcheap. (cont.)\n\
<a name="line-1742"></a> \\n\
<a name="line-1743"></a> \commit a572ddeb55dc28124c4c2fba09330e8b97a6dce5\n\
<a name="line-1744"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1745"></a> \Date:   Fri Mar 22 22:49:15 2013 +0900\n\
<a name="line-1746"></a> \\n\
<a name="line-1747"></a> \    Do not use gdb.parse_and_eval in loop. It's very slow.\n\
<a name="line-1748"></a> \\n\
<a name="line-1749"></a> \commit cbdcfce5d3bc0d74d67d097f0e0ccf4a77ecb00c\n\
<a name="line-1750"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1751"></a> \Date:   Fri Mar 22 22:20:44 2013 +0900\n\
<a name="line-1752"></a> \\n\
<a name="line-1753"></a> \    Pytyon script to dump Haskell heap on gdb.\n\
<a name="line-1754"></a> \\n\
<a name="line-1755"></a> \commit 25cb7c8e298eb75e26dcdf56d4bd532d6bbd641b\n\
<a name="line-1756"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1757"></a> \Date:   Fri Mar 22 02:21:18 2013 +0900\n\
<a name="line-1758"></a> \\n\
<a name="line-1759"></a> \    Update Future plan.\n\
<a name="line-1760"></a> \\n\
<a name="line-1761"></a> \commit b7e82942abed041e519c4709a591096367bdf158\n\
<a name="line-1762"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1763"></a> \Date:   Wed Mar 20 12:21:38 2013 +0900\n\
<a name="line-1764"></a> \\n\
<a name="line-1765"></a> \    ignore .ditz-config file on git command\n\
<a name="line-1766"></a> \\n\
<a name="line-1767"></a> \commit 46ba77fa0f2ed1fa16acdedae737deab365c9c25\n\
<a name="line-1768"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1769"></a> \Date:   Tue Mar 19 21:52:39 2013 +0900\n\
<a name="line-1770"></a> \\n\
<a name="line-1771"></a> \    Use \"JHC_XXX\" name in Makefile to share source code with jhc.\n\
<a name="line-1772"></a> \\n\
<a name="line-1773"></a> \commit 830a6f81207bac4394f8981e3f432821358d862b\n\
<a name="line-1774"></a> \Merge: 870430b 2adf411\n\
<a name="line-1775"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1776"></a> \Date:   Tue Mar 19 20:50:19 2013 +0900\n\
<a name="line-1777"></a> \\n\
<a name="line-1778"></a> \    Merge branch 'master' into arafura\n\
<a name="line-1779"></a> \    \n\
<a name="line-1780"></a> \    Conflicts:\n\
<a name="line-1781"></a> \    \x0009\&amp;library_deps.make\n\
<a name="line-1782"></a> \\n\
<a name="line-1783"></a> \commit 870430b35629ec2ca8d498b5f198bd2d8610edfe\n\
<a name="line-1784"></a> \Merge: f1fb1c6 ddafc44\n\
<a name="line-1785"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1786"></a> \Date:   Sun Mar 17 16:30:24 2013 +0900\n\
<a name="line-1787"></a> \\n\
<a name="line-1788"></a> \    Merge branch 'master' into arafura\n\
<a name="line-1789"></a> \    \n\
<a name="line-1790"></a> \    Conflicts:\n\
<a name="line-1791"></a> \    \x0009\&amp;Makefile.am\n\
<a name="line-1792"></a> \    \x0009\&amp;po/ja.po\n\
<a name="line-1793"></a> \    \x0009\&amp;src/Grin/Grin.hs\n\
<a name="line-1794"></a> \\n\
<a name="line-1795"></a> \commit f1fb1c6304bc85b71d3fb0558fad7804d5565d60\n\
<a name="line-1796"></a> \Merge: fa1a95b de85f4e\n\
<a name="line-1797"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1798"></a> \Date:   Sun Mar 17 16:19:20 2013 +0900\n\
<a name="line-1799"></a> \\n\
<a name="line-1800"></a> \    Merge branch 'master' into arafura\n\
<a name="line-1801"></a> \    \n\
<a name="line-1802"></a> \    Conflicts:\n\
<a name="line-1803"></a> \    \x0009\&amp;rts/rts/gc_jgc.c\n\
<a name="line-1804"></a> \\n\
<a name="line-1805"></a> \commit 2adf411caac22cf15b1d63d2de80ec9e3b12e843\n\
<a name="line-1806"></a> \Author: kiwamu &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1807"></a> \Date:   Sun Mar 17 16:06:29 2013 +0900\n\
<a name="line-1808"></a> \\n\
<a name="line-1809"></a> \    Upgrade some JHC_EXT_LIBS.\n\
<a name="line-1810"></a> \    \n\
<a name="line-1811"></a> \    Ignore-this: d51be66b69fbe0240775f1464a4d46e7\n\
<a name="line-1812"></a> \    \n\
<a name="line-1813"></a> \    darcs-hash:20130317070629-99646-8d122ceea5273835030a18ac965842896f8f42e1.gz\n\
<a name="line-1814"></a> \\n\
<a name="line-1815"></a> \commit ac8ddb00ddc5aa3580ce3e68cb2773f1536cb638\n\
<a name="line-1816"></a> \Author: kiwamu &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1817"></a> \Date:   Sun Mar 17 02:21:07 2013 +0900\n\
<a name="line-1818"></a> \\n\
<a name="line-1819"></a> \    Explain RTS cflags for tiny cpu.\n\
<a name="line-1820"></a> \    \n\
<a name="line-1821"></a> \    Ignore-this: b09e6da5e1704b9da4a51ae6a23f57ee\n\
<a name="line-1822"></a> \    \n\
<a name="line-1823"></a> \    darcs-hash:20130316172107-99646-d9545e56b6d11bf6511bf35a793f2246cae9b697.gz\n\
<a name="line-1824"></a> \\n\
<a name="line-1825"></a> \commit fa1a95b48fec10d2ee2adc30f5c447cdb36564e5\n\
<a name="line-1826"></a> \Author: Kiwamu Okabe &lt;kiwamu@gmail.com&gt;\n\
<a name="line-1827"></a> \Date:   Sat Mar 16 23:10:41 2013 +0900\n\
<a name="line-1828"></a> \\n\
<a name="line-1829"></a> \    About darcs send command.\n\
<a name="line-1830"></a> \\n\
<a name="line-1831"></a> \commit ddafc4422bea272707775cd680058232b9b40e07\n\
<a name="line-1832"></a> \Author: John Meacham &lt;john@repetae.net&gt;\n\
<a name="line-1833"></a> \Date:   Sat Mar 16 22:14:24 2013 +0900\n\
<a name="line-1834"></a> \\n\
<a name="line-1835"></a> \    add Japanese translation\n\
<a name="line-1836"></a> \    \n\
<a name="line-1837"></a> \    Ignore-this: 771722900017d423f40b25f917392680\n\
<a name="line-1838"></a> \    \n\
<a name="line-1839"></a> \    darcs-hash:20130316131424-1a7c6-1f6707f0212f861d0af8aad5a573efa1a4107879.gz\n\
<a name="line-1840"></a> \\n\
<a name="line-1841"></a> \commit c753139eff5275fe8a48b0ce7fccd0a387409406\n\
<a name="line-1842"></a> \Author: John Meacham &lt;john@repetae.net&gt;\n\
<a name="line-1843"></a> \Date:   Sat Mar 16 22:07:34 2013 +0900\n\
<a name="line-1844"></a> \\n\
<a name="line-1845"></a> \    improve error message\n\
<a name="line-1846"></a> \    \n\
<a name="line-1847"></a> \    Ignore-this: e90f98c675cc6df2770c8bba3a7c313\n\
<a name="line-1848"></a> \    \n\
<a name="line-1849"></a> \    darcs-hash:20130316130734-1a7c6-5e34d40efe9979f39d53361dbd0c194b1d050af3.gz\n\
<a name="line-1850"></a> \\n\
<a name="line-1851"></a> \commit 340727f1a7eb881ba8fec88d77218ad622beb20a\n\
<a name="line-1852"></a> \Author: John Meacham &lt;john@repetae.net&gt;\n\
<a name="line-1853"></a> \Date:   Sat Mar 16 22:07:04 2013 +0900\n\
<a name="line-1854"></a> \\n\
<a name="line-1855"></a> \    add printing of attributed, conjunctive, and disjunctive types.\n\
<a name="line-1856"></a> \    \n\
<a name="line-1857"></a> \    Ignore-this: 71f5c1b073bf7a11bc6187345e03e6d0\n\
<a name="line-1858"></a> \    \n\
<a name="line-1859"></a> \    darcs-hash:20130316130704-1a7c6-4a14b9c3d272dc9d345f3b837fd2adb13997e8cb.gz\n\
<a name="line-1860"></a> \\n\
<a name="line-1861"></a> \commit 712c3748d829da2c6c9c8b5cd3044066dab68f2d\n\
<a name="line-1862"></a> \Author: John Meacham &lt;john@repetae.net&gt;\n\
<a name="line-1863"></a> \Date:   Sat Mar 16 22:04:01 2013 +0900\n\
<a name="line-1864"></a> \\n\
<a name="line-1865"></a> \    convert complex types to hardware implemented complex numbers when available\n\
<a name="line-1866"></a> \    \n\
<a name="line-1867"></a> \    Ignore-this: ec581ab1eaf5f8e1c920e5741fba50ee\n\
<a name="line-1868"></a> \    \n\
<a name="line-1869"></a> \    darcs-hash:20130316130401-1a7c6-162e1c4a44528c0b6c3ec8692027ed79a11468ea.gz\n\
<a name="line-1870"></a> \\n\
<a name="line-1871"></a> \commit db29b9d6356de33dae1678f3f4d1f22eab8502ab\n\
<a name="line-1872"></a> \Author: John Meacham &lt;john@repetae.net&gt;\n\
<a name="line-1873"></a> \Date:   Sat Mar 16 21:56:30 2013 +0900\n\
<a name="line-1874"></a> \\n\
<a name="line-1875"></a> \    Add TyComplex and TyVector to basic types\n\
<a name="line-1876"></a> \    \n\
<a name="line-1877"></a> \    Ignore-this: f8a61d1dc3dd99cf7a481a50c192125f\n\
<a name="line-1878"></a> \    \n\
<a name="line-1879"></a> \    darcs-hash:20130316125630-1a7c6-82f16b518bcc6bd4d4f692ca8575cd0a65e9c361.gz\n\
<a name="line-1880"></a> \\n\
<a name="line-1881"></a> \commit c3db54ed132774c12ba8b8909f458b5681277ad9\n\
<a name="line-1882"></a> \Author: John Meacham &lt;john@repetae.net&gt;\n\
<a name="line-1883"></a> \Date:   Sat Mar 16 21:51:21 2013 +0900\n\
<a name="line-1884"></a> \\n\
<a name="line-1885"></a> \    from Kiwamu Okabe: fix ghc warnings.\n\
<a name="line-1886"></a> \    \n\
<a name="line-1887"></a> \    Ignore-this: 245f7d05dfa93475d82dac08ade9c007\n\
<a name="line-1888"></a> \    \n\
<a name="line-1889"></a> \    darcs-hash:20130316125121-1a7c6-489b97df0250c3724bcc458a0210cd23cc5aae47.gz\n\
<a name="line-1890"></a> \\n\
<a name="line-1891"></a> \commit 4d8f741cd23aecd87b032ea2b41eaa6fa4e75558\n\
<a name="line-1892"></a> \Author: John Meacham &lt;john@repetae.net&gt;\n\
<a name="line-1893"></a> \Date:   Sat Mar 16 21:48:22 2013 +0900\n\
<a name="line-1894"></a> \\n\
<a name="line-1895"></a> \    from Kiwamu Okabe: RTS fix for embedded ARM CPUs\n\
<a name="line-1896"></a> \    \n\
<a name="line-1897"></a> \    Ignore-this: 40ed352498ff8e20d43410ea772f96c0\n\
<a name="line-1898"></a> \    \n\
<a name="line-1899"></a> \    darcs-hash:20130316124822-1a7c6-51653050afc3b9359b57d2b290e480804995a9c4.gz\n\
<a name="line-1900"></a> \\n\
<a name="line-1901"></a> \commit d85bd01d86dcfb6067545175f01e6ff2efae7299\n\
<a name="line-1902"></a> \Author: John Meacham &lt;john@repetae.net&gt;\n\
<a name="line-1903"></a> \Date:   Sat Mar 16 21:46:30 2013 +0900\n\
<a name="line-1904"></a> \\n\
<a name="line-1905"></a> \    from Kiwamu Okabe: ghc 7.6 compatibility\n\
<a name="line-1906"></a> \    \n\
<a name="line-1907"></a> \    Ignore-this: 953ccf73fee4a1d604eec7b0bfd360d8\n\
<a name="line-1908"></a> \    \n\
<a name="line-1909"></a> \    darcs-hash:20130316124630-1a7c6-0fe41016dc7bdf9b1aa6e2d44beab198a3a7ea7d.gz\n\
<a name="line-1910"></a> \\n\
<a name="line-1911"></a> \commit 6adebb83357aa04650f0e734182e2ab18581b998\n\
<a name="line-1912"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1913"></a> \Date:   Sat Mar 16 21:24:46 2013 +0900\n\
<a name="line-1914"></a> \\n\
<a name="line-1915"></a> \    Explain demo on tiny CPU.\n\
<a name="line-1916"></a> \\n\
<a name="line-1917"></a> \commit 22c38dc56117680319a2c8e3c9fae6b425d353ed\n\
<a name="line-1918"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1919"></a> \Date:   Sat Mar 16 17:56:43 2013 +0900\n\
<a name="line-1920"></a> \\n\
<a name="line-1921"></a> \    Add Ajhc 0.8.0.2 Release Note.\n\
<a name="line-1922"></a> \\n\
<a name="line-1923"></a> \commit 904b30ed92df33403c6bae58c7837aca627d1775\n\
<a name="line-1924"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1925"></a> \Date:   Sat Mar 16 11:43:34 2013 +0900\n\
<a name="line-1926"></a> \\n\
<a name="line-1927"></a> \    Do not run CI on master branch.\n\
<a name="line-1928"></a> \\n\
<a name="line-1929"></a> \commit 76d810b331b63a7b9accdc7217f9af4a7727eafb\n\
<a name="line-1930"></a> \Author: Kiwamu Okabe &lt;kiwamu@gmail.com&gt;\n\
<a name="line-1931"></a> \Date:   Sat Mar 16 11:17:42 2013 +0900\n\
<a name="line-1932"></a> \\n\
<a name="line-1933"></a> \    Add future plan.\n\
<a name="line-1934"></a> \\n\
<a name="line-1935"></a> \commit fad2d6340e429bb0a3d0ae86f50615911a6bb1de\n\
<a name="line-1936"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1937"></a> \Date:   Fri Mar 15 21:10:22 2013 +0900\n\
<a name="line-1938"></a> \\n\
<a name="line-1939"></a> \    Use git instead of darcs.\n\
<a name="line-1940"></a> \\n\
<a name="line-1941"></a> \commit e03a1ee09758f8a0e565e30abd5c88a60f72ee5c\n\
<a name="line-1942"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1943"></a> \Date:   Fri Mar 15 21:09:49 2013 +0900\n\
<a name="line-1944"></a> \\n\
<a name="line-1945"></a> \    Update ja.po.\n\
<a name="line-1946"></a> \\n\
<a name="line-1947"></a> \commit 600cb0c4d6ecbbe2ce2e6eea2ddf11a91333635c\n\
<a name="line-1948"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1949"></a> \Date:   Fri Mar 15 14:32:15 2013 +0900\n\
<a name="line-1950"></a> \\n\
<a name="line-1951"></a> \    s/jhc/Ajhc/g on manual_ja.html.\n\
<a name="line-1952"></a> \\n\
<a name="line-1953"></a> \commit 971ac8c04a0546b64a5708ddda6be362cb7f76ef\n\
<a name="line-1954"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1955"></a> \Date:   Fri Mar 15 13:57:55 2013 +0900\n\
<a name="line-1956"></a> \\n\
<a name="line-1957"></a> \    s/jhc/Ajhc/g on manual.html.\n\
<a name="line-1958"></a> \\n\
<a name="line-1959"></a> \commit 57948b53329b6ee108ca14571bf1c6e15d541894\n\
<a name="line-1960"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1961"></a> \Date:   Fri Mar 15 13:27:03 2013 +0900\n\
<a name="line-1962"></a> \\n\
<a name="line-1963"></a> \    A bit change.\n\
<a name="line-1964"></a> \\n\
<a name="line-1965"></a> \commit dc57a14f8b5c86e92b034a2706250e66b07d6ce5\n\
<a name="line-1966"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1967"></a> \Date:   Fri Mar 15 13:09:18 2013 +0900\n\
<a name="line-1968"></a> \\n\
<a name="line-1969"></a> \    Explain new cflags for jgc.\n\
<a name="line-1970"></a> \\n\
<a name="line-1971"></a> \commit 80aa12fb9b57622bba2f0e911d7ebc0c04ddb662\n\
<a name="line-1972"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1973"></a> \Date:   Fri Mar 15 01:00:47 2013 +0900\n\
<a name="line-1974"></a> \\n\
<a name="line-1975"></a> \    Bump up version 0.8.0.1. New RTS for tiny memory.\n\
<a name="line-1976"></a> \\n\
<a name="line-1977"></a> \commit 3167551530b0576cf1f42f928865868ce9aa0b50\n\
<a name="line-1978"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1979"></a> \Date:   Thu Mar 14 05:09:01 2013 +0900\n\
<a name="line-1980"></a> \\n\
<a name="line-1981"></a> \    Copy RTS from demo-cortex-m3.\n\
<a name="line-1982"></a> \\n\
<a name="line-1983"></a> \commit eb7206805ca012bca6d7bfeceed668b9c3f6a3d5\n\
<a name="line-1984"></a> \Author: Kiwamu Okabe &lt;kiwamu@gmail.com&gt;\n\
<a name="line-1985"></a> \Date:   Sun Mar 10 02:59:43 2013 +0900\n\
<a name="line-1986"></a> \\n\
<a name="line-1987"></a> \    Explain branch policy.\n\
<a name="line-1988"></a> \\n\
<a name="line-1989"></a> \commit 202d113021baf66f5f7534c0eb1776e730e53a48\n\
<a name="line-1990"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-1991"></a> \Date:   Thu Mar 7 19:50:06 2013 +0900\n\
<a name="line-1992"></a> \\n\
<a name="line-1993"></a> \    Drop volatile poke patch.\n\
<a name="line-1994"></a> \    \n\
<a name="line-1995"></a> \    Read the thread.\n\
<a name="line-1996"></a> \    http://www.haskell.org/pipermail/jhc/2013-March/001008.html\n\
<a name="line-1997"></a> \\n\
<a name="line-1998"></a> \commit de85f4eb5d8688143c83352631c161792e8cc883\n\
<a name="line-1999"></a> \Author: John Meacham &lt;john@repetae.net&gt;\n\
<a name="line-2000"></a> \Date:   Wed Mar 6 22:02:31 2013 +0900\n\
<a name="line-2001"></a> \\n\
<a name="line-2002"></a> \    Kiwamu Okabe's fix for jhc_aligned_malloc\n\
<a name="line-2003"></a> \    \n\
<a name="line-2004"></a> \    Ignore-this: 4413ee55fe27c401d2fb08a752d8811d\n\
<a name="line-2005"></a> \    \n\
<a name="line-2006"></a> \    darcs-hash:20130306130231-1a7c6-6f4a8a5ba9870d07ef7548da3f2451a37d1d78f2.gz\n\
<a name="line-2007"></a> \\n\
<a name="line-2008"></a> \commit a187199849a4a4cef21bf24c87548374673d81e5\n\
<a name="line-2009"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2010"></a> \Date:   Tue Mar 5 22:47:11 2013 +0900\n\
<a name="line-2011"></a> \\n\
<a name="line-2012"></a> \    Add typesig.\n\
<a name="line-2013"></a> \\n\
<a name="line-2014"></a> \commit 8b41239136cc607eed0d7974b0d6eb643b95faf8\n\
<a name="line-2015"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2016"></a> \Date:   Tue Mar 5 19:50:15 2013 +0900\n\
<a name="line-2017"></a> \\n\
<a name="line-2018"></a> \    Fix \"Not in scope: `catch'\" error on ghc 7.6.2.\n\
<a name="line-2019"></a> \\n\
<a name="line-2020"></a> \commit 647878e884c106439c12c3d271407002dd4196ec\n\
<a name="line-2021"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2022"></a> \Date:   Tue Mar 5 02:12:31 2013 +0900\n\
<a name="line-2023"></a> \\n\
<a name="line-2024"></a> \    Use DoRec instead of RecursiveDo.\n\
<a name="line-2025"></a> \\n\
<a name="line-2026"></a> \commit 86f4306ce526f2081724f446e0a253fc3eb3d33b\n\
<a name="line-2027"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2028"></a> \Date:   Tue Mar 5 01:25:45 2013 +0900\n\
<a name="line-2029"></a> \\n\
<a name="line-2030"></a> \    Fix many ghc warning. (cont.)\n\
<a name="line-2031"></a> \\n\
<a name="line-2032"></a> \commit cbb7aa047150bb98b76abec2f68a3f397853413f\n\
<a name="line-2033"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2034"></a> \Date:   Mon Mar 4 22:48:10 2013 +0900\n\
<a name="line-2035"></a> \\n\
<a name="line-2036"></a> \    Fix many ghc warning. (cont.)\n\
<a name="line-2037"></a> \\n\
<a name="line-2038"></a> \commit 4acae1778d0960e0bcf5038edc2a7158a0582744\n\
<a name="line-2039"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2040"></a> \Date:   Mon Mar 4 21:57:20 2013 +0900\n\
<a name="line-2041"></a> \\n\
<a name="line-2042"></a> \    Remove unused UNPACK pragma.\n\
<a name="line-2043"></a> \\n\
<a name="line-2044"></a> \commit 7409b637f4871d4bda765068c389a8d77c6a2d26\n\
<a name="line-2045"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2046"></a> \Date:   Mon Mar 4 21:36:12 2013 +0900\n\
<a name="line-2047"></a> \\n\
<a name="line-2048"></a> \    Extract functions derived by DrIFT for fixing \"Defined but not used\" warning.\n\
<a name="line-2049"></a> \\n\
<a name="line-2050"></a> \commit 61a96383ad866f599d3950dc1fb7b84a6d7000ca\n\
<a name="line-2051"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2052"></a> \Date:   Mon Mar 4 20:16:13 2013 +0900\n\
<a name="line-2053"></a> \\n\
<a name="line-2054"></a> \    Fix pattern match(es) are non-exhaustive.\n\
<a name="line-2055"></a> \\n\
<a name="line-2056"></a> \commit 151af38ece7ccba7e7f5970948c7fbca3c3bea2d\n\
<a name="line-2057"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2058"></a> \Date:   Mon Mar 4 18:06:41 2013 +0900\n\
<a name="line-2059"></a> \\n\
<a name="line-2060"></a> \    Add iocatch function to use old Prelude.catch.\n\
<a name="line-2061"></a> \\n\
<a name="line-2062"></a> \commit 90a685b03ea75fa4e2c7a13f00b5c1d22d8232b2\n\
<a name="line-2063"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2064"></a> \Date:   Mon Mar 4 17:16:09 2013 +0900\n\
<a name="line-2065"></a> \\n\
<a name="line-2066"></a> \    Fix many ghc warning. (cont.)\n\
<a name="line-2067"></a> \\n\
<a name="line-2068"></a> \commit db79e4312182cc8fc5d3a1d0afa48a343faf3729\n\
<a name="line-2069"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2070"></a> \Date:   Mon Mar 4 17:14:56 2013 +0900\n\
<a name="line-2071"></a> \\n\
<a name="line-2072"></a> \    Set version 0.8.0.0. Ajhc use version number as 0.8.0.x.\n\
<a name="line-2073"></a> \\n\
<a name="line-2074"></a> \commit 502b91a34e7b4c8841f563c0eb458ccab858d3e5\n\
<a name="line-2075"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2076"></a> \Date:   Mon Mar 4 15:41:23 2013 +0900\n\
<a name="line-2077"></a> \\n\
<a name="line-2078"></a> \    Fix many ghc warning. / Add cleanup files.\n\
<a name="line-2079"></a> \\n\
<a name="line-2080"></a> \commit f64cb5a883c096c2ffd7ce85e22d3c6ec1494892\n\
<a name="line-2081"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2082"></a> \Date:   Mon Mar 4 13:06:24 2013 +0900\n\
<a name="line-2083"></a> \\n\
<a name="line-2084"></a> \    Fix some warning on compile ajhc.\n\
<a name="line-2085"></a> \\n\
<a name="line-2086"></a> \commit b3a50378e3d7c5e9f8d52bece2c5250b07f97595\n\
<a name="line-2087"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2088"></a> \Date:   Sat Mar 2 18:26:24 2013 +0900\n\
<a name="line-2089"></a> \\n\
<a name="line-2090"></a> \    Build manual_ja.html with po4a.\n\
<a name="line-2091"></a> \\n\
<a name="line-2092"></a> \commit 531599b10155db4aeb953da3499437320f68efb0\n\
<a name="line-2093"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2094"></a> \Date:   Sat Mar 2 17:46:02 2013 +0900\n\
<a name="line-2095"></a> \\n\
<a name="line-2096"></a> \    Poke function should use volatile prefix to write memory.\n\
<a name="line-2097"></a> \\n\
<a name="line-2098"></a> \commit 7d28d966944f8e29e8b870cb93d82af76a539690\n\
<a name="line-2099"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2100"></a> \Date:   Sat Mar 2 17:44:23 2013 +0900\n\
<a name="line-2101"></a> \\n\
<a name="line-2102"></a> \    rename aligned_alloc to use it with C11 libc\n\
<a name="line-2103"></a> \\n\
<a name="line-2104"></a> \commit 48f25d2099c7e355768ef410e5464f7561a9be36\n\
<a name="line-2105"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2106"></a> \Date:   Sat Mar 2 17:23:05 2013 +0900\n\
<a name="line-2107"></a> \\n\
<a name="line-2108"></a> \    Remove pbuilder setting, because travis-ci can't use chroot.\n\
<a name="line-2109"></a> \    \"W: Failure trying to run: chroot /var/cache/pbuilder/build/15916/. mount -t proc proc /proc\"\n\
<a name="line-2110"></a> \\n\
<a name="line-2111"></a> \commit 186e80ebf33094e033dc2e537e54c3713a042e56\n\
<a name="line-2112"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2113"></a> \Date:   Sat Mar 2 16:55:11 2013 +0900\n\
<a name="line-2114"></a> \\n\
<a name="line-2115"></a> \    Fix option miss.\n\
<a name="line-2116"></a> \\n\
<a name="line-2117"></a> \commit fbb3fd2aa54dd51288adf8f233d76142b1bac402\n\
<a name="line-2118"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2119"></a> \Date:   Sat Mar 2 16:37:30 2013 +0900\n\
<a name="line-2120"></a> \\n\
<a name="line-2121"></a> \    Test pbuilder on travis-ci with pbuilderrc file.\n\
<a name="line-2122"></a> \\n\
<a name="line-2123"></a> \commit b99be49d897b23663762ebdbe027489b42312581\n\
<a name="line-2124"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2125"></a> \Date:   Sat Mar 2 16:09:30 2013 +0900\n\
<a name="line-2126"></a> \\n\
<a name="line-2127"></a> \    Test pbuilder on travis-ci.\n\
<a name="line-2128"></a> \\n\
<a name="line-2129"></a> \commit cf28f1e69aee1732c335ee79524a9832eeb92776\n\
<a name="line-2130"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2131"></a> \Date:   Sat Mar 2 14:10:13 2013 +0900\n\
<a name="line-2132"></a> \\n\
<a name="line-2133"></a> \    s/jhc/ajhc/g\n\
<a name="line-2134"></a> \\n\
<a name="line-2135"></a> \commit d1002d3d8e296dcdc488a41e604eb6c2898a4731\n\
<a name="line-2136"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2137"></a> \Date:   Sat Mar 2 11:44:53 2013 +0900\n\
<a name="line-2138"></a> \\n\
<a name="line-2139"></a> \    Add README.md file for github web page and travis-ci build status.\n\
<a name="line-2140"></a> \\n\
<a name="line-2141"></a> \commit ac5f7963e6ae1c27769afa2d00200c1197d48755\n\
<a name="line-2142"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2143"></a> \Date:   Sat Mar 2 11:41:56 2013 +0900\n\
<a name="line-2144"></a> \\n\
<a name="line-2145"></a> \    Jhs does not support make -j?\n\
<a name="line-2146"></a> \\n\
<a name="line-2147"></a> \commit a41169ffc25083c5a6a8429956b237562ec2cdb3\n\
<a name="line-2148"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2149"></a> \Date:   Sat Mar 2 11:31:45 2013 +0900\n\
<a name="line-2150"></a> \\n\
<a name="line-2151"></a> \    Add -j3 option for make command.\n\
<a name="line-2152"></a> \\n\
<a name="line-2153"></a> \commit b0f9637ea5617438058c187216d5ad924c7c87cb\n\
<a name="line-2154"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2155"></a> \Date:   Sat Mar 2 11:15:40 2013 +0900\n\
<a name="line-2156"></a> \\n\
<a name="line-2157"></a> \    Need libconfig-yaml-perl to regress on travis-ci.\n\
<a name="line-2158"></a> \\n\
<a name="line-2159"></a> \commit 69a66d5f4faa8410ceed63845e51179e60fb9b29\n\
<a name="line-2160"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2161"></a> \Date:   Sat Mar 2 11:00:16 2013 +0900\n\
<a name="line-2162"></a> \\n\
<a name="line-2163"></a> \    Do not use locales-all. It's not found on travis-ci.\n\
<a name="line-2164"></a> \\n\
<a name="line-2165"></a> \commit 6cbc218a48fd7b70d5743a6f3b0a78b287f583b7\n\
<a name="line-2166"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2167"></a> \Date:   Sat Mar 2 10:54:42 2013 +0900\n\
<a name="line-2168"></a> \\n\
<a name="line-2169"></a> \    Write .travis.yml from scratch.\n\
<a name="line-2170"></a> \\n\
<a name="line-2171"></a> \commit 2fa490f923f444840ee1fc51bf0e2e378d3b989a\n\
<a name="line-2172"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2173"></a> \Date:   Sat Mar 2 07:23:15 2013 +0900\n\
<a name="line-2174"></a> \\n\
<a name="line-2175"></a> \    Add regress target to Makefile.\n\
<a name="line-2176"></a> \\n\
<a name="line-2177"></a> \commit f1e72fd1bdfd1d78634d009471e0c76ae61f2f66\n\
<a name="line-2178"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2179"></a> \Date:   Sat Mar 2 06:59:16 2013 +0900\n\
<a name="line-2180"></a> \\n\
<a name="line-2181"></a> \    Use autoconf on travis-ci.\n\
<a name="line-2182"></a> \\n\
<a name="line-2183"></a> \commit d80e701a15200d4958b98f0cb318347b6dd6f56f\n\
<a name="line-2184"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2185"></a> \Date:   Sat Mar 2 06:42:01 2013 +0900\n\
<a name="line-2186"></a> \\n\
<a name="line-2187"></a> \    Add Travis CI setting file.\n\
<a name="line-2188"></a> \\n\
<a name="line-2189"></a> \commit 5892ff8176c0d5179e75ab4c27ea6f58ddc067b9\n\
<a name="line-2190"></a> \Author: Kiwamu Okabe &lt;kiwamu@debian.or.jp&gt;\n\
<a name="line-2191"></a> \Date:   Sat Mar 2 02:44:13 2013 +0900\n\
<a name="line-2192"></a> \\n\
<a name="line-2193"></a> \    Add gitignore file. / Use git for darcs to dump Changelog.\n\
<a name="line-2194"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-2195"></a>
<a name="line-2196"></a><a name="shortchange_txt"></a><span class='hs-comment'>-- | Generated from src\/data\/shortchange.txt</span>
<a name="line-2197"></a><span class='hs-comment'>{-# NOINLINE shortchange_txt #-}</span>
<a name="line-2198"></a><span class='hs-definition'>shortchange_txt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-2199"></a><span class='hs-definition'>shortchange_txt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-2200"></a> \e56ab3927c0329621b546c23e07ace0a1452adf4\
<a name="line-2201"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-2202"></a>
<a name="line-2203"></a><a name="slub_c"></a><span class='hs-comment'>-- | Generated from rts\/rts\/slub.c</span>
<a name="line-2204"></a><span class='hs-comment'>{-# NOINLINE slub_c #-}</span>
<a name="line-2205"></a><span class='hs-definition'>slub_c</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-2206"></a><span class='hs-definition'>slub_c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-2207"></a> \#if _JHC_GC == _JHC_GC_JGC\n\
<a name="line-2208"></a> \\n\
<a name="line-2209"></a> \#ifdef JHC_HEADER\n\
<a name="line-2210"></a> \\n\
<a name="line-2211"></a> \struct s_arena;\n\
<a name="line-2212"></a> \struct s_cache;\n\
<a name="line-2213"></a> \static void *s_alloc(gc_t gc, struct s_cache *sc) A_UNUSED;\n\
<a name="line-2214"></a> \static struct s_cache *find_cache(struct s_cache **rsc, struct s_arena *arena,\n\
<a name="line-2215"></a> \                                  unsigned short size, unsigned short num_ptrs) A_UNUSED;\n\
<a name="line-2216"></a> \static bool s_set_used_bit(void *val) A_UNUSED;\n\
<a name="line-2217"></a> \static void clear_used_bits(struct s_arena *arena) A_UNUSED;\n\
<a name="line-2218"></a> \\n\
<a name="line-2219"></a> \#define S_BLOCK(val) ((struct s_block *)((uintptr_t)(val) &amp; ~ (BLOCK_SIZE - 1)))\n\
<a name="line-2220"></a> \#define BLOCK_SIZE     (1UL &lt;&lt; 12)\n\
<a name="line-2221"></a> \#define MEGABLOCK_SIZE (1UL &lt;&lt; 20)\n\
<a name="line-2222"></a> \\n\
<a name="line-2223"></a> \#else\n\
<a name="line-2224"></a> \\n\
<a name="line-2225"></a> \#include \"sys/bitarray.h\"\n\
<a name="line-2226"></a> \#include \"sys/queue.h\"\n\
<a name="line-2227"></a> \\n\
<a name="line-2228"></a> \struct s_arena {\n\
<a name="line-2229"></a> \        struct s_megablock *current_megablock;\n\
<a name="line-2230"></a> \        SLIST_HEAD(,s_block) free_blocks;\n\
<a name="line-2231"></a> \        unsigned block_used;\n\
<a name="line-2232"></a> \        unsigned block_threshold;\n\
<a name="line-2233"></a> \        SLIST_HEAD(,s_cache) caches;\n\
<a name="line-2234"></a> \        SLIST_HEAD(,s_megablock) megablocks;\n\
<a name="line-2235"></a> \};\n\
<a name="line-2236"></a> \\n\
<a name="line-2237"></a> \struct s_megablock {\n\
<a name="line-2238"></a> \        void *base;\n\
<a name="line-2239"></a> \        unsigned next_free;\n\
<a name="line-2240"></a> \        SLIST_ENTRY(s_megablock) next;\n\
<a name="line-2241"></a> \};\n\
<a name="line-2242"></a> \\n\
<a name="line-2243"></a> \struct s_block_info {\n\
<a name="line-2244"></a> \        unsigned char color;\n\
<a name="line-2245"></a> \        unsigned char size;\n\
<a name="line-2246"></a> \        unsigned char num_ptrs;\n\
<a name="line-2247"></a> \        unsigned char flags;\n\
<a name="line-2248"></a> \};\n\
<a name="line-2249"></a> \\n\
<a name="line-2250"></a> \struct s_block {\n\
<a name="line-2251"></a> \        SLIST_ENTRY(s_block) link;\n\
<a name="line-2252"></a> \        struct s_block_info pi;\n\
<a name="line-2253"></a> \        unsigned short num_free;\n\
<a name="line-2254"></a> \        unsigned short next_free;\n\
<a name="line-2255"></a> \        bitarray_t used[];\n\
<a name="line-2256"></a> \};\n\
<a name="line-2257"></a> \\n\
<a name="line-2258"></a> \struct s_cache {\n\
<a name="line-2259"></a> \        SLIST_ENTRY(s_cache) next;\n\
<a name="line-2260"></a> \        SLIST_HEAD(,s_block) blocks;\n\
<a name="line-2261"></a> \        SLIST_HEAD(,s_block) full_blocks;\n\
<a name="line-2262"></a> \        struct s_block_info pi;\n\
<a name="line-2263"></a> \        unsigned short num_entries;\n\
<a name="line-2264"></a> \        struct s_arena *arena;\n\
<a name="line-2265"></a> \};\n\
<a name="line-2266"></a> \\n\
<a name="line-2267"></a> \/* This finds a bit that isn't set, sets it, then returns its index.  It\n\
<a name="line-2268"></a> \ * assumes that a bit is available to be found, otherwise it goes into an\n\
<a name="line-2269"></a> \ * infinite loop. */\n\
<a name="line-2270"></a> \\n\
<a name="line-2271"></a> \static unsigned\n\
<a name="line-2272"></a> \bitset_find_free(unsigned *next_free,int n,bitarray_t ba[static n]) {\n\
<a name="line-2273"></a> \        assert(*next_free &lt; (unsigned)n);\n\
<a name="line-2274"></a> \        unsigned i = *next_free;\n\
<a name="line-2275"></a> \        do {\n\
<a name="line-2276"></a> \                int o = __builtin_ffsl(~ba[i]);\n\
<a name="line-2277"></a> \                if(__predict_true(o)) {\n\
<a name="line-2278"></a> \                        ba[i] |= (1UL &lt;&lt; (o - 1));\n\
<a name="line-2279"></a> \                        *next_free = i;\n\
<a name="line-2280"></a> \                        return (i*BITS_PER_UNIT + (o - 1));\n\
<a name="line-2281"></a> \                }\n\
<a name="line-2282"></a> \                i = (i + 1) % n;\n\
<a name="line-2283"></a> \                assert(i != *next_free);\n\
<a name="line-2284"></a> \        } while (1);\n\
<a name="line-2285"></a> \}\n\
<a name="line-2286"></a> \\n\
<a name="line-2287"></a> \struct s_megablock *\n\
<a name="line-2288"></a> \s_new_megablock(struct s_arena *arena)\n\
<a name="line-2289"></a> \{\n\
<a name="line-2290"></a> \        struct s_megablock *mb = malloc(sizeof(*mb));\n\
<a name="line-2291"></a> \#if defined(__WIN32__)\n\
<a name="line-2292"></a> \        mb-&gt;base = _aligned_malloc(MEGABLOCK_SIZE, BLOCK_SIZE);\n\
<a name="line-2293"></a> \        int ret = !mb-&gt;base;\n\
<a name="line-2294"></a> \#elif defined(__ARM_EABI__)\n\
<a name="line-2295"></a> \        mb-&gt;base = memalign(BLOCK_SIZE,MEGABLOCK_SIZE);\n\
<a name="line-2296"></a> \        int ret = !mb-&gt;base;\n\
<a name="line-2297"></a> \#elif (defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) &amp;&amp; __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ &lt;  1060)\n\
<a name="line-2298"></a> \        assert(sysconf(_SC_PAGESIZE) == BLOCK_SIZE);\n\
<a name="line-2299"></a> \        mb-&gt;base = valloc(MEGABLOCK_SIZE);\n\
<a name="line-2300"></a> \        int ret = !mb-&gt;base;\n\
<a name="line-2301"></a> \#else\n\
<a name="line-2302"></a> \        int ret = posix_memalign(&amp;mb-&gt;base,BLOCK_SIZE,MEGABLOCK_SIZE);\n\
<a name="line-2303"></a> \#endif\n\
<a name="line-2304"></a> \        if(ret != 0) {\n\
<a name="line-2305"></a> \                fprintf(stderr,\"Unable to allocate memory for megablock\\n\");\n\
<a name="line-2306"></a> \                abort();\n\
<a name="line-2307"></a> \        }\n\
<a name="line-2308"></a> \        VALGRIND_MAKE_MEM_NOACCESS(mb-&gt;base,MEGABLOCK_SIZE);\n\
<a name="line-2309"></a> \        //VALGRIND_FREELIKE_BLOCK(mb-&gt;base,0);\n\
<a name="line-2310"></a> \        mb-&gt;next_free = 0;\n\
<a name="line-2311"></a> \        return mb;\n\
<a name="line-2312"></a> \}\n\
<a name="line-2313"></a> \\n\
<a name="line-2314"></a> \/* block allocator */\n\
<a name="line-2315"></a> \\n\
<a name="line-2316"></a> \static struct s_block *\n\
<a name="line-2317"></a> \get_free_block(gc_t gc, struct s_arena *arena) {\n\
<a name="line-2318"></a> \        arena-&gt;block_used++;\n\
<a name="line-2319"></a> \        if(__predict_true(SLIST_FIRST(&amp;arena-&gt;free_blocks))) {\n\
<a name="line-2320"></a> \                struct s_block *pg = SLIST_FIRST(&amp;arena-&gt;free_blocks);\n\
<a name="line-2321"></a> \                SLIST_REMOVE_HEAD(&amp;arena-&gt;free_blocks,link);\n\
<a name="line-2322"></a> \                return pg;\n\
<a name="line-2323"></a> \        } else {\n\
<a name="line-2324"></a> \                if((arena-&gt;block_used &gt;= arena-&gt;block_threshold)) {\n\
<a name="line-2325"></a> \                        gc_perform_gc(gc);\n\
<a name="line-2326"></a> \                        // if we are still using 80% of the heap after a gc, raise the threshold.\n\
<a name="line-2327"></a> \                        if(__predict_false((unsigned)arena-&gt;block_used * 10 &gt;= arena-&gt;block_threshold * 9)) {\n\
<a name="line-2328"></a> \                                arena-&gt;block_threshold *= 2;\n\
<a name="line-2329"></a> \                        }\n\
<a name="line-2330"></a> \                }\n\
<a name="line-2331"></a> \                if(__predict_false(!arena-&gt;current_megablock))\n\
<a name="line-2332"></a> \                        arena-&gt;current_megablock = s_new_megablock(arena);\n\
<a name="line-2333"></a> \                struct s_megablock *mb = arena-&gt;current_megablock;\n\
<a name="line-2334"></a> \                struct s_block *pg = mb-&gt;base + BLOCK_SIZE*mb-&gt;next_free;\n\
<a name="line-2335"></a> \                mb-&gt;next_free++;\n\
<a name="line-2336"></a> \                if(mb-&gt;next_free == MEGABLOCK_SIZE / BLOCK_SIZE) {\n\
<a name="line-2337"></a> \                        SLIST_INSERT_HEAD(&amp;arena-&gt;megablocks,mb, next);\n\
<a name="line-2338"></a> \                        arena-&gt;current_megablock = NULL;\n\
<a name="line-2339"></a> \                }\n\
<a name="line-2340"></a> \                VALGRIND_MAKE_MEM_UNDEFINED(pg,sizeof(struct s_block));\n\
<a name="line-2341"></a> \                pg-&gt;num_free = 0;\n\
<a name="line-2342"></a> \                return pg;\n\
<a name="line-2343"></a> \        }\n\
<a name="line-2344"></a> \}\n\
<a name="line-2345"></a> \\n\
<a name="line-2346"></a> \static void\n\
<a name="line-2347"></a> \s_cleanup_blocks(struct s_arena *arena) {\n\
<a name="line-2348"></a> \        struct s_cache *sc = SLIST_FIRST(&amp;arena-&gt;caches);\n\
<a name="line-2349"></a> \        for(;sc;sc = SLIST_NEXT(sc,next)) {\n\
<a name="line-2350"></a> \\n\
<a name="line-2351"></a> \                // 'best' keeps track of the block with the fewest free spots\n\
<a name="line-2352"></a> \                // and percolates it to the front, effectively a single pass\n\
<a name="line-2353"></a> \                // of a bubblesort to help combat fragmentation. It does\n\
<a name="line-2354"></a> \                // not increase the complexity of the cleanup algorithm as\n\
<a name="line-2355"></a> \                // we had to scan every block anyway, but over many passes\n\
<a name="line-2356"></a> \                // of the GC it will eventually result in a more sorted list\n\
<a name="line-2357"></a> \                // than would occur by chance.\n\
<a name="line-2358"></a> \\n\
<a name="line-2359"></a> \                struct s_block *best = NULL;\n\
<a name="line-2360"></a> \                int free_best = 4096;\n\
<a name="line-2361"></a> \                struct s_block *pg = SLIST_FIRST(&amp;sc-&gt;blocks);\n\
<a name="line-2362"></a> \                struct s_block *fpg = SLIST_FIRST(&amp;sc-&gt;full_blocks);\n\
<a name="line-2363"></a> \                SLIST_INIT(&amp;sc-&gt;blocks);\n\
<a name="line-2364"></a> \                SLIST_INIT(&amp;sc-&gt;full_blocks);\n\
<a name="line-2365"></a> \                if(!pg) {\n\
<a name="line-2366"></a> \                        pg = fpg;\n\
<a name="line-2367"></a> \                        fpg = NULL;\n\
<a name="line-2368"></a> \                }\n\
<a name="line-2369"></a> \                while(pg) {\n\
<a name="line-2370"></a> \                        struct s_block *npg = SLIST_NEXT(pg,link);\n\
<a name="line-2371"></a> \                        if(__predict_false(pg-&gt;num_free == 0)) {\n\
<a name="line-2372"></a> \                                SLIST_INSERT_HEAD(&amp;sc-&gt;full_blocks,pg,link);\n\
<a name="line-2373"></a> \                        } else if(__predict_true(pg-&gt;num_free == sc-&gt;num_entries)) {\n\
<a name="line-2374"></a> \                                arena-&gt;block_used--;\n\
<a name="line-2375"></a> \                                VALGRIND_MAKE_MEM_NOACCESS((char *)pg + sizeof(struct s_block), BLOCK_SIZE - sizeof(struct s_block));\n\
<a name="line-2376"></a> \                                SLIST_INSERT_HEAD(&amp;arena-&gt;free_blocks,pg,link);\n\
<a name="line-2377"></a> \                        } else {\n\
<a name="line-2378"></a> \                                if(!best) {\n\
<a name="line-2379"></a> \                                        free_best = pg-&gt;num_free;\n\
<a name="line-2380"></a> \                                        best = pg;\n\
<a name="line-2381"></a> \                                } else {\n\
<a name="line-2382"></a> \                                        if(pg-&gt;num_free &lt; free_best) {\n\
<a name="line-2383"></a> \                                                struct s_block *tmp = best;\n\
<a name="line-2384"></a> \                                                best = pg; pg = tmp;\n\
<a name="line-2385"></a> \                                                free_best = pg-&gt;num_free;\n\
<a name="line-2386"></a> \                                        }\n\
<a name="line-2387"></a> \                                        SLIST_INSERT_HEAD(&amp;sc-&gt;blocks,pg,link);\n\
<a name="line-2388"></a> \                                }\n\
<a name="line-2389"></a> \                        }\n\
<a name="line-2390"></a> \                        if(!npg &amp;&amp; fpg) {\n\
<a name="line-2391"></a> \                                pg = fpg;\n\
<a name="line-2392"></a> \                                fpg = NULL;\n\
<a name="line-2393"></a> \                        } else\n\
<a name="line-2394"></a> \                                pg = npg;\n\
<a name="line-2395"></a> \                }\n\
<a name="line-2396"></a> \                if(best)\n\
<a name="line-2397"></a> \                        SLIST_INSERT_HEAD(&amp;sc-&gt;blocks,best,link);\n\
<a name="line-2398"></a> \        }\n\
<a name="line-2399"></a> \}\n\
<a name="line-2400"></a> \\n\
<a name="line-2401"></a> \inline static void\n\
<a name="line-2402"></a> \clear_block_used_bits(unsigned num_entries, struct s_block *pg)\n\
<a name="line-2403"></a> \{\n\
<a name="line-2404"></a> \        pg-&gt;num_free = num_entries;\n\
<a name="line-2405"></a> \        memset(pg-&gt;used,0,BITARRAY_SIZE_IN_BYTES(num_entries) - sizeof(pg-&gt;used[0]));\n\
<a name="line-2406"></a> \        int excess = num_entries % BITS_PER_UNIT;\n\
<a name="line-2407"></a> \        pg-&gt;used[BITARRAY_SIZE(num_entries) - 1] = ~((1UL &lt;&lt; excess) - 1);\n\
<a name="line-2408"></a> \#if JHC_VALGRIND\n\
<a name="line-2409"></a> \                unsigned header =  sizeof(struct s_block) + BITARRAY_SIZE_IN_BYTES(num_entries);\n\
<a name="line-2410"></a> \                VALGRIND_MAKE_MEM_NOACCESS((char *)pg + header, BLOCK_SIZE - header);\n\
<a name="line-2411"></a> \#endif\n\
<a name="line-2412"></a> \}\n\
<a name="line-2413"></a> \\n\
<a name="line-2414"></a> \static void *\n\
<a name="line-2415"></a> \s_alloc(gc_t gc, struct s_cache *sc)\n\
<a name="line-2416"></a> \{\n\
<a name="line-2417"></a> \        struct s_block *pg = SLIST_FIRST(&amp;sc-&gt;blocks);\n\
<a name="line-2418"></a> \        if(__predict_false(!pg)) {\n\
<a name="line-2419"></a> \                pg = get_free_block(gc, sc-&gt;arena);\n\
<a name="line-2420"></a> \                VALGRIND_MAKE_MEM_NOACCESS(pg, BLOCK_SIZE);\n\
<a name="line-2421"></a> \                VALGRIND_MAKE_MEM_DEFINED(pg, sizeof(struct s_block));\n\
<a name="line-2422"></a> \                if(sc-&gt;num_entries != pg-&gt;num_free)\n\
<a name="line-2423"></a> \                        VALGRIND_MAKE_MEM_UNDEFINED((char *)pg-&gt;used,BITARRAY_SIZE_IN_BYTES(sc-&gt;num_entries));\n\
<a name="line-2424"></a> \                else\n\
<a name="line-2425"></a> \                        VALGRIND_MAKE_MEM_DEFINED((char *)pg-&gt;used,BITARRAY_SIZE_IN_BYTES(sc-&gt;num_entries));\n\
<a name="line-2426"></a> \                assert(pg);\n\
<a name="line-2427"></a> \                pg-&gt;pi = sc-&gt;pi;\n\
<a name="line-2428"></a> \                pg-&gt;next_free = 0;\n\
<a name="line-2429"></a> \                SLIST_INSERT_HEAD(&amp;sc-&gt;blocks,pg,link);\n\
<a name="line-2430"></a> \                if(sc-&gt;num_entries != pg-&gt;num_free)\n\
<a name="line-2431"></a> \                        clear_block_used_bits(sc-&gt;num_entries, pg);\n\
<a name="line-2432"></a> \                pg-&gt;used[0] = 1; //set the first bit\n\
<a name="line-2433"></a> \                pg-&gt;num_free = sc-&gt;num_entries - 1;\n\
<a name="line-2434"></a> \                return (uintptr_t *)pg + pg-&gt;pi.color;\n\
<a name="line-2435"></a> \        } else {\n\
<a name="line-2436"></a> \                __builtin_prefetch(pg-&gt;used,1);\n\
<a name="line-2437"></a> \                pg-&gt;num_free--;\n\
<a name="line-2438"></a> \                unsigned next_free = pg-&gt;next_free;\n\
<a name="line-2439"></a> \                unsigned found = bitset_find_free(&amp;next_free,BITARRAY_SIZE(sc-&gt;num_entries),pg-&gt;used);\n\
<a name="line-2440"></a> \                pg-&gt;next_free = next_free;\n\
<a name="line-2441"></a> \                void *val = (uintptr_t *)pg + pg-&gt;pi.color + found*pg-&gt;pi.size;\n\
<a name="line-2442"></a> \                if(__predict_false(0 == pg-&gt;num_free)) {\n\
<a name="line-2443"></a> \                        assert(pg == SLIST_FIRST(&amp;sc-&gt;blocks));\n\
<a name="line-2444"></a> \                        SLIST_REMOVE_HEAD(&amp;sc-&gt;blocks,link);\n\
<a name="line-2445"></a> \                        SLIST_INSERT_HEAD(&amp;sc-&gt;full_blocks,pg,link);\n\
<a name="line-2446"></a> \                }\n\
<a name="line-2447"></a> \                assert(S_BLOCK(val) == pg);\n\
<a name="line-2448"></a> \                //printf(\"s_alloc: val: %p s_block: %p size: %i color: %i found: %i num_free: %i\\n\", val, pg, pg-&gt;pi.size, pg-&gt;pi.color, found, pg-&gt;num_free);\n\
<a name="line-2449"></a> \                return val;\n\
<a name="line-2450"></a> \        }\n\
<a name="line-2451"></a> \}\n\
<a name="line-2452"></a> \\n\
<a name="line-2453"></a> \/*\n\
<a name="line-2454"></a> \static void\n\
<a name="line-2455"></a> \s_free(void *val)\n\
<a name="line-2456"></a> \{\n\
<a name="line-2457"></a> \        assert(val);\n\
<a name="line-2458"></a> \        struct s_block *pg = s_block(val);\n\
<a name="line-2459"></a> \        unsigned int offset = ((uintptr_t *)val - (uintptr_t *)pg) - pg-&gt;pi.color;\n\
<a name="line-2460"></a> \//        printf(\"s_free:  val: %p s_block: %p size: %i color: %i num_free: %i offset: %i bit: %i\\n\", val, pg, pg-&gt;pi.size, pg-&gt;pi.color, pg-&gt;num_free, offset, offset/pg-&gt;pi.size);\n\
<a name="line-2461"></a> \        assert(BIT_VALUE(pg-&gt;used,offset/(pg-&gt;pi.size)));\n\
<a name="line-2462"></a> \        BIT_UNSET(pg-&gt;used,offset/(pg-&gt;pi.size));\n\
<a name="line-2463"></a> \        pg-&gt;num_free++;\n\
<a name="line-2464"></a> \}\n\
<a name="line-2465"></a> \*/\n\
<a name="line-2466"></a> \\n\
<a name="line-2467"></a> \static struct s_cache *\n\
<a name="line-2468"></a> \new_cache(struct s_arena *arena, unsigned short size, unsigned short num_ptrs)\n\
<a name="line-2469"></a> \{\n\
<a name="line-2470"></a> \        struct s_cache *sc = malloc(sizeof(*sc));\n\
<a name="line-2471"></a> \        sc-&gt;arena = arena;\n\
<a name="line-2472"></a> \        sc-&gt;pi.size = size;\n\
<a name="line-2473"></a> \        sc-&gt;pi.num_ptrs = num_ptrs;\n\
<a name="line-2474"></a> \        sc-&gt;pi.flags = 0;\n\
<a name="line-2475"></a> \        size_t excess = BLOCK_SIZE - sizeof(struct s_block);\n\
<a name="line-2476"></a> \        sc-&gt;num_entries = (8*excess) / (8*sizeof(uintptr_t)*size + 1) - 1;\n\
<a name="line-2477"></a> \        //sc-&gt;num_entries = (8*excess) / (8*size*sizeof(uintptr_t) + 1);\n\
<a name="line-2478"></a> \        sc-&gt;pi.color = (sizeof(struct s_block) + BITARRAY_SIZE_IN_BYTES(sc-&gt;num_entries) + sizeof(uintptr_t) - 1) / sizeof(uintptr_t);\n\
<a name="line-2479"></a> \        SLIST_INIT(&amp;sc-&gt;blocks);\n\
<a name="line-2480"></a> \        SLIST_INIT(&amp;sc-&gt;full_blocks);\n\
<a name="line-2481"></a> \        SLIST_INSERT_HEAD(&amp;arena-&gt;caches,sc,next);\n\
<a name="line-2482"></a> \        //print_cache(sc);\n\
<a name="line-2483"></a> \        return sc;\n\
<a name="line-2484"></a> \}\n\
<a name="line-2485"></a> \\n\
<a name="line-2486"></a> \// clear all used bits, must be followed by a marking phase.\n\
<a name="line-2487"></a> \static void\n\
<a name="line-2488"></a> \clear_used_bits(struct s_arena *arena)\n\
<a name="line-2489"></a> \{\n\
<a name="line-2490"></a> \        struct s_cache *sc = SLIST_FIRST(&amp;arena-&gt;caches);\n\
<a name="line-2491"></a> \        for(;sc;sc = SLIST_NEXT(sc,next)) {\n\
<a name="line-2492"></a> \                struct s_block *pg = SLIST_FIRST(&amp;sc-&gt;blocks);\n\
<a name="line-2493"></a> \                struct s_block *fpg = SLIST_FIRST(&amp;sc-&gt;full_blocks);\n\
<a name="line-2494"></a> \                do {\n\
<a name="line-2495"></a> \                        for(;pg;pg = SLIST_NEXT(pg,link))\n\
<a name="line-2496"></a> \                                clear_block_used_bits(sc-&gt;num_entries,pg);\n\
<a name="line-2497"></a> \                        pg = fpg;\n\
<a name="line-2498"></a> \                        fpg = NULL;\n\
<a name="line-2499"></a> \                }  while(pg);\n\
<a name="line-2500"></a> \        }\n\
<a name="line-2501"></a> \}\n\
<a name="line-2502"></a> \\n\
<a name="line-2503"></a> \// set a used bit. returns true if the\n\
<a name="line-2504"></a> \// tagged node should be scanned by the GC.\n\
<a name="line-2505"></a> \// this happens when the used bit was not previously set\n\
<a name="line-2506"></a> \// and the node contains internal pointers.\n\
<a name="line-2507"></a> \\n\
<a name="line-2508"></a> \static bool\n\
<a name="line-2509"></a> \s_set_used_bit(void *val)\n\
<a name="line-2510"></a> \{\n\
<a name="line-2511"></a> \        assert(val);\n\
<a name="line-2512"></a> \        struct s_block *pg = S_BLOCK(val);\n\
<a name="line-2513"></a> \        unsigned int offset = ((uintptr_t *)val - (uintptr_t *)pg) - pg-&gt;pi.color;\n\
<a name="line-2514"></a> \        if(__predict_true(BIT_IS_UNSET(pg-&gt;used,offset/pg-&gt;pi.size))) {\n\
<a name="line-2515"></a> \                BIT_SET(pg-&gt;used,offset/pg-&gt;pi.size);\n\
<a name="line-2516"></a> \                pg-&gt;num_free--;\n\
<a name="line-2517"></a> \                return (bool)pg-&gt;pi.num_ptrs;\n\
<a name="line-2518"></a> \        }\n\
<a name="line-2519"></a> \        return false;\n\
<a name="line-2520"></a> \}\n\
<a name="line-2521"></a> \\n\
<a name="line-2522"></a> \static struct s_cache *\n\
<a name="line-2523"></a> \find_cache(struct s_cache **rsc, struct s_arena *arena, unsigned short size, unsigned short num_ptrs)\n\
<a name="line-2524"></a> \{\n\
<a name="line-2525"></a> \        if(__predict_true(rsc &amp;&amp; *rsc))\n\
<a name="line-2526"></a> \                return *rsc;\n\
<a name="line-2527"></a> \        struct s_cache *sc = SLIST_FIRST(&amp;arena-&gt;caches);\n\
<a name="line-2528"></a> \        for(;sc;sc = SLIST_NEXT(sc,next)) {\n\
<a name="line-2529"></a> \                if(sc-&gt;pi.size == size &amp;&amp; sc-&gt;pi.num_ptrs == num_ptrs)\n\
<a name="line-2530"></a> \                        goto found;\n\
<a name="line-2531"></a> \        }\n\
<a name="line-2532"></a> \        sc = new_cache(arena,size,num_ptrs);\n\
<a name="line-2533"></a> \found:\n\
<a name="line-2534"></a> \        if(rsc)\n\
<a name="line-2535"></a> \                *rsc = sc;\n\
<a name="line-2536"></a> \        return sc;\n\
<a name="line-2537"></a> \}\n\
<a name="line-2538"></a> \\n\
<a name="line-2539"></a> \struct s_arena *\n\
<a name="line-2540"></a> \new_arena(void) {\n\
<a name="line-2541"></a> \        struct s_arena *arena = malloc(sizeof(struct s_arena));\n\
<a name="line-2542"></a> \        SLIST_INIT(&amp;arena-&gt;caches);\n\
<a name="line-2543"></a> \        SLIST_INIT(&amp;arena-&gt;free_blocks);\n\
<a name="line-2544"></a> \        SLIST_INIT(&amp;arena-&gt;megablocks);\n\
<a name="line-2545"></a> \        arena-&gt;block_used = 0;\n\
<a name="line-2546"></a> \        arena-&gt;block_threshold = 8;\n\
<a name="line-2547"></a> \        arena-&gt;current_megablock = NULL;\n\
<a name="line-2548"></a> \        return arena;\n\
<a name="line-2549"></a> \}\n\
<a name="line-2550"></a> \\n\
<a name="line-2551"></a> \void\n\
<a name="line-2552"></a> \print_cache(struct s_cache *sc) {\n\
<a name="line-2553"></a> \        fprintf(stderr, \"num_entries: %i\\n\",(int)sc-&gt;num_entries);\n\
<a name="line-2554"></a> \//        printf(\"  entries: %i words\\n\",(int)(sc-&gt;num_entries*sc-&gt;pi.size));\n\
<a name="line-2555"></a> \        fprintf(stderr, \"  header: %lu bytes\\n\", sizeof(struct s_block) + BITARRAY_SIZE_IN_BYTES(sc-&gt;num_entries));\n\
<a name="line-2556"></a> \        fprintf(stderr, \"  size: %i words\\n\",(int)sc-&gt;pi.size);\n\
<a name="line-2557"></a> \//        printf(\"  color: %i words\\n\",(int)sc-&gt;pi.color);\n\
<a name="line-2558"></a> \        fprintf(stderr, \"  nptrs: %i words\\n\",(int)sc-&gt;pi.num_ptrs);\n\
<a name="line-2559"></a> \//        printf(\"  end: %i bytes\\n\",(int)(sc-&gt;pi.color+ sc-&gt;num_entries*sc-&gt;pi.size)*sizeof(uintptr_t));\n\
<a name="line-2560"></a> \        fprintf(stderr, \"%20s %9s %9s %s\\n\", \"block\", \"num_free\", \"next_free\", \"status\");\n\
<a name="line-2561"></a> \        struct s_block *pg;\n\
<a name="line-2562"></a> \        SLIST_FOREACH(pg,&amp;sc-&gt;blocks,link) {\n\
<a name="line-2563"></a> \            fprintf(stderr, \"%20p %9i %9i %c\\n\", pg, pg-&gt;num_free, pg-&gt;next_free, 'P');\n\
<a name="line-2564"></a> \        }\n\
<a name="line-2565"></a> \        fprintf(stderr, \"  full_blocks:\\n\");\n\
<a name="line-2566"></a> \        SLIST_FOREACH(pg,&amp;sc-&gt;full_blocks,link) {\n\
<a name="line-2567"></a> \            fprintf(stderr, \"%20p %9i %9i %c\\n\", pg, pg-&gt;num_free, pg-&gt;next_free, 'F');\n\
<a name="line-2568"></a> \        }\n\
<a name="line-2569"></a> \}\n\
<a name="line-2570"></a> \\n\
<a name="line-2571"></a> \#endif\n\
<a name="line-2572"></a> \#endif\n\
<a name="line-2573"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-2574"></a>
<a name="line-2575"></a><a name="gc_jgc_c"></a><span class='hs-comment'>-- | Generated from rts\/rts\/gc_jgc.c</span>
<a name="line-2576"></a><span class='hs-comment'>{-# NOINLINE gc_jgc_c #-}</span>
<a name="line-2577"></a><span class='hs-definition'>gc_jgc_c</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-2578"></a><span class='hs-definition'>gc_jgc_c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-2579"></a> \#include \"jhc_rts_header.h\"\n\
<a name="line-2580"></a> \#include \"sys/queue.h\"\n\
<a name="line-2581"></a> \#include \"sys/bitarray.h\"\n\
<a name="line-2582"></a> \#include \"rts/cdefs.h\"\n\
<a name="line-2583"></a> \#include \"rts/constants.h\"\n\
<a name="line-2584"></a> \#include \"rts/gc_jgc_internal.h\"\n\
<a name="line-2585"></a> \\n\
<a name="line-2586"></a> \#if _JHC_GC == _JHC_GC_JGC\n\
<a name="line-2587"></a> \\n\
<a name="line-2588"></a> \#ifdef _JHC_JGC_FIXED_MEGABLOCK\n\
<a name="line-2589"></a> \static char aligned_megablock_1[MEGABLOCK_SIZE] __attribute__ ((aligned(BLOCK_SIZE)));\n\
<a name="line-2590"></a> \static char gc_stack_base_area[(1UL &lt;&lt; 8)*sizeof(gc_t)];\n\
<a name="line-2591"></a> \#endif\n\
<a name="line-2592"></a> \gc_t saved_gc; /* xxx Remove me. */\n\
<a name="line-2593"></a> \arena_t saved_arena; /* xxx Remove me. */\n\
<a name="line-2594"></a> \\n\
<a name="line-2595"></a> \#define TO_GCPTR(x) (entry_t *)(FROM_SPTR(x))\n\
<a name="line-2596"></a> \\n\
<a name="line-2597"></a> \void gc_perform_gc(gc_t gc, arena_t arena) A_STD;\n\
<a name="line-2598"></a> \static bool s_set_used_bit(void *val) A_UNUSED;\n\
<a name="line-2599"></a> \static void clear_used_bits(arena_t arena) A_UNUSED;\n\
<a name="line-2600"></a> \static void s_cleanup_blocks(arena_t arena);\n\
<a name="line-2601"></a> \static struct s_block *get_free_block(gc_t gc, arena_t arena, bool retry);\n\
<a name="line-2602"></a> \static void *jhc_aligned_alloc(unsigned size);\n\
<a name="line-2603"></a> \\n\
<a name="line-2604"></a> \typedef struct {\n\
<a name="line-2605"></a> \        sptr_t ptrs[0];\n\
<a name="line-2606"></a> \} entry_t;\n\
<a name="line-2607"></a> \\n\
<a name="line-2608"></a> \static const void *nh_start, *nh_end;\n\
<a name="line-2609"></a> \\n\
<a name="line-2610"></a> \static bool\n\
<a name="line-2611"></a> \gc_check_heap(entry_t *s)\n\
<a name="line-2612"></a> \{\n\
<a name="line-2613"></a> \        return (s &lt; (entry_t *)nh_start || s &gt; (entry_t *)nh_end);\n\
<a name="line-2614"></a> \}\n\
<a name="line-2615"></a> \\n\
<a name="line-2616"></a> \struct stack {\n\
<a name="line-2617"></a> \        unsigned size;\n\
<a name="line-2618"></a> \        unsigned ptr;\n\
<a name="line-2619"></a> \        entry_t * *stack;\n\
<a name="line-2620"></a> \};\n\
<a name="line-2621"></a> \\n\
<a name="line-2622"></a> \#define EMPTY_STACK { 0, 0, NULL }\n\
<a name="line-2623"></a> \\n\
<a name="line-2624"></a> \static void\n\
<a name="line-2625"></a> \stack_grow(struct stack *s, unsigned grow)\n\
<a name="line-2626"></a> \{\n\
<a name="line-2627"></a> \        s-&gt;size += grow;\n\
<a name="line-2628"></a> \        s-&gt;stack = realloc(s-&gt;stack, sizeof(s-&gt;stack[0])*s-&gt;size);\n\
<a name="line-2629"></a> \        assert(s-&gt;stack);\n\
<a name="line-2630"></a> \        debugf(\"stack:\");\n\
<a name="line-2631"></a> \        for(unsigned i = 0; i &lt; s-&gt;ptr; i++) {\n\
<a name="line-2632"></a> \                debugf(\" %p\", (void *)s-&gt;stack[i]);\n\
<a name="line-2633"></a> \        }\n\
<a name="line-2634"></a> \        debugf(\"\\n\");\n\
<a name="line-2635"></a> \}\n\
<a name="line-2636"></a> \\n\
<a name="line-2637"></a> \inline static void\n\
<a name="line-2638"></a> \stack_check(struct stack *s, unsigned n) {\n\
<a name="line-2639"></a> \        if(__predict_false(s-&gt;size - s-&gt;ptr &lt; n)) {\n\
<a name="line-2640"></a> \#ifndef _JHC_JGC_STACKGROW\n\
<a name="line-2641"></a> \#define _JHC_JGC_STACKGROW (1024)\n\
<a name="line-2642"></a> \#endif\n\
<a name="line-2643"></a> \                stack_grow(s,n + (_JHC_JGC_STACKGROW));\n\
<a name="line-2644"></a> \        }\n\
<a name="line-2645"></a> \}\n\
<a name="line-2646"></a> \\n\
<a name="line-2647"></a> \static struct stack root_stack = EMPTY_STACK;\n\
<a name="line-2648"></a> \\n\
<a name="line-2649"></a> \void gc_add_root(gc_t gc, arena_t arena, void *root)\n\
<a name="line-2650"></a> \{\n\
<a name="line-2651"></a> \        if(IS_PTR(root)) {\n\
<a name="line-2652"></a> \                entry_t *nroot = TO_GCPTR(root);\n\
<a name="line-2653"></a> \                if(gc_check_heap(nroot)) {\n\
<a name="line-2654"></a> \                        stack_check(&amp;root_stack,1);\n\
<a name="line-2655"></a> \                        root_stack.stack[root_stack.ptr++] = nroot;\n\
<a name="line-2656"></a> \                }\n\
<a name="line-2657"></a> \        }\n\
<a name="line-2658"></a> \}\n\
<a name="line-2659"></a> \\n\
<a name="line-2660"></a> \static void\n\
<a name="line-2661"></a> \gc_add_grey(struct stack *stack, entry_t *s)\n\
<a name="line-2662"></a> \{\n\
<a name="line-2663"></a> \        VALGRIND_MAKE_MEM_DEFINED(s,(S_BLOCK(s))-&gt;u.pi.size * sizeof(uintptr_t));\n\
<a name="line-2664"></a> \        if(gc_check_heap(s) &amp;&amp; s_set_used_bit(s))\n\
<a name="line-2665"></a> \                stack-&gt;stack[stack-&gt;ptr++] = s;\n\
<a name="line-2666"></a> \}\n\
<a name="line-2667"></a> \\n\
<a name="line-2668"></a> \void A_STD\n\
<a name="line-2669"></a> \gc_perform_gc(gc_t gc, arena_t arena)\n\
<a name="line-2670"></a> \{\n\
<a name="line-2671"></a> \        profile_push(&amp;gc_gc_time);\n\
<a name="line-2672"></a> \        saved_arena-&gt;number_gcs++;\n\
<a name="line-2673"></a> \\n\
<a name="line-2674"></a> \        unsigned number_redirects = 0;\n\
<a name="line-2675"></a> \        unsigned number_stack = 0;\n\
<a name="line-2676"></a> \        unsigned number_ptr = 0;\n\
<a name="line-2677"></a> \        struct stack stack = EMPTY_STACK;\n\
<a name="line-2678"></a> \\n\
<a name="line-2679"></a> \        clear_used_bits(saved_arena);\n\
<a name="line-2680"></a> \\n\
<a name="line-2681"></a> \        debugf(\"Setting Roots:\");\n\
<a name="line-2682"></a> \        stack_check(&amp;stack, root_stack.ptr);\n\
<a name="line-2683"></a> \        for(unsigned i = 0; i &lt; root_stack.ptr; i++) {\n\
<a name="line-2684"></a> \                gc_add_grey(&amp;stack, root_stack.stack[i]);\n\
<a name="line-2685"></a> \                debugf(\" %p\", root_stack.stack[i]);\n\
<a name="line-2686"></a> \        }\n\
<a name="line-2687"></a> \        debugf(\" # \");\n\
<a name="line-2688"></a> \        struct StablePtr *sp;\n\
<a name="line-2689"></a> \        LIST_FOREACH(sp, &amp;root_StablePtrs, link) {\n\
<a name="line-2690"></a> \            gc_add_grey(&amp;stack, (entry_t *)sp);\n\
<a name="line-2691"></a> \            debugf(\" %p\", root_stack.stack[i]);\n\
<a name="line-2692"></a> \        }\n\
<a name="line-2693"></a> \\n\
<a name="line-2694"></a> \        debugf(\"\\n\");\n\
<a name="line-2695"></a> \        debugf(\"Trace:\");\n\
<a name="line-2696"></a> \        stack_check(&amp;stack, gc - saved_arena-&gt;gc_stack_base);\n\
<a name="line-2697"></a> \        number_stack = gc - saved_arena-&gt;gc_stack_base;\n\
<a name="line-2698"></a> \        for(unsigned i = 0; i &lt; number_stack; i++) {\n\
<a name="line-2699"></a> \                debugf(\" |\");\n\
<a name="line-2700"></a> \                // TODO - short circuit redirects on stack\n\
<a name="line-2701"></a> \                sptr_t ptr = saved_arena-&gt;gc_stack_base[i];\n\
<a name="line-2702"></a> \                if(1 &amp;&amp; (IS_LAZY(ptr))) {\n\
<a name="line-2703"></a> \                        assert(GET_PTYPE(ptr) == P_LAZY);\n\
<a name="line-2704"></a> \                        VALGRIND_MAKE_MEM_DEFINED(FROM_SPTR(ptr), sizeof(uintptr_t));\n\
<a name="line-2705"></a> \                        if(!IS_LAZY(GETHEAD(FROM_SPTR(ptr)))) {\n\
<a name="line-2706"></a> \                                void *gptr = TO_GCPTR(ptr);\n\
<a name="line-2707"></a> \                                if(gc_check_heap(gptr))\n\
<a name="line-2708"></a> \                                        s_set_used_bit(gptr);\n\
<a name="line-2709"></a> \                                number_redirects++;\n\
<a name="line-2710"></a> \                                debugf(\" *\");\n\
<a name="line-2711"></a> \                                ptr = (sptr_t)GETHEAD(FROM_SPTR(ptr));\n\
<a name="line-2712"></a> \                        }\n\
<a name="line-2713"></a> \                }\n\
<a name="line-2714"></a> \                if(__predict_false(!IS_PTR(ptr))) {\n\
<a name="line-2715"></a> \                        debugf(\" -\");\n\
<a name="line-2716"></a> \                        continue;\n\
<a name="line-2717"></a> \                }\n\
<a name="line-2718"></a> \                number_ptr++;\n\
<a name="line-2719"></a> \                entry_t *e = TO_GCPTR(ptr);\n\
<a name="line-2720"></a> \                debugf(\" %p\",(void *)e);\n\
<a name="line-2721"></a> \                gc_add_grey(&amp;stack, e);\n\
<a name="line-2722"></a> \        }\n\
<a name="line-2723"></a> \        debugf(\"\\n\");\n\
<a name="line-2724"></a> \\n\
<a name="line-2725"></a> \        while(stack.ptr) {\n\
<a name="line-2726"></a> \                entry_t *e = stack.stack[--stack.ptr];\n\
<a name="line-2727"></a> \                struct s_block *pg = S_BLOCK(e);\n\
<a name="line-2728"></a> \                if(!(pg-&gt;flags &amp; SLAB_MONOLITH))\n\
<a name="line-2729"></a> \                        VALGRIND_MAKE_MEM_DEFINED(e,pg-&gt;u.pi.size * sizeof(uintptr_t));\n\
<a name="line-2730"></a> \                debugf(\"Processing Grey: %p\\n\",e);\n\
<a name="line-2731"></a> \                unsigned num_ptrs = pg-&gt;flags &amp; SLAB_MONOLITH ? pg-&gt;u.m.num_ptrs : pg-&gt;u.pi.num_ptrs;\n\
<a name="line-2732"></a> \                stack_check(&amp;stack, num_ptrs);\n\
<a name="line-2733"></a> \                for(unsigned i = 0; i &lt; num_ptrs; i++) {\n\
<a name="line-2734"></a> \                        if(1 &amp;&amp; (P_LAZY == GET_PTYPE(e-&gt;ptrs[i]))) {\n\
<a name="line-2735"></a> \                                VALGRIND_MAKE_MEM_DEFINED(FROM_SPTR(e-&gt;ptrs[i]), sizeof(uintptr_t));\n\
<a name="line-2736"></a> \                                if(!IS_LAZY(GETHEAD(FROM_SPTR(e-&gt;ptrs[i])))) {\n\
<a name="line-2737"></a> \                                        number_redirects++;\n\
<a name="line-2738"></a> \                                        debugf(\" *\");\n\
<a name="line-2739"></a> \                                        e-&gt;ptrs[i] = (sptr_t)GETHEAD(FROM_SPTR(e-&gt;ptrs[i]));\n\
<a name="line-2740"></a> \                                }\n\
<a name="line-2741"></a> \                        }\n\
<a name="line-2742"></a> \                        if(IS_PTR(e-&gt;ptrs[i])) {\n\
<a name="line-2743"></a> \                                entry_t * ptr = TO_GCPTR(e-&gt;ptrs[i]);\n\
<a name="line-2744"></a> \                                debugf(\"Following: %p %p\\n\",e-&gt;ptrs[i], ptr);\n\
<a name="line-2745"></a> \                                gc_add_grey( &amp;stack, ptr);\n\
<a name="line-2746"></a> \                        }\n\
<a name="line-2747"></a> \                }\n\
<a name="line-2748"></a> \        }\n\
<a name="line-2749"></a> \        free(stack.stack);\n\
<a name="line-2750"></a> \        s_cleanup_blocks(saved_arena);\n\
<a name="line-2751"></a> \        if (JHC_STATUS) {\n\
<a name="line-2752"></a> \                fprintf(stderr, \"%3u - %6u Used: %4u Thresh: %4u Ss: %5u Ps: %5u Rs: %5u Root: %3u\\n\",\n\
<a name="line-2753"></a> \                        saved_arena-&gt;number_gcs,\n\
<a name="line-2754"></a> \                        saved_arena-&gt;number_allocs,\n\
<a name="line-2755"></a> \                        (unsigned)saved_arena-&gt;block_used,\n\
<a name="line-2756"></a> \                        (unsigned)saved_arena-&gt;block_threshold,\n\
<a name="line-2757"></a> \                        number_stack,\n\
<a name="line-2758"></a> \                        number_ptr,\n\
<a name="line-2759"></a> \                        number_redirects,\n\
<a name="line-2760"></a> \                        (unsigned)root_stack.ptr\n\
<a name="line-2761"></a> \                       );\n\
<a name="line-2762"></a> \                saved_arena-&gt;number_allocs = 0;\n\
<a name="line-2763"></a> \        }\n\
<a name="line-2764"></a> \        profile_pop(&amp;gc_gc_time);\n\
<a name="line-2765"></a> \}\n\
<a name="line-2766"></a> \\n\
<a name="line-2767"></a> \// 7 to share caches with the first 7 tuples\n\
<a name="line-2768"></a> \#define GC_STATIC_ARRAY_NUM 7\n\
<a name="line-2769"></a> \#define GC_MAX_BLOCK_ENTRIES 150\n\
<a name="line-2770"></a> \\n\
<a name="line-2771"></a> \static struct s_cache *array_caches[GC_STATIC_ARRAY_NUM];\n\
<a name="line-2772"></a> \static struct s_cache *array_caches_atomic[GC_STATIC_ARRAY_NUM];\n\
<a name="line-2773"></a> \\n\
<a name="line-2774"></a> \void\n\
<a name="line-2775"></a> \jhc_alloc_init(void) {\n\
<a name="line-2776"></a> \        VALGRIND_PRINTF(\"Jhc-Valgrind mode active.\\n\");\n\
<a name="line-2777"></a> \        saved_arena = new_arena();\n\
<a name="line-2778"></a> \#ifdef _JHC_JGC_FIXED_MEGABLOCK\n\
<a name="line-2779"></a> \        saved_gc = saved_arena-&gt;gc_stack_base = (void *) gc_stack_base_area;\n\
<a name="line-2780"></a> \#else\n\
<a name="line-2781"></a> \        saved_gc = saved_arena-&gt;gc_stack_base = malloc((1UL &lt;&lt; 18)*sizeof(saved_arena-&gt;gc_stack_base[0]));\n\
<a name="line-2782"></a> \#endif\n\
<a name="line-2783"></a> \        if(nh_stuff[0]) {\n\
<a name="line-2784"></a> \                nh_end = nh_start = nh_stuff[0];\n\
<a name="line-2785"></a> \                for(int i = 1; nh_stuff[i]; i++) {\n\
<a name="line-2786"></a> \                        if(nh_stuff[i] &lt; nh_start)\n\
<a name="line-2787"></a> \                                nh_start = nh_stuff[i];\n\
<a name="line-2788"></a> \                        if(nh_stuff[i] &gt; nh_end)\n\
<a name="line-2789"></a> \                                nh_end = nh_stuff[i];\n\
<a name="line-2790"></a> \                }\n\
<a name="line-2791"></a> \        }\n\
<a name="line-2792"></a> \}\n\
<a name="line-2793"></a> \\n\
<a name="line-2794"></a> \void\n\
<a name="line-2795"></a> \jhc_alloc_fini(void) {\n\
<a name="line-2796"></a> \        if(_JHC_PROFILE || JHC_STATUS) {\n\
<a name="line-2797"></a> \                fprintf(stderr, \"arena: %p\\n\", saved_arena);\n\
<a name="line-2798"></a> \                fprintf(stderr, \"  block_used: %i\\n\", saved_arena-&gt;block_used);\n\
<a name="line-2799"></a> \                fprintf(stderr, \"  block_threshold: %i\\n\", saved_arena-&gt;block_threshold);\n\
<a name="line-2800"></a> \                struct s_cache *sc;\n\
<a name="line-2801"></a> \                SLIST_FOREACH(sc,&amp;saved_arena-&gt;caches,next)\n\
<a name="line-2802"></a> \                        print_cache(sc);\n\
<a name="line-2803"></a> \        }\n\
<a name="line-2804"></a> \}\n\
<a name="line-2805"></a> \\n\
<a name="line-2806"></a> \heap_t A_STD\n\
<a name="line-2807"></a> \(gc_alloc)(gc_t gc, arena_t arena, struct s_cache **sc, unsigned count, unsigned nptrs)\n\
<a name="line-2808"></a> \{\n\
<a name="line-2809"></a> \        assert(nptrs &lt;= count);\n\
<a name="line-2810"></a> \        entry_t *e = s_alloc(gc, arena, find_cache(sc, saved_arena, count, nptrs));\n\
<a name="line-2811"></a> \        VALGRIND_MAKE_MEM_UNDEFINED(e,sizeof(uintptr_t)*count);\n\
<a name="line-2812"></a> \        debugf(\"gc_alloc: %p %i %i\\n\",(void *)e, count, nptrs);\n\
<a name="line-2813"></a> \        return (void *)e;\n\
<a name="line-2814"></a> \}\n\
<a name="line-2815"></a> \\n\
<a name="line-2816"></a> \static heap_t A_STD\n\
<a name="line-2817"></a> \s_monoblock(arena_t arena, unsigned size, unsigned nptrs, unsigned flags) {\n\
<a name="line-2818"></a> \        struct s_block *b = jhc_aligned_alloc(size * sizeof(uintptr_t));\n\
<a name="line-2819"></a> \        b-&gt;flags = flags | SLAB_MONOLITH;\n\
<a name="line-2820"></a> \        b-&gt;color = (sizeof(struct s_block) + BITARRAY_SIZE_IN_BYTES(1) +\n\
<a name="line-2821"></a> \                    sizeof(uintptr_t) - 1) / sizeof(uintptr_t);\n\
<a name="line-2822"></a> \        b-&gt;u.m.num_ptrs = nptrs;\n\
<a name="line-2823"></a> \        SLIST_INSERT_HEAD(&amp;arena-&gt;monolithic_blocks, b, link);\n\
<a name="line-2824"></a> \        b-&gt;used[0] = 1;\n\
<a name="line-2825"></a> \        return (void *)b + b-&gt;color*sizeof(uintptr_t);\n\
<a name="line-2826"></a> \}\n\
<a name="line-2827"></a> \\n\
<a name="line-2828"></a> \// Allocate an array of count garbage collectable locations in the garbage\n\
<a name="line-2829"></a> \// collected heap.\n\
<a name="line-2830"></a> \heap_t A_STD\n\
<a name="line-2831"></a> \gc_array_alloc(gc_t gc, arena_t arena, unsigned count)\n\
<a name="line-2832"></a> \{\n\
<a name="line-2833"></a> \        if (!count)\n\
<a name="line-2834"></a> \               return NULL;\n\
<a name="line-2835"></a> \        if (count &lt;= GC_STATIC_ARRAY_NUM)\n\
<a name="line-2836"></a> \                return (wptr_t)s_alloc(gc, arena,array_caches[count - 1]);\n\
<a name="line-2837"></a> \        if (count &lt; GC_MAX_BLOCK_ENTRIES)\n\
<a name="line-2838"></a> \                return s_alloc(gc, arena, find_cache(NULL, saved_arena, count, count));\n\
<a name="line-2839"></a> \        return s_monoblock(saved_arena, count, count, 0);\n\
<a name="line-2840"></a> \        abort();\n\
<a name="line-2841"></a> \}\n\
<a name="line-2842"></a> \\n\
<a name="line-2843"></a> \// Allocate an array of count non-garbage collectable locations in the garbage\n\
<a name="line-2844"></a> \// collected heap.\n\
<a name="line-2845"></a> \heap_t A_STD\n\
<a name="line-2846"></a> \gc_array_alloc_atomic(gc_t gc, arena_t arena, unsigned count, unsigned flags)\n\
<a name="line-2847"></a> \{\n\
<a name="line-2848"></a> \        if (!count)\n\
<a name="line-2849"></a> \               return NULL;\n\
<a name="line-2850"></a> \        if (count &lt;= GC_STATIC_ARRAY_NUM &amp;&amp; !flags)\n\
<a name="line-2851"></a> \                return (wptr_t)s_alloc(gc, arena, array_caches_atomic[count - 1]);\n\
<a name="line-2852"></a> \        if (count &lt; GC_MAX_BLOCK_ENTRIES &amp;&amp; !flags)\n\
<a name="line-2853"></a> \                return s_alloc(gc, arena, find_cache(NULL, saved_arena, count, 0));\n\
<a name="line-2854"></a> \        return s_monoblock(saved_arena, count, count, flags);\n\
<a name="line-2855"></a> \        abort();\n\
<a name="line-2856"></a> \}\n\
<a name="line-2857"></a> \\n\
<a name="line-2858"></a> \/* This finds a bit that isn't set, sets it, then returns its index.  It\n\
<a name="line-2859"></a> \ * assumes that a bit is available to be found, otherwise it goes into an\n\
<a name="line-2860"></a> \ * infinite loop. */\n\
<a name="line-2861"></a> \\n\
<a name="line-2862"></a> \static unsigned\n\
<a name="line-2863"></a> \bitset_find_free(unsigned *next_free,int n,bitarray_t ba[static n]) {\n\
<a name="line-2864"></a> \        assert(*next_free &lt; (unsigned)n);\n\
<a name="line-2865"></a> \        unsigned i = *next_free;\n\
<a name="line-2866"></a> \        do {\n\
<a name="line-2867"></a> \                int o = __builtin_ffsl(~ba[i]);\n\
<a name="line-2868"></a> \                if(__predict_true(o)) {\n\
<a name="line-2869"></a> \                        ba[i] |= (1UL &lt;&lt; (o - 1));\n\
<a name="line-2870"></a> \                        *next_free = i;\n\
<a name="line-2871"></a> \                        return (i*BITS_PER_UNIT + (o - 1));\n\
<a name="line-2872"></a> \                }\n\
<a name="line-2873"></a> \                i = (i + 1) % n;\n\
<a name="line-2874"></a> \                assert(i != *next_free);\n\
<a name="line-2875"></a> \        } while (1);\n\
<a name="line-2876"></a> \}\n\
<a name="line-2877"></a> \\n\
<a name="line-2878"></a> \static void *\n\
<a name="line-2879"></a> \jhc_aligned_alloc(unsigned size) {\n\
<a name="line-2880"></a> \        void *base;\n\
<a name="line-2881"></a> \#if defined(__WIN32__)\n\
<a name="line-2882"></a> \        base = _aligned_malloc(MEGABLOCK_SIZE, BLOCK_SIZE);\n\
<a name="line-2883"></a> \        int ret = !base;\n\
<a name="line-2884"></a> \#elif defined(__ARM_EABI__)\n\
<a name="line-2885"></a> \        base = memalign(BLOCK_SIZE, MEGABLOCK_SIZE);\n\
<a name="line-2886"></a> \        int ret = !base;\n\
<a name="line-2887"></a> \#elif (defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) &amp;&amp; __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ &lt;  1060)\n\
<a name="line-2888"></a> \        assert(sysconf(_SC_PAGESIZE) == BLOCK_SIZE);\n\
<a name="line-2889"></a> \        base = valloc(MEGABLOCK_SIZE);\n\
<a name="line-2890"></a> \        int ret = !base;\n\
<a name="line-2891"></a> \#else\n\
<a name="line-2892"></a> \        int ret = posix_memalign(&amp;base,BLOCK_SIZE,MEGABLOCK_SIZE);\n\
<a name="line-2893"></a> \#endif\n\
<a name="line-2894"></a> \        if(ret != 0) {\n\
<a name="line-2895"></a> \                fprintf(stderr,\"Unable to allocate memory for aligned alloc: %u\\n\", size);\n\
<a name="line-2896"></a> \                abort();\n\
<a name="line-2897"></a> \        }\n\
<a name="line-2898"></a> \        return base;\n\
<a name="line-2899"></a> \}\n\
<a name="line-2900"></a> \\n\
<a name="line-2901"></a> \struct s_megablock *\n\
<a name="line-2902"></a> \s_new_megablock(arena_t arena)\n\
<a name="line-2903"></a> \{\n\
<a name="line-2904"></a> \        struct s_megablock *mb = malloc(sizeof(*mb));\n\
<a name="line-2905"></a> \#ifdef _JHC_JGC_FIXED_MEGABLOCK\n\
<a name="line-2906"></a> \        static int count = 0;\n\
<a name="line-2907"></a> \        if (count != 0) {\n\
<a name="line-2908"></a> \                abort();\n\
<a name="line-2909"></a> \        }\n\
<a name="line-2910"></a> \        count++;\n\
<a name="line-2911"></a> \        mb-&gt;base = aligned_megablock_1;\n\
<a name="line-2912"></a> \#else\n\
<a name="line-2913"></a> \        mb-&gt;base = jhc_aligned_alloc(MEGABLOCK_SIZE);\n\
<a name="line-2914"></a> \#endif\n\
<a name="line-2915"></a> \        VALGRIND_MAKE_MEM_NOACCESS(mb-&gt;base,MEGABLOCK_SIZE);\n\
<a name="line-2916"></a> \        mb-&gt;next_free = 0;\n\
<a name="line-2917"></a> \        return mb;\n\
<a name="line-2918"></a> \}\n\
<a name="line-2919"></a> \\n\
<a name="line-2920"></a> \/* block allocator */\n\
<a name="line-2921"></a> \\n\
<a name="line-2922"></a> \static struct s_block *\n\
<a name="line-2923"></a> \get_free_block(gc_t gc, arena_t arena, bool retry) {\n\
<a name="line-2924"></a> \        arena-&gt;block_used++;\n\
<a name="line-2925"></a> \        if(__predict_true(SLIST_FIRST(&amp;arena-&gt;free_blocks))) {\n\
<a name="line-2926"></a> \                struct s_block *pg = SLIST_FIRST(&amp;arena-&gt;free_blocks);\n\
<a name="line-2927"></a> \                SLIST_REMOVE_HEAD(&amp;arena-&gt;free_blocks,link);\n\
<a name="line-2928"></a> \                return pg;\n\
<a name="line-2929"></a> \        } else {\n\
<a name="line-2930"></a> \#ifdef _JHC_JGC_NAIVEGC\n\
<a name="line-2931"></a> \                if(retry == false) {\n\
<a name="line-2932"></a> \                        gc_perform_gc(gc, arena);\n\
<a name="line-2933"></a> \                        return NULL;\n\
<a name="line-2934"></a> \                }\n\
<a name="line-2935"></a> \#else\n\
<a name="line-2936"></a> \                if((arena-&gt;block_used &gt;= arena-&gt;block_threshold)) {\n\
<a name="line-2937"></a> \                        gc_perform_gc(gc, arena);\n\
<a name="line-2938"></a> \                        // if we are still using 80% of the heap after a gc, raise the threshold.\n\
<a name="line-2939"></a> \                        if(__predict_false((unsigned)arena-&gt;block_used * 10 &gt;= arena-&gt;block_threshold * 9)) {\n\
<a name="line-2940"></a> \                                arena-&gt;block_threshold *= 2;\n\
<a name="line-2941"></a> \                        }\n\
<a name="line-2942"></a> \                }\n\
<a name="line-2943"></a> \#endif\n\
<a name="line-2944"></a> \                if(__predict_false(!arena-&gt;current_megablock))\n\
<a name="line-2945"></a> \                        arena-&gt;current_megablock = s_new_megablock(arena);\n\
<a name="line-2946"></a> \                struct s_megablock *mb = arena-&gt;current_megablock;\n\
<a name="line-2947"></a> \                struct s_block *pg = mb-&gt;base + BLOCK_SIZE*mb-&gt;next_free;\n\
<a name="line-2948"></a> \                mb-&gt;next_free++;\n\
<a name="line-2949"></a> \                if(mb-&gt;next_free == MEGABLOCK_SIZE / BLOCK_SIZE) {\n\
<a name="line-2950"></a> \                        SLIST_INSERT_HEAD(&amp;arena-&gt;megablocks,mb, next);\n\
<a name="line-2951"></a> \                        arena-&gt;current_megablock = NULL;\n\
<a name="line-2952"></a> \                }\n\
<a name="line-2953"></a> \                VALGRIND_MAKE_MEM_UNDEFINED(pg,sizeof(struct s_block));\n\
<a name="line-2954"></a> \                pg-&gt;u.pi.num_free = 0;\n\
<a name="line-2955"></a> \                return pg;\n\
<a name="line-2956"></a> \        }\n\
<a name="line-2957"></a> \}\n\
<a name="line-2958"></a> \\n\
<a name="line-2959"></a> \typedef void (*finalizer_ptr)(HsPtr arg);\n\
<a name="line-2960"></a> \typedef void (*finalizer_env_ptr)(HsPtr env, HsPtr arg);\n\
<a name="line-2961"></a> \\n\
<a name="line-2962"></a> \void hs_foreignptr_env_helper(HsPtr env, HsPtr arg) {\n\
<a name="line-2963"></a> \        ((finalizer_ptr)env)(arg);\n\
<a name="line-2964"></a> \}\n\
<a name="line-2965"></a> \\n\
<a name="line-2966"></a> \static void\n\
<a name="line-2967"></a> \s_cleanup_blocks(arena_t arena) {\n\
<a name="line-2968"></a> \        struct s_block *pg = SLIST_FIRST(&amp;arena-&gt;monolithic_blocks);\n\
<a name="line-2969"></a> \        SLIST_INIT(&amp;arena-&gt;monolithic_blocks);\n\
<a name="line-2970"></a> \        while (pg) {\n\
<a name="line-2971"></a> \                if (pg-&gt;used[0]) {\n\
<a name="line-2972"></a> \                        SLIST_INSERT_HEAD(&amp;arena-&gt;monolithic_blocks, pg, link);\n\
<a name="line-2973"></a> \                        pg = SLIST_NEXT(pg,link);\n\
<a name="line-2974"></a> \                } else {\n\
<a name="line-2975"></a> \                        if (pg-&gt;flags &amp; SLAB_FLAG_FINALIZER) {\n\
<a name="line-2976"></a> \                                HsPtr *ptr = (HsPtr *)pg;\n\
<a name="line-2977"></a> \                                if(ptr[pg-&gt;color + 1]) {\n\
<a name="line-2978"></a> \                                        finalizer_ptr *fp = ptr[pg-&gt;color + 1];\n\
<a name="line-2979"></a> \                                        do {\n\
<a name="line-2980"></a> \                                                fp[0](ptr[pg-&gt;color]);\n\
<a name="line-2981"></a> \                                        } while(*++fp);\n\
<a name="line-2982"></a> \                                }\n\
<a name="line-2983"></a> \                        }\n\
<a name="line-2984"></a> \                        void *ptr = pg;\n\
<a name="line-2985"></a> \                        pg = SLIST_NEXT(pg,link);\n\
<a name="line-2986"></a> \                        free(ptr);\n\
<a name="line-2987"></a> \                }\n\
<a name="line-2988"></a> \        }\n\
<a name="line-2989"></a> \        struct s_cache *sc = SLIST_FIRST(&amp;arena-&gt;caches);\n\
<a name="line-2990"></a> \        for(;sc;sc = SLIST_NEXT(sc,next)) {\n\
<a name="line-2991"></a> \                // 'best' keeps track of the block with the fewest free spots\n\
<a name="line-2992"></a> \                // and percolates it to the front, effectively a single pass\n\
<a name="line-2993"></a> \                // of a bubblesort to help combat fragmentation. It does\n\
<a name="line-2994"></a> \                // not increase the complexity of the cleanup algorithm as\n\
<a name="line-2995"></a> \                // we had to scan every block anyway, but over many passes\n\
<a name="line-2996"></a> \                // of the GC it will eventually result in a more sorted list\n\
<a name="line-2997"></a> \                // than would occur by chance.\n\
<a name="line-2998"></a> \\n\
<a name="line-2999"></a> \                struct s_block *best = NULL;\n\
<a name="line-3000"></a> \                int free_best = 4096;\n\
<a name="line-3001"></a> \                pg = SLIST_FIRST(&amp;sc-&gt;blocks);\n\
<a name="line-3002"></a> \                struct s_block *fpg = SLIST_FIRST(&amp;sc-&gt;full_blocks);\n\
<a name="line-3003"></a> \                SLIST_INIT(&amp;sc-&gt;blocks);\n\
<a name="line-3004"></a> \                SLIST_INIT(&amp;sc-&gt;full_blocks);\n\
<a name="line-3005"></a> \                if(!pg) {\n\
<a name="line-3006"></a> \                        pg = fpg;\n\
<a name="line-3007"></a> \                        fpg = NULL;\n\
<a name="line-3008"></a> \                }\n\
<a name="line-3009"></a> \                while(pg) {\n\
<a name="line-3010"></a> \                        struct s_block *npg = SLIST_NEXT(pg,link);\n\
<a name="line-3011"></a> \                        if(__predict_false(pg-&gt;u.pi.num_free == 0)) {\n\
<a name="line-3012"></a> \                                // Add full blockes to the cache's full block list.\n\
<a name="line-3013"></a> \                                SLIST_INSERT_HEAD(&amp;sc-&gt;full_blocks,pg,link);\n\
<a name="line-3014"></a> \                        } else if(__predict_true(pg-&gt;u.pi.num_free == sc-&gt;num_entries)) {\n\
<a name="line-3015"></a> \                                // Return completely free block to arena free block list.\n\
<a name="line-3016"></a> \                                arena-&gt;block_used--;\n\
<a name="line-3017"></a> \                                VALGRIND_MAKE_MEM_NOACCESS((char *)pg + sizeof(struct s_block),\n\
<a name="line-3018"></a> \                                                           BLOCK_SIZE - sizeof(struct s_block));\n\
<a name="line-3019"></a> \                                SLIST_INSERT_HEAD(&amp;arena-&gt;free_blocks,pg,link);\n\
<a name="line-3020"></a> \                        } else {\n\
<a name="line-3021"></a> \                                if(!best) {\n\
<a name="line-3022"></a> \                                        free_best = pg-&gt;u.pi.num_free;\n\
<a name="line-3023"></a> \                                        best = pg;\n\
<a name="line-3024"></a> \                                } else {\n\
<a name="line-3025"></a> \                                        if(pg-&gt;u.pi.num_free &lt; free_best) {\n\
<a name="line-3026"></a> \                                                struct s_block *tmp = best;\n\
<a name="line-3027"></a> \                                                best = pg; pg = tmp;\n\
<a name="line-3028"></a> \                                                free_best = pg-&gt;u.pi.num_free;\n\
<a name="line-3029"></a> \                                        }\n\
<a name="line-3030"></a> \                                        SLIST_INSERT_HEAD(&amp;sc-&gt;blocks,pg,link);\n\
<a name="line-3031"></a> \                                }\n\
<a name="line-3032"></a> \                        }\n\
<a name="line-3033"></a> \                        if(!npg &amp;&amp; fpg) {\n\
<a name="line-3034"></a> \                                pg = fpg;\n\
<a name="line-3035"></a> \                                fpg = NULL;\n\
<a name="line-3036"></a> \                        } else\n\
<a name="line-3037"></a> \                                pg = npg;\n\
<a name="line-3038"></a> \                }\n\
<a name="line-3039"></a> \                if(best)\n\
<a name="line-3040"></a> \                        SLIST_INSERT_HEAD(&amp;sc-&gt;blocks,best,link);\n\
<a name="line-3041"></a> \        }\n\
<a name="line-3042"></a> \}\n\
<a name="line-3043"></a> \\n\
<a name="line-3044"></a> \inline static void\n\
<a name="line-3045"></a> \clear_block_used_bits(unsigned num_entries, struct s_block *pg)\n\
<a name="line-3046"></a> \{\n\
<a name="line-3047"></a> \        pg-&gt;u.pi.num_free = num_entries;\n\
<a name="line-3048"></a> \        memset(pg-&gt;used,0,BITARRAY_SIZE_IN_BYTES(num_entries) - sizeof(pg-&gt;used[0]));\n\
<a name="line-3049"></a> \        int excess = num_entries % BITS_PER_UNIT;\n\
<a name="line-3050"></a> \        pg-&gt;used[BITARRAY_SIZE(num_entries) - 1] = ~((1UL &lt;&lt; excess) - 1);\n\
<a name="line-3051"></a> \#if JHC_VALGRIND\n\
<a name="line-3052"></a> \                unsigned header =  sizeof(struct s_block) + BITARRAY_SIZE_IN_BYTES(num_entries);\n\
<a name="line-3053"></a> \                VALGRIND_MAKE_MEM_NOACCESS((char *)pg + header, BLOCK_SIZE - header);\n\
<a name="line-3054"></a> \#endif\n\
<a name="line-3055"></a> \}\n\
<a name="line-3056"></a> \\n\
<a name="line-3057"></a> \/*\n\
<a name="line-3058"></a> \ * allocators\n\
<a name="line-3059"></a> \ */\n\
<a name="line-3060"></a> \\n\
<a name="line-3061"></a> \heap_t A_STD\n\
<a name="line-3062"></a> \s_alloc(gc_t gc, arena_t arena, struct s_cache *sc)\n\
<a name="line-3063"></a> \{\n\
<a name="line-3064"></a> \#if _JHC_PROFILE\n\
<a name="line-3065"></a> \       sc-&gt;allocations++;\n\
<a name="line-3066"></a> \       sc-&gt;arena-&gt;number_allocs++;\n\
<a name="line-3067"></a> \#endif\n\
<a name="line-3068"></a> \        bool retry = false;\n\
<a name="line-3069"></a> \        struct s_block *pg;\n\
<a name="line-3070"></a> \retry_s_alloc:\n\
<a name="line-3071"></a> \        pg = SLIST_FIRST(&amp;sc-&gt;blocks);\n\
<a name="line-3072"></a> \        if(__predict_false(!pg)) {\n\
<a name="line-3073"></a> \                pg = get_free_block(gc, sc-&gt;arena, retry);\n\
<a name="line-3074"></a> \                if(__predict_false(!pg)) {\n\
<a name="line-3075"></a> \                        retry = true;\n\
<a name="line-3076"></a> \                        goto retry_s_alloc;\n\
<a name="line-3077"></a> \                }\n\
<a name="line-3078"></a> \                VALGRIND_MAKE_MEM_NOACCESS(pg, BLOCK_SIZE);\n\
<a name="line-3079"></a> \                VALGRIND_MAKE_MEM_DEFINED(pg, sizeof(struct s_block));\n\
<a name="line-3080"></a> \                if(sc-&gt;num_entries != pg-&gt;u.pi.num_free)\n\
<a name="line-3081"></a> \                        VALGRIND_MAKE_MEM_UNDEFINED((char *)pg-&gt;used,\n\
<a name="line-3082"></a> \                                                    BITARRAY_SIZE_IN_BYTES(sc-&gt;num_entries));\n\
<a name="line-3083"></a> \                else\n\
<a name="line-3084"></a> \                        VALGRIND_MAKE_MEM_DEFINED((char *)pg-&gt;used,\n\
<a name="line-3085"></a> \                                                  BITARRAY_SIZE_IN_BYTES(sc-&gt;num_entries));\n\
<a name="line-3086"></a> \                assert(pg);\n\
<a name="line-3087"></a> \                pg-&gt;flags = sc-&gt;flags;\n\
<a name="line-3088"></a> \                pg-&gt;color = sc-&gt;color;\n\
<a name="line-3089"></a> \                pg-&gt;u.pi.num_ptrs = sc-&gt;num_ptrs;\n\
<a name="line-3090"></a> \                pg-&gt;u.pi.size = sc-&gt;size;\n\
<a name="line-3091"></a> \                pg-&gt;u.pi.next_free = 0;\n\
<a name="line-3092"></a> \                SLIST_INSERT_HEAD(&amp;sc-&gt;blocks,pg,link);\n\
<a name="line-3093"></a> \                if(sc-&gt;num_entries != pg-&gt;u.pi.num_free)\n\
<a name="line-3094"></a> \                        clear_block_used_bits(sc-&gt;num_entries, pg);\n\
<a name="line-3095"></a> \                pg-&gt;used[0] = 1; //set the first bit\n\
<a name="line-3096"></a> \                pg-&gt;u.pi.num_free = sc-&gt;num_entries - 1;\n\
<a name="line-3097"></a> \                return (uintptr_t *)pg + pg-&gt;color;\n\
<a name="line-3098"></a> \        } else {\n\
<a name="line-3099"></a> \                __builtin_prefetch(pg-&gt;used,1);\n\
<a name="line-3100"></a> \                pg-&gt;u.pi.num_free--;\n\
<a name="line-3101"></a> \                unsigned next_free = pg-&gt;u.pi.next_free;\n\
<a name="line-3102"></a> \                unsigned found = bitset_find_free(&amp;next_free,BITARRAY_SIZE(sc-&gt;num_entries),pg-&gt;used);\n\
<a name="line-3103"></a> \                pg-&gt;u.pi.next_free = next_free;\n\
<a name="line-3104"></a> \                void *val = (uintptr_t *)pg + pg-&gt;color + found*pg-&gt;u.pi.size;\n\
<a name="line-3105"></a> \                if(__predict_false(0 == pg-&gt;u.pi.num_free)) {\n\
<a name="line-3106"></a> \                        assert(pg == SLIST_FIRST(&amp;sc-&gt;blocks));\n\
<a name="line-3107"></a> \                        SLIST_REMOVE_HEAD(&amp;sc-&gt;blocks,link);\n\
<a name="line-3108"></a> \                        SLIST_INSERT_HEAD(&amp;sc-&gt;full_blocks,pg,link);\n\
<a name="line-3109"></a> \                }\n\
<a name="line-3110"></a> \                assert(S_BLOCK(val) == pg);\n\
<a name="line-3111"></a> \                //printf(\"s_alloc: val: %p s_block: %p size: %i color: %i found: %i num_free: %i\\n\", val, pg, pg-&gt;pi.size, pg-&gt;pi.color, found, pg-&gt;num_free);\n\
<a name="line-3112"></a> \                return val;\n\
<a name="line-3113"></a> \        }\n\
<a name="line-3114"></a> \}\n\
<a name="line-3115"></a> \\n\
<a name="line-3116"></a> \struct s_cache *\n\
<a name="line-3117"></a> \new_cache(arena_t arena, unsigned short size, unsigned short num_ptrs)\n\
<a name="line-3118"></a> \{\n\
<a name="line-3119"></a> \        struct s_cache *sc = malloc(sizeof(*sc));\n\
<a name="line-3120"></a> \        memset(sc,0,sizeof(*sc));\n\
<a name="line-3121"></a> \        sc-&gt;arena = arena;\n\
<a name="line-3122"></a> \        sc-&gt;size = size;\n\
<a name="line-3123"></a> \        sc-&gt;num_ptrs = num_ptrs;\n\
<a name="line-3124"></a> \        sc-&gt;flags = 0;\n\
<a name="line-3125"></a> \        size_t excess = BLOCK_SIZE - sizeof(struct s_block);\n\
<a name="line-3126"></a> \        sc-&gt;num_entries = (8*excess) / (8*sizeof(uintptr_t)*size + 1) - 1;\n\
<a name="line-3127"></a> \        sc-&gt;color = (sizeof(struct s_block) + BITARRAY_SIZE_IN_BYTES(sc-&gt;num_entries) +\n\
<a name="line-3128"></a> \                        sizeof(uintptr_t) - 1) / sizeof(uintptr_t);\n\
<a name="line-3129"></a> \        SLIST_INIT(&amp;sc-&gt;blocks);\n\
<a name="line-3130"></a> \        SLIST_INIT(&amp;sc-&gt;full_blocks);\n\
<a name="line-3131"></a> \        SLIST_INSERT_HEAD(&amp;arena-&gt;caches,sc,next);\n\
<a name="line-3132"></a> \        return sc;\n\
<a name="line-3133"></a> \}\n\
<a name="line-3134"></a> \\n\
<a name="line-3135"></a> \// clear all used bits, must be followed by a marking phase.\n\
<a name="line-3136"></a> \static void\n\
<a name="line-3137"></a> \clear_used_bits(arena_t arena)\n\
<a name="line-3138"></a> \{\n\
<a name="line-3139"></a> \        struct s_block *pg;\n\
<a name="line-3140"></a> \        SLIST_FOREACH(pg, &amp;arena-&gt;monolithic_blocks, link)\n\
<a name="line-3141"></a> \            pg-&gt;used[0] = 0;\n\
<a name="line-3142"></a> \        struct s_cache *sc = SLIST_FIRST(&amp;arena-&gt;caches);\n\
<a name="line-3143"></a> \        for(;sc;sc = SLIST_NEXT(sc,next)) {\n\
<a name="line-3144"></a> \                SLIST_FOREACH(pg, &amp;sc-&gt;blocks, link)\n\
<a name="line-3145"></a> \                    clear_block_used_bits(sc-&gt;num_entries,pg);\n\
<a name="line-3146"></a> \                SLIST_FOREACH(pg, &amp;sc-&gt;full_blocks, link)\n\
<a name="line-3147"></a> \                    clear_block_used_bits(sc-&gt;num_entries,pg);\n\
<a name="line-3148"></a> \        }\n\
<a name="line-3149"></a> \}\n\
<a name="line-3150"></a> \\n\
<a name="line-3151"></a> \// Set a used bit. returns true if the tagged node should be scanned by the GC.\n\
<a name="line-3152"></a> \// this happens when the used bit was not previously set and the node contains\n\
<a name="line-3153"></a> \// internal pointers.\n\
<a name="line-3154"></a> \\n\
<a name="line-3155"></a> \static bool\n\
<a name="line-3156"></a> \s_set_used_bit(void *val)\n\
<a name="line-3157"></a> \{\n\
<a name="line-3158"></a> \        assert(val);\n\
<a name="line-3159"></a> \        struct s_block *pg = S_BLOCK(val);\n\
<a name="line-3160"></a> \        unsigned int offset = ((uintptr_t *)val - (uintptr_t *)pg) - pg-&gt;color;\n\
<a name="line-3161"></a> \        if(__predict_true(BIT_IS_UNSET(pg-&gt;used,offset/pg-&gt;u.pi.size))) {\n\
<a name="line-3162"></a> \                if (pg-&gt;flags &amp; SLAB_MONOLITH) {\n\
<a name="line-3163"></a> \                        pg-&gt;used[0] = 1;\n\
<a name="line-3164"></a> \                        return (bool)pg-&gt;u.m.num_ptrs;\n\
<a name="line-3165"></a> \\n\
<a name="line-3166"></a> \                } else {\n\
<a name="line-3167"></a> \                        BIT_SET(pg-&gt;used,offset/pg-&gt;u.pi.size);\n\
<a name="line-3168"></a> \                        pg-&gt;u.pi.num_free--;\n\
<a name="line-3169"></a> \                        return (bool)pg-&gt;u.pi.num_ptrs;\n\
<a name="line-3170"></a> \                }\n\
<a name="line-3171"></a> \        }\n\
<a name="line-3172"></a> \        return false;\n\
<a name="line-3173"></a> \}\n\
<a name="line-3174"></a> \\n\
<a name="line-3175"></a> \struct s_cache *\n\
<a name="line-3176"></a> \find_cache(struct s_cache **rsc, arena_t arena,\n\
<a name="line-3177"></a> \           unsigned short size, unsigned short num_ptrs)\n\
<a name="line-3178"></a> \{\n\
<a name="line-3179"></a> \        if(__predict_true(rsc &amp;&amp; *rsc))\n\
<a name="line-3180"></a> \                return *rsc;\n\
<a name="line-3181"></a> \        struct s_cache *sc = SLIST_FIRST(&amp;arena-&gt;caches);\n\
<a name="line-3182"></a> \        for(;sc;sc = SLIST_NEXT(sc,next)) {\n\
<a name="line-3183"></a> \                if(sc-&gt;size == size &amp;&amp; sc-&gt;num_ptrs == num_ptrs)\n\
<a name="line-3184"></a> \                        goto found;\n\
<a name="line-3185"></a> \        }\n\
<a name="line-3186"></a> \        sc = new_cache(arena,size,num_ptrs);\n\
<a name="line-3187"></a> \found:\n\
<a name="line-3188"></a> \        if(rsc)\n\
<a name="line-3189"></a> \                *rsc = sc;\n\
<a name="line-3190"></a> \        return sc;\n\
<a name="line-3191"></a> \}\n\
<a name="line-3192"></a> \\n\
<a name="line-3193"></a> \arena_t\n\
<a name="line-3194"></a> \new_arena(void) {\n\
<a name="line-3195"></a> \        arena_t arena = malloc(sizeof(struct s_arena));\n\
<a name="line-3196"></a> \        SLIST_INIT(&amp;arena-&gt;caches);\n\
<a name="line-3197"></a> \        SLIST_INIT(&amp;arena-&gt;free_blocks);\n\
<a name="line-3198"></a> \        SLIST_INIT(&amp;arena-&gt;megablocks);\n\
<a name="line-3199"></a> \        SLIST_INIT(&amp;arena-&gt;monolithic_blocks);\n\
<a name="line-3200"></a> \        arena-&gt;block_used = 0;\n\
<a name="line-3201"></a> \        arena-&gt;block_threshold = 8;\n\
<a name="line-3202"></a> \        arena-&gt;current_megablock = NULL;\n\
<a name="line-3203"></a> \\n\
<a name="line-3204"></a> \        for (int i = 0; i &lt; GC_STATIC_ARRAY_NUM; i++) {\n\
<a name="line-3205"></a> \                find_cache(&amp;array_caches[i], arena, i + 1, i + 1);\n\
<a name="line-3206"></a> \                find_cache(&amp;array_caches_atomic[i], arena, i + 1, 0);\n\
<a name="line-3207"></a> \        }\n\
<a name="line-3208"></a> \        return arena;\n\
<a name="line-3209"></a> \}\n\
<a name="line-3210"></a> \\n\
<a name="line-3211"></a> \uint32_t\n\
<a name="line-3212"></a> \get_heap_flags(void * sp) {\n\
<a name="line-3213"></a> \        uint32_t ret = 0;\n\
<a name="line-3214"></a> \        switch (GET_PTYPE(sp)) {\n\
<a name="line-3215"></a> \        case P_VALUE: return SLAB_VIRTUAL_VALUE;\n\
<a name="line-3216"></a> \        case P_FUNC: return SLAB_VIRTUAL_FUNC;\n\
<a name="line-3217"></a> \        case P_LAZY:\n\
<a name="line-3218"></a> \                     ret |= SLAB_VIRTUAL_LAZY;\n\
<a name="line-3219"></a> \        case P_WHNF:\n\
<a name="line-3220"></a> \                     if (S_BLOCK(sp) == NULL)\n\
<a name="line-3221"></a> \                             return (ret | SLAB_VIRTUAL_SPECIAL);\n\
<a name="line-3222"></a> \                     if ((void *)sp &gt;= nh_start &amp;&amp; (void *)sp &lt;= nh_end)\n\
<a name="line-3223"></a> \                             return (ret | SLAB_VIRTUAL_CONSTANT);\n\
<a name="line-3224"></a> \                     return ret |= S_BLOCK(sp)-&gt;flags;\n\
<a name="line-3225"></a> \        }\n\
<a name="line-3226"></a> \        return ret;\n\
<a name="line-3227"></a> \}\n\
<a name="line-3228"></a> \\n\
<a name="line-3229"></a> \heap_t A_STD\n\
<a name="line-3230"></a> \gc_malloc_foreignptr(unsigned alignment, unsigned size, bool finalizer) {\n\
<a name="line-3231"></a> \        // we don't allow higher alignments yet.\n\
<a name="line-3232"></a> \        assert (alignment &lt;= sizeof(uintptr_t));\n\
<a name="line-3233"></a> \        // no finalizers yet\n\
<a name="line-3234"></a> \        assert (!finalizer);\n\
<a name="line-3235"></a> \        unsigned spacing = 1 + finalizer;\n\
<a name="line-3236"></a> \        wptr_t *res = gc_array_alloc_atomic(saved_gc, saved_arena, spacing + TO_BLOCKS(size),\n\
<a name="line-3237"></a> \                                             finalizer ? SLAB_FLAG_FINALIZER : SLAB_FLAG_NONE);\n\
<a name="line-3238"></a> \        res[0] = (wptr_t)(res + spacing);\n\
<a name="line-3239"></a> \        if (finalizer)\n\
<a name="line-3240"></a> \                res[1] = NULL;\n\
<a name="line-3241"></a> \        return TO_SPTR(P_WHNF, res);\n\
<a name="line-3242"></a> \}\n\
<a name="line-3243"></a> \\n\
<a name="line-3244"></a> \heap_t A_STD\n\
<a name="line-3245"></a> \gc_new_foreignptr(HsPtr ptr) {\n\
<a name="line-3246"></a> \        HsPtr *res = gc_array_alloc_atomic(saved_gc, saved_arena, 2, SLAB_FLAG_FINALIZER);\n\
<a name="line-3247"></a> \        res[0] = ptr;\n\
<a name="line-3248"></a> \        res[1] = NULL;\n\
<a name="line-3249"></a> \        return TO_SPTR(P_WHNF, res);\n\
<a name="line-3250"></a> \}\n\
<a name="line-3251"></a> \\n\
<a name="line-3252"></a> \bool A_STD\n\
<a name="line-3253"></a> \gc_add_foreignptr_finalizer(wptr_t fp, HsFunPtr finalizer) {\n\
<a name="line-3254"></a> \        if (!(SLAB_FLAG_FINALIZER &amp; get_heap_flags(fp)))\n\
<a name="line-3255"></a> \                return false;\n\
<a name="line-3256"></a> \        HsFunPtr **res = (HsFunPtr**)FROM_SPTR(fp);\n\
<a name="line-3257"></a> \        unsigned len = 0;\n\
<a name="line-3258"></a> \        if (res[1])\n\
<a name="line-3259"></a> \                while(res[1][len++]);\n\
<a name="line-3260"></a> \        else\n\
<a name="line-3261"></a> \                len = 1;\n\
<a name="line-3262"></a> \        res[1] = realloc(res[1], (len + 1) * sizeof(HsFunPtr));\n\
<a name="line-3263"></a> \        HsFunPtr *ptrs = res[1];\n\
<a name="line-3264"></a> \        ptrs[len - 1] = finalizer;\n\
<a name="line-3265"></a> \        ptrs[len] = NULL;\n\
<a name="line-3266"></a> \        return true;\n\
<a name="line-3267"></a> \}\n\
<a name="line-3268"></a> \\n\
<a name="line-3269"></a> \void\n\
<a name="line-3270"></a> \print_cache(struct s_cache *sc) {\n\
<a name="line-3271"></a> \        fprintf(stderr, \"num_entries: %i with %lu bytes of header\\n\",\n\
<a name="line-3272"></a> \                (int)sc-&gt;num_entries, sizeof(struct s_block) +\n\
<a name="line-3273"></a> \                BITARRAY_SIZE_IN_BYTES(sc-&gt;num_entries));\n\
<a name="line-3274"></a> \        fprintf(stderr, \"  size: %i words %i ptrs\\n\",\n\
<a name="line-3275"></a> \                (int)sc-&gt;size,(int)sc-&gt;num_ptrs);\n\
<a name="line-3276"></a> \#if _JHC_PROFILE\n\
<a name="line-3277"></a> \        fprintf(stderr, \"  allocations: %lu\\n\", (unsigned long)sc-&gt;allocations);\n\
<a name="line-3278"></a> \#endif\n\
<a name="line-3279"></a> \        if(SLIST_EMPTY(&amp;sc-&gt;blocks) &amp;&amp; SLIST_EMPTY(&amp;sc-&gt;full_blocks))\n\
<a name="line-3280"></a> \                return;\n\
<a name="line-3281"></a> \        fprintf(stderr, \"  blocks:\\n\");\n\
<a name="line-3282"></a> \        fprintf(stderr, \"%20s %9s %9s %s\\n\", \"block\", \"num_free\", \"next_free\", \"status\");\n\
<a name="line-3283"></a> \        struct s_block *pg;\n\
<a name="line-3284"></a> \        SLIST_FOREACH(pg,&amp;sc-&gt;blocks,link)\n\
<a name="line-3285"></a> \            fprintf(stderr, \"%20p %9i %9i %c\\n\", pg, pg-&gt;u.pi.num_free, pg-&gt;u.pi.next_free, 'P');\n\
<a name="line-3286"></a> \        SLIST_FOREACH(pg,&amp;sc-&gt;full_blocks,link)\n\
<a name="line-3287"></a> \            fprintf(stderr, \"%20p %9i %9i %c\\n\", pg, pg-&gt;u.pi.num_free, pg-&gt;u.pi.next_free, 'F');\n\
<a name="line-3288"></a> \}\n\
<a name="line-3289"></a> \\n\
<a name="line-3290"></a> \void hs_perform_gc(void) {\n\
<a name="line-3291"></a> \        gc_perform_gc(saved_gc, saved_arena);\n\
<a name="line-3292"></a> \}\n\
<a name="line-3293"></a> \\n\
<a name="line-3294"></a> \#endif\n\
<a name="line-3295"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-3296"></a>
<a name="line-3297"></a><a name="gc_jgc_h"></a><span class='hs-comment'>-- | Generated from rts\/rts\/gc_jgc.h</span>
<a name="line-3298"></a><span class='hs-comment'>{-# NOINLINE gc_jgc_h #-}</span>
<a name="line-3299"></a><span class='hs-definition'>gc_jgc_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-3300"></a><span class='hs-definition'>gc_jgc_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-3301"></a> \#ifndef JHC_GC_JGC_H\n\
<a name="line-3302"></a> \#define JHC_GC_JGC_H\n\
<a name="line-3303"></a> \\n\
<a name="line-3304"></a> \#include &lt;stdbool.h&gt;\n\
<a name="line-3305"></a> \#include &lt;stdint.h&gt;\n\
<a name="line-3306"></a> \#include \"sys/queue.h\"\n\
<a name="line-3307"></a> \#include \"HsFFI.h\"\n\
<a name="line-3308"></a> \\n\
<a name="line-3309"></a> \struct sptr;\n\
<a name="line-3310"></a> \struct s_arena;\n\
<a name="line-3311"></a> \struct s_cache;\n\
<a name="line-3312"></a> \typedef struct s_arena *arena_t;\n\
<a name="line-3313"></a> \typedef void* *gc_t;\n\
<a name="line-3314"></a> \typedef void* heap_t;  // a pointer into the GCed heap.\n\
<a name="line-3315"></a> \\n\
<a name="line-3316"></a> \#if defined(_JHC_JGC_BLOCK_SHIFT) &amp;&amp; defined(_JHC_JGC_MEGABLOCK_SHIFT)\n\
<a name="line-3317"></a> \#if (_JHC_JGC_BLOCK_SHIFT) &gt;= (_JHC_JGC_MEGABLOCK_SHIFT)\n\
<a name="line-3318"></a> \#error \"_JHC_JGC_MEGABLOCK_SHIFT should be larger than _JHC_JGC_BLOCK_SHIFT.\"\n\
<a name="line-3319"></a> \#endif\n\
<a name="line-3320"></a> \#elif defined(_JHC_JGC_BLOCK_SHIFT) || defined(_JHC_JGC_MEGABLOCK_SHIFT)\n\
<a name="line-3321"></a> \#error \"Should define both _JHC_JGC_BLOCK_SHIFT and _JHC_JGC_MEGABLOCK_SHIFT.\"\n\
<a name="line-3322"></a> \#else\n\
<a name="line-3323"></a> \#define _JHC_JGC_BLOCK_SHIFT     12\n\
<a name="line-3324"></a> \#define _JHC_JGC_MEGABLOCK_SHIFT 20\n\
<a name="line-3325"></a> \#endif /* defined(_JHC_JGC_BLOCK_SHIFT) &amp;&amp; defined(_JHC_JGC_MEGABLOCK_SHIFT) */\n\
<a name="line-3326"></a> \\n\
<a name="line-3327"></a> \#define BLOCK_SIZE     (1UL &lt;&lt; (_JHC_JGC_BLOCK_SHIFT))\n\
<a name="line-3328"></a> \#define MEGABLOCK_SIZE (1UL &lt;&lt; (_JHC_JGC_MEGABLOCK_SHIFT))\n\
<a name="line-3329"></a> \#define S_BLOCK(val) ((struct s_block *)((uintptr_t)(val) &amp; ~(BLOCK_SIZE - 1)))\n\
<a name="line-3330"></a> \#define TO_BLOCKS(x) (((x) + sizeof(uintptr_t) - 1)/sizeof(uintptr_t))\n\
<a name="line-3331"></a> \\n\
<a name="line-3332"></a> \extern arena_t saved_arena;\n\
<a name="line-3333"></a> \extern gc_t saved_gc;\n\
<a name="line-3334"></a> \\n\
<a name="line-3335"></a> \void print_cache(struct s_cache *sc);\n\
<a name="line-3336"></a> \struct s_cache *new_cache(arena_t arena, unsigned short size,\n\
<a name="line-3337"></a> \                          unsigned short num_ptrs);\n\
<a name="line-3338"></a> \arena_t new_arena(void);\n\
<a name="line-3339"></a> \struct s_cache *find_cache(struct s_cache **rsc, arena_t arena,\n\
<a name="line-3340"></a> \                           unsigned short size, unsigned short num_ptrs);\n\
<a name="line-3341"></a> \void gc_add_root(gc_t gc, arena_t arena, void * root);\n\
<a name="line-3342"></a> \void A_STD gc_perform_gc(gc_t gc, arena_t arena);\n\
<a name="line-3343"></a> \uint32_t get_heap_flags(void* sp);\n\
<a name="line-3344"></a> \\n\
<a name="line-3345"></a> \heap_t s_alloc(gc_t gc, arena_t arena, struct s_cache *sc) A_STD;\n\
<a name="line-3346"></a> \heap_t (gc_alloc)(gc_t gc, arena_t arena,struct s_cache **sc, unsigned count, unsigned nptrs) A_STD;\n\
<a name="line-3347"></a> \heap_t gc_array_alloc(gc_t gc, arena_t arena, unsigned count) A_STD;\n\
<a name="line-3348"></a> \heap_t gc_array_alloc_atomic(gc_t gc, arena_t arena, unsigned count, unsigned slab_flags) A_STD;\n\
<a name="line-3349"></a> \/* foreignptr, saved_gc must be set properly. */\n\
<a name="line-3350"></a> \heap_t gc_malloc_foreignptr(unsigned alignment, unsigned size, bool finalizer) A_STD;\n\
<a name="line-3351"></a> \heap_t gc_new_foreignptr(HsPtr ptr) A_STD;\n\
<a name="line-3352"></a> \bool gc_add_foreignptr_finalizer(struct sptr* fp, HsFunPtr finalizer) A_STD;\n\
<a name="line-3353"></a> \\n\
<a name="line-3354"></a> \#define gc_frame0(gc,n,...) void *ptrs[n] = { __VA_ARGS__ }; \\\n\
<a name="line-3355"></a> \        for(int i = 0; i &lt; n; i++) gc[i] = (sptr_t)ptrs[i]; \\\n\
<a name="line-3356"></a> \        gc_t sgc = gc;  gc_t gc = sgc + n;\n\
<a name="line-3357"></a> \#define gc_frame1(gc,p1) gc[0] = (sptr_t)p1; gc_t sgc = gc;  gc_t gc = sgc + 1;\n\
<a name="line-3358"></a> \#define gc_frame2(gc,p1,p2) gc[0] = (sptr_t)p1; gc[1] = (sptr_t)p2; \\\n\
<a name="line-3359"></a> \                                    gc_t sgc = gc;  gc_t gc = sgc + 2;\n\
<a name="line-3360"></a> \\n\
<a name="line-3361"></a> \struct StablePtr {\n\
<a name="line-3362"></a> \    LIST_ENTRY(StablePtr) link;\n\
<a name="line-3363"></a> \    struct sptr* contents;\n\
<a name="line-3364"></a> \};\n\
<a name="line-3365"></a> \\n\
<a name="line-3366"></a> \extern LIST_HEAD(StablePtr_list, StablePtr) root_StablePtrs;\n\
<a name="line-3367"></a> \\n\
<a name="line-3368"></a> \#endif\n\
<a name="line-3369"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-3370"></a>
<a name="line-3371"></a><a name="profile_c"></a><span class='hs-comment'>-- | Generated from rts\/rts\/profile.c</span>
<a name="line-3372"></a><span class='hs-comment'>{-# NOINLINE profile_c #-}</span>
<a name="line-3373"></a><span class='hs-definition'>profile_c</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-3374"></a><span class='hs-definition'>profile_c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-3375"></a> \// profiling and debugging code.\n\
<a name="line-3376"></a> \\n\
<a name="line-3377"></a> \#if defined(__WIN32__)\n\
<a name="line-3378"></a> \#define HAVE_TIMES 0\n\
<a name="line-3379"></a> \#else\n\
<a name="line-3380"></a> \#define HAVE_TIMES 1\n\
<a name="line-3381"></a> \#endif\n\
<a name="line-3382"></a> \\n\
<a name="line-3383"></a> \#include &lt;stdio.h&gt;\n\
<a name="line-3384"></a> \#include &lt;stdlib.h&gt;\n\
<a name="line-3385"></a> \#if HAVE_TIMES\n\
<a name="line-3386"></a> \#include &lt;sys/times.h&gt;\n\
<a name="line-3387"></a> \#include &lt;time.h&gt;\n\
<a name="line-3388"></a> \#endif\n\
<a name="line-3389"></a> \#include &lt;unistd.h&gt;\n\
<a name="line-3390"></a> \\n\
<a name="line-3391"></a> \#include \"jhc_rts_header.h\"\n\
<a name="line-3392"></a> \\n\
<a name="line-3393"></a> \void A_UNUSED\n\
<a name="line-3394"></a> \profile_print_header(FILE *file, char *value_unit)\n\
<a name="line-3395"></a> \{\n\
<a name="line-3396"></a> \        fprintf(file, \"JOB \\\"%s\", jhc_progname);\n\
<a name="line-3397"></a> \        for(int i = 0; i &lt; jhc_argc; i++)\n\
<a name="line-3398"></a> \                fprintf(file, \" %s\", jhc_argv[i]);\n\
<a name="line-3399"></a> \        fprintf(file, \"\\\"\\n\");\n\
<a name="line-3400"></a> \        fprintf(file, \"DATE \\\"%s\\\"\\n\", ctime(NULL));\n\
<a name="line-3401"></a> \        fprintf(file, \"SAMPLE_UNIT \\\"seconds\\\"\\n\");\n\
<a name="line-3402"></a> \        fprintf(file, \"VALUE_UNIT \\\"%s\\\"\\n\", value_unit ? value_unit : \"bytes\");\n\
<a name="line-3403"></a> \}\n\
<a name="line-3404"></a> \\n\
<a name="line-3405"></a> \#if HAVE_TIMES\n\
<a name="line-3406"></a> \struct profile_stack {\n\
<a name="line-3407"></a> \    struct tms tm_total;\n\
<a name="line-3408"></a> \    struct tms tm_pushed;\n\
<a name="line-3409"></a> \};\n\
<a name="line-3410"></a> \\n\
<a name="line-3411"></a> \struct profile_stack gc_alloc_time;\n\
<a name="line-3412"></a> \struct profile_stack gc_gc_time;\n\
<a name="line-3413"></a> \\n\
<a name="line-3414"></a> \void\n\
<a name="line-3415"></a> \jhc_profile_push(struct profile_stack *ps)\n\
<a name="line-3416"></a> \{\n\
<a name="line-3417"></a> \        times(&amp;ps-&gt;tm_pushed);\n\
<a name="line-3418"></a> \}\n\
<a name="line-3419"></a> \\n\
<a name="line-3420"></a> \void\n\
<a name="line-3421"></a> \jhc_profile_pop(struct profile_stack *ps)\n\
<a name="line-3422"></a> \{\n\
<a name="line-3423"></a> \    struct tms tm;\n\
<a name="line-3424"></a> \    times(&amp;tm);\n\
<a name="line-3425"></a> \    ps-&gt;tm_total.tms_utime += tm.tms_utime - ps-&gt;tm_pushed.tms_utime;\n\
<a name="line-3426"></a> \    ps-&gt;tm_total.tms_stime += tm.tms_stime - ps-&gt;tm_pushed.tms_stime;\n\
<a name="line-3427"></a> \}\n\
<a name="line-3428"></a> \\n\
<a name="line-3429"></a> \void print_times(struct tms *tm) {\n\
<a name="line-3430"></a> \#if  !defined(__WIN32__) &amp;&amp; !defined(__ARM_EABI__)\n\
<a name="line-3431"></a> \    float cpt = (float)sysconf(_SC_CLK_TCK);\n\
<a name="line-3432"></a> \    fprintf(stderr, \"User Time:   %.2fs\\n\", (float)tm-&gt;tms_utime/cpt);\n\
<a name="line-3433"></a> \    fprintf(stderr, \"System Time: %.2fs\\n\", (float)tm-&gt;tms_stime/cpt);\n\
<a name="line-3434"></a> \    fprintf(stderr, \"Total Time:  %.2fs\\n\", (float)(tm-&gt;tms_stime + tm-&gt;tms_utime)/cpt);\n\
<a name="line-3435"></a> \#endif\n\
<a name="line-3436"></a> \    return;\n\
<a name="line-3437"></a> \}\n\
<a name="line-3438"></a> \#else\n\
<a name="line-3439"></a> \\n\
<a name="line-3440"></a> \struct profile_stack;\n\
<a name="line-3441"></a> \void jhc_profile_push(struct profile_stack *ps) {}\n\
<a name="line-3442"></a> \void jhc_profile_pop(struct profile_stack *ps) {}\n\
<a name="line-3443"></a> \\n\
<a name="line-3444"></a> \#endif\n\
<a name="line-3445"></a> \\n\
<a name="line-3446"></a> \void A_COLD\n\
<a name="line-3447"></a> \jhc_print_profile(void) {\n\
<a name="line-3448"></a> \        if(!(_JHC_PROFILE || getenv(\"AJHC_RTS_PROFILE\"))) return;\n\
<a name="line-3449"></a> \        fprintf(stderr, \"\\n-----------------\\n\");\n\
<a name="line-3450"></a> \        fprintf(stderr, \"Profiling: %s\\n\", jhc_progname);\n\
<a name="line-3451"></a> \        fprintf(stderr, \"Command: %s\\n\", jhc_command);\n\
<a name="line-3452"></a> \        fprintf(stderr, \"Complie: %s\\n\", jhc_c_compile);\n\
<a name="line-3453"></a> \        fprintf(stderr, \"Version: %s\\n\\n\", jhc_version);\n\
<a name="line-3454"></a> \#if HAVE_TIMES\n\
<a name="line-3455"></a> \        struct tms tm;\n\
<a name="line-3456"></a> \        times(&amp;tm);\n\
<a name="line-3457"></a> \        print_times(&amp;tm);\n\
<a name="line-3458"></a> \#endif\n\
<a name="line-3459"></a> \#if _JHC_PROFILE\n\
<a name="line-3460"></a> \        print_times(&amp;gc_gc_time.tm_total);\n\
<a name="line-3461"></a> \        print_times(&amp;gc_alloc_time.tm_total);\n\
<a name="line-3462"></a> \#endif\n\
<a name="line-3463"></a> \        fprintf(stderr, \"-----------------\\n\");\n\
<a name="line-3464"></a> \}\n\
<a name="line-3465"></a> \\n\
<a name="line-3466"></a> \#if _JHC_PROFILE &amp;&amp; _JHC_GC != _JHC_GC_JGC\n\
<a name="line-3467"></a> \\n\
<a name="line-3468"></a> \#define BUCKETS 7\n\
<a name="line-3469"></a> \static unsigned alloced[BUCKETS];\n\
<a name="line-3470"></a> \static unsigned alloced_atomic[BUCKETS];\n\
<a name="line-3471"></a> \\n\
<a name="line-3472"></a> \static void\n\
<a name="line-3473"></a> \alloc_count(int n,int atomic)\n\
<a name="line-3474"></a> \{\n\
<a name="line-3475"></a> \        n = n ? ((n - 1)/sizeof(void *)) + 1 : 0;\n\
<a name="line-3476"></a> \        n = n &gt; BUCKETS - 1 ? BUCKETS - 1 : n;\n\
<a name="line-3477"></a> \        (atomic ? alloced_atomic : alloced)[n]++;\n\
<a name="line-3478"></a> \}\n\
<a name="line-3479"></a> \\n\
<a name="line-3480"></a> \static void\n\
<a name="line-3481"></a> \print_alloc_size_stats(void) {\n\
<a name="line-3482"></a> \        char fmt[] = \"%10s %10s %10s %10s %10s\\n\";\n\
<a name="line-3483"></a> \        char fmt2[] = \"%10u %10u %10u %10u %10u\\n\";\n\
<a name="line-3484"></a> \        fprintf(stderr,fmt,\"Size\",\"Normal\",\"Atomic\",\"Total\",\"Accum\");\n\
<a name="line-3485"></a> \        fprintf(stderr,fmt,\"----\",\"------\",\"------\",\"-----\",\"-----\");\n\
<a name="line-3486"></a> \        unsigned accum = 0;\n\
<a name="line-3487"></a> \        for(int i = 0; i &lt; BUCKETS; i++) {\n\
<a name="line-3488"></a> \                accum += alloced[i] + alloced_atomic[i];\n\
<a name="line-3489"></a> \                fprintf(stderr,fmt2,i,alloced[i],alloced_atomic[i],alloced_atomic[i] + alloced[i], accum);\n\
<a name="line-3490"></a> \        }\n\
<a name="line-3491"></a> \}\n\
<a name="line-3492"></a> \#endif\n\
<a name="line-3493"></a> \\n\
<a name="line-3494"></a> \#if JHC_MEM_ANNOTATE &amp;&amp; _JHC_GC == _JHC_GC_JGC\n\
<a name="line-3495"></a> \#include &lt;Judy.h&gt;\n\
<a name="line-3496"></a> \\n\
<a name="line-3497"></a> \static Pvoid_t mem_annotate = NULL;\n\
<a name="line-3498"></a> \\n\
<a name="line-3499"></a> \#define XSTR(x) #x\n\
<a name="line-3500"></a> \#define STR(x) XSTR(x)\n\
<a name="line-3501"></a> \#define gc_alloc(gc,sc,c,nptrs) \\\n\
<a name="line-3502"></a> \    gc_alloc_annot(gc,sc,c,nptrs,(__FILE__ \":\" STR(__LINE__)))\n\
<a name="line-3503"></a> \\n\
<a name="line-3504"></a> \A_UNUSED static void *\n\
<a name="line-3505"></a> \gc_alloc_annot(gc_t gc,struct s_cache **sc, unsigned count, unsigned nptrs, char *str)\n\
<a name="line-3506"></a> \{\n\
<a name="line-3507"></a> \        void *ret = (gc_alloc)(gc,sc,count,nptrs);\n\
<a name="line-3508"></a> \        PWord_t pval;\n\
<a name="line-3509"></a> \        JLI(pval,mem_annotate,(Word_t)ret);\n\
<a name="line-3510"></a> \        *pval = (Word_t)str;\n\
<a name="line-3511"></a> \        return ret;\n\
<a name="line-3512"></a> \}\n\
<a name="line-3513"></a> \\n\
<a name="line-3514"></a> \char *\n\
<a name="line-3515"></a> \gc_lookup(void *ptr)\n\
<a name="line-3516"></a> \{\n\
<a name="line-3517"></a> \        PWord_t pval;\n\
<a name="line-3518"></a> \        JLG(pval,mem_annotate,(Word_t)ptr &amp; ~(Word_t)3);\n\
<a name="line-3519"></a> \        return pval ? (char *)*pval : \"(none)\";\n\
<a name="line-3520"></a> \}\n\
<a name="line-3521"></a> \\n\
<a name="line-3522"></a> \#endif\n\
<a name="line-3523"></a> \\n\
<a name="line-3524"></a> \#if _JHC_DEBUG  &amp;&amp; _JHC_GC == _JHC_GC_JGC\n\
<a name="line-3525"></a> \\n\
<a name="line-3526"></a> \// these ensure the type synonyms are available to the debugger\n\
<a name="line-3527"></a> \uintptr_t _dummy1;\n\
<a name="line-3528"></a> \node_t *_dummy2;\n\
<a name="line-3529"></a> \dnode_t *_dummy3;\n\
<a name="line-3530"></a> \sptr_t *_dummy4;\n\
<a name="line-3531"></a> \fptr_t *_dummy5;\n\
<a name="line-3532"></a> \wptr_t *_dummy6;\n\
<a name="line-3533"></a> \\n\
<a name="line-3534"></a> \bool A_UNUSED\n\
<a name="line-3535"></a> \jhc_valid_whnf(wptr_t s)\n\
<a name="line-3536"></a> \{\n\
<a name="line-3537"></a> \        return ((GET_PTYPE(s) == P_VALUE) || ((GET_PTYPE(s) == P_WHNF) &amp;&amp; jhc_malloc_sanity(s,P_WHNF)));\n\
<a name="line-3538"></a> \}\n\
<a name="line-3539"></a> \\n\
<a name="line-3540"></a> \bool A_UNUSED\n\
<a name="line-3541"></a> \jhc_valid_lazy(sptr_t s)\n\
<a name="line-3542"></a> \{\n\
<a name="line-3543"></a> \        if(jhc_valid_whnf((wptr_t)s))\n\
<a name="line-3544"></a> \                return true;\n\
<a name="line-3545"></a> \        assert(GET_PTYPE(s) == P_LAZY);\n\
<a name="line-3546"></a> \        node_t *ds = (node_t *)FROM_SPTR(s);\n\
<a name="line-3547"></a> \        assert(jhc_malloc_sanity(ds,P_LAZY));\n\
<a name="line-3548"></a> \        if(IS_LAZY(ds-&gt;head)) {\n\
<a name="line-3549"></a> \                if(ds-&gt;head == BLACK_HOLE) return true;\n\
<a name="line-3550"></a> \                assert(GET_PTYPE(ds-&gt;head) == P_FUNC);\n\
<a name="line-3551"></a> \                return true;\n\
<a name="line-3552"></a> \        } else\n\
<a name="line-3553"></a> \                return jhc_valid_whnf((wptr_t)ds-&gt;head);\n\
<a name="line-3554"></a> \}\n\
<a name="line-3555"></a> \\n\
<a name="line-3556"></a> \#endif\n\
<a name="line-3557"></a> \\n\
<a name="line-3558"></a> \#if _JHC_DEBUG\n\
<a name="line-3559"></a> \wptr_t A_STD\n\
<a name="line-3560"></a> \promote(sptr_t s)\n\
<a name="line-3561"></a> \{\n\
<a name="line-3562"></a> \        assert(!IS_LAZY(s));\n\
<a name="line-3563"></a> \        assert(jhc_valid_whnf((wptr_t)s));\n\
<a name="line-3564"></a> \        return (wptr_t)s;\n\
<a name="line-3565"></a> \}\n\
<a name="line-3566"></a> \\n\
<a name="line-3567"></a> \sptr_t A_STD\n\
<a name="line-3568"></a> \demote(wptr_t s)\n\
<a name="line-3569"></a> \{\n\
<a name="line-3570"></a> \        assert(!IS_LAZY(s));\n\
<a name="line-3571"></a> \        assert(jhc_valid_whnf(s));\n\
<a name="line-3572"></a> \        return (sptr_t)s;\n\
<a name="line-3573"></a> \}\n\
<a name="line-3574"></a> \\n\
<a name="line-3575"></a> \void A_STD\n\
<a name="line-3576"></a> \update(void * thunk, wptr_t new)\n\
<a name="line-3577"></a> \{\n\
<a name="line-3578"></a> \        assert(GETHEAD(thunk) == BLACK_HOLE);\n\
<a name="line-3579"></a> \        assert(!IS_LAZY(new));\n\
<a name="line-3580"></a> \        GETHEAD(thunk) = (fptr_t)new;\n\
<a name="line-3581"></a> \}\n\
<a name="line-3582"></a> \\n\
<a name="line-3583"></a> \#endif\n\
<a name="line-3584"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-3585"></a>
<a name="line-3586"></a><a name="profile_h"></a><span class='hs-comment'>-- | Generated from rts\/rts\/profile.h</span>
<a name="line-3587"></a><span class='hs-comment'>{-# NOINLINE profile_h #-}</span>
<a name="line-3588"></a><span class='hs-definition'>profile_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-3589"></a><span class='hs-definition'>profile_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-3590"></a> \#ifndef RTS_PROFILE_H\n\
<a name="line-3591"></a> \#define RTS_PROFILE_H\n\
<a name="line-3592"></a> \\n\
<a name="line-3593"></a> \#include &lt;stdio.h&gt;\n\
<a name="line-3594"></a> \#include \"rts/cdefs.h\"\n\
<a name="line-3595"></a> \\n\
<a name="line-3596"></a> \#ifndef JHC_VALGRIND\n\
<a name="line-3597"></a> \#define JHC_VALGRIND 0\n\
<a name="line-3598"></a> \#endif\n\
<a name="line-3599"></a> \\n\
<a name="line-3600"></a> \#ifndef JHC_MEM_ANNOTATE\n\
<a name="line-3601"></a> \#define JHC_MEM_ANNOTATE 0\n\
<a name="line-3602"></a> \#endif\n\
<a name="line-3603"></a> \\n\
<a name="line-3604"></a> \#ifndef _JHC_PROFILE\n\
<a name="line-3605"></a> \#define _JHC_PROFILE 0\n\
<a name="line-3606"></a> \#endif\n\
<a name="line-3607"></a> \\n\
<a name="line-3608"></a> \#if JHC_VALGRIND\n\
<a name="line-3609"></a> \#include &lt;valgrind/valgrind.h&gt;\n\
<a name="line-3610"></a> \#include &lt;valgrind/memcheck.h&gt;\n\
<a name="line-3611"></a> \#else\n\
<a name="line-3612"></a> \#define VALGRIND_MAKE_MEM_UNDEFINED(x,y) \\\n\
<a name="line-3613"></a> \    do { } while (0)\n\
<a name="line-3614"></a> \#define VALGRIND_MAKE_MEM_DEFINED(x,y) \\\n\
<a name="line-3615"></a> \    do { } while (0)\n\
<a name="line-3616"></a> \#define VALGRIND_MAKE_MEM_NOACCESS(x,y) \\\n\
<a name="line-3617"></a> \    do { } while (0)\n\
<a name="line-3618"></a> \#define VALGRIND_PRINTF(...) \\\n\
<a name="line-3619"></a> \    do { } while (0)\n\
<a name="line-3620"></a> \#endif\n\
<a name="line-3621"></a> \\n\
<a name="line-3622"></a> \void A_UNUSED profile_print_header(FILE *file, char *value_unit);\n\
<a name="line-3623"></a> \void A_COLD jhc_print_profile(void);\n\
<a name="line-3624"></a> \\n\
<a name="line-3625"></a> \#if _JHC_PROFILE\n\
<a name="line-3626"></a> \struct profile_stack;\n\
<a name="line-3627"></a> \extern struct profile_stack gc_alloc_time;\n\
<a name="line-3628"></a> \extern struct profile_stack gc_gc_time;\n\
<a name="line-3629"></a> \void jhc_profile_push(struct profile_stack *ps);\n\
<a name="line-3630"></a> \void jhc_profile_pop(struct profile_stack *ps);\n\
<a name="line-3631"></a> \#define profile_push(x) jhc_profile_push(x)\n\
<a name="line-3632"></a> \#define profile_pop(x)  jhc_profile_pop(x)\n\
<a name="line-3633"></a> \#else\n\
<a name="line-3634"></a> \#define profile_push(x)          do { } while(0)\n\
<a name="line-3635"></a> \#define profile_pop(x)           do { } while(0)\n\
<a name="line-3636"></a> \#define alloc_count(x,y)         do { } while(0)\n\
<a name="line-3637"></a> \#define print_alloc_size_stats() do { } while(0)\n\
<a name="line-3638"></a> \#endif\n\
<a name="line-3639"></a> \\n\
<a name="line-3640"></a> \#if JHC_STATUS &gt; 1\n\
<a name="line-3641"></a> \#define debugf(...) fprintf(stderr,__VA_ARGS__)\n\
<a name="line-3642"></a> \#else\n\
<a name="line-3643"></a> \#define debugf(...) do { } while (0)\n\
<a name="line-3644"></a> \#endif\n\
<a name="line-3645"></a> \\n\
<a name="line-3646"></a> \#endif\n\
<a name="line-3647"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-3648"></a>
<a name="line-3649"></a><a name="cdefs_h"></a><span class='hs-comment'>-- | Generated from rts\/rts\/cdefs.h</span>
<a name="line-3650"></a><span class='hs-comment'>{-# NOINLINE cdefs_h #-}</span>
<a name="line-3651"></a><span class='hs-definition'>cdefs_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-3652"></a><span class='hs-definition'>cdefs_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-3653"></a> \#ifndef RTS_CDEFS_H\n\
<a name="line-3654"></a> \#define RTS_CDEFS_H\n\
<a name="line-3655"></a> \\n\
<a name="line-3656"></a> \// GNU attributes\n\
<a name="line-3657"></a> \#if !defined(__predict_true)\n\
<a name="line-3658"></a> \#ifdef __GNUC__\n\
<a name="line-3659"></a> \#  define __predict_true(exp)     __builtin_expect(!!(exp), 1)\n\
<a name="line-3660"></a> \#  define __predict_false(exp)    __builtin_expect(!!(exp), 0)\n\
<a name="line-3661"></a> \#else\n\
<a name="line-3662"></a> \#  define __predict_true(exp)     (exp)\n\
<a name="line-3663"></a> \#  define __predict_false(exp)    (exp)\n\
<a name="line-3664"></a> \#endif\n\
<a name="line-3665"></a> \#endif\n\
<a name="line-3666"></a> \\n\
<a name="line-3667"></a> \#ifdef __GNUC__\n\
<a name="line-3668"></a> \#define A_ALIGNED  __attribute__ ((aligned))\n\
<a name="line-3669"></a> \#define A_CONST    __attribute__ ((const))\n\
<a name="line-3670"></a> \#define A_MALLOC   __attribute__ ((malloc))\n\
<a name="line-3671"></a> \#define A_MAYALIAS __attribute__ ((__may_alias__))\n\
<a name="line-3672"></a> \#define A_NORETURN __attribute__ ((noreturn))\n\
<a name="line-3673"></a> \#define A_PURE     __attribute__ ((pure))\n\
<a name="line-3674"></a> \#define A_UNUSED   __attribute__ ((unused))\n\
<a name="line-3675"></a> \#ifdef __i386__\n\
<a name="line-3676"></a> \#define A_REGPARM __attribute__ ((fastcall))\n\
<a name="line-3677"></a> \#else\n\
<a name="line-3678"></a> \#define A_REGPARM\n\
<a name="line-3679"></a> \#endif\n\
<a name="line-3680"></a> \#define A_STD    A_REGPARM\n\
<a name="line-3681"></a> \\n\
<a name="line-3682"></a> \#else\n\
<a name="line-3683"></a> \#define A_ALIGNED\n\
<a name="line-3684"></a> \#define A_CONST\n\
<a name="line-3685"></a> \#define A_MALLOC\n\
<a name="line-3686"></a> \#define A_MAYALIAS\n\
<a name="line-3687"></a> \#define A_NORETURN\n\
<a name="line-3688"></a> \#define A_PURE\n\
<a name="line-3689"></a> \#define A_UNUSED\n\
<a name="line-3690"></a> \#define A_STD\n\
<a name="line-3691"></a> \#endif\n\
<a name="line-3692"></a> \\n\
<a name="line-3693"></a> \// these should be enabled with newer versions of gcc\n\
<a name="line-3694"></a> \#define A_HOT\n\
<a name="line-3695"></a> \#define A_COLD\n\
<a name="line-3696"></a> \#define A_FALIGNED\n\
<a name="line-3697"></a> \\n\
<a name="line-3698"></a> \#endif\n\
<a name="line-3699"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-3700"></a>
<a name="line-3701"></a><a name="rts_support_c"></a><span class='hs-comment'>-- | Generated from rts\/rts\/rts_support.c</span>
<a name="line-3702"></a><span class='hs-comment'>{-# NOINLINE rts_support_c #-}</span>
<a name="line-3703"></a><span class='hs-definition'>rts_support_c</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-3704"></a><span class='hs-definition'>rts_support_c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-3705"></a> \#include &lt;stdio.h&gt;\n\
<a name="line-3706"></a> \#include &lt;stdlib.h&gt;\n\
<a name="line-3707"></a> \#include &lt;locale.h&gt;\n\
<a name="line-3708"></a> \\n\
<a name="line-3709"></a> \#include \"HsFFI.h\"\n\
<a name="line-3710"></a> \#include \"rts/rts_support.h\"\n\
<a name="line-3711"></a> \#include \"rts/profile.h\"\n\
<a name="line-3712"></a> \#include \"rts/gc.h\"\n\
<a name="line-3713"></a> \\n\
<a name="line-3714"></a> \jmp_buf jhc_uncaught;\n\
<a name="line-3715"></a> \int jhc_argc;\n\
<a name="line-3716"></a> \char **jhc_argv;\n\
<a name="line-3717"></a> \char *jhc_progname;\n\
<a name="line-3718"></a> \\n\
<a name="line-3719"></a> \#ifdef __WIN32__\n\
<a name="line-3720"></a> \A_UNUSED char *jhc_options_os =  \"mingw32\";\n\
<a name="line-3721"></a> \A_UNUSED char *jhc_options_arch = \"i386\";\n\
<a name="line-3722"></a> \#elif defined(__ARM_EABI__)\n\
<a name="line-3723"></a> \A_UNUSED char *jhc_options_os =  \"nds\";\n\
<a name="line-3724"></a> \A_UNUSED char *jhc_options_arch = \"ARM\";\n\
<a name="line-3725"></a> \#else\n\
<a name="line-3726"></a> \A_UNUSED char *jhc_options_os = \"(unknown os)\";\n\
<a name="line-3727"></a> \A_UNUSED char *jhc_options_arch = \"(unknown arch)\";\n\
<a name="line-3728"></a> \#endif\n\
<a name="line-3729"></a> \\n\
<a name="line-3730"></a> \void\n\
<a name="line-3731"></a> \hs_set_argv(int argc, char *argv[])\n\
<a name="line-3732"></a> \{\n\
<a name="line-3733"></a> \        jhc_argc = argc - 1;\n\
<a name="line-3734"></a> \        jhc_argv = argv + 1;\n\
<a name="line-3735"></a> \        jhc_progname = argv[0];\n\
<a name="line-3736"></a> \}\n\
<a name="line-3737"></a> \\n\
<a name="line-3738"></a> \void A_NORETURN A_UNUSED A_COLD\n\
<a name="line-3739"></a> \jhc_exit(int n) {\n\
<a name="line-3740"></a> \        fflush(stdout);\n\
<a name="line-3741"></a> \        jhc_print_profile();\n\
<a name="line-3742"></a> \        exit(n);\n\
<a name="line-3743"></a> \}\n\
<a name="line-3744"></a> \\n\
<a name="line-3745"></a> \void  A_NORETURN A_UNUSED  A_COLD\n\
<a name="line-3746"></a> \jhc_error(char *s) {\n\
<a name="line-3747"></a> \        fflush(stdout);\n\
<a name="line-3748"></a> \        fputs(s,stderr);\n\
<a name="line-3749"></a> \        fputs(\"\\n\",stderr);\n\
<a name="line-3750"></a> \        jhc_exit(1);\n\
<a name="line-3751"></a> \}\n\
<a name="line-3752"></a> \\n\
<a name="line-3753"></a> \void  A_NORETURN A_UNUSED  A_COLD\n\
<a name="line-3754"></a> \jhc_case_fell_off(int n) {\n\
<a name="line-3755"></a> \        fflush(stdout);\n\
<a name="line-3756"></a> \        fprintf(stderr, \"\\n%s:%i: case fell off\\n\", __FILE__, n);\n\
<a name="line-3757"></a> \        abort();\n\
<a name="line-3758"></a> \}\n\
<a name="line-3759"></a> \\n\
<a name="line-3760"></a> \void jhc_hs_init(void);\n\
<a name="line-3761"></a> \\n\
<a name="line-3762"></a> \static int hs_init_count;\n\
<a name="line-3763"></a> \void\n\
<a name="line-3764"></a> \hs_init(int *argc, char **argv[])\n\
<a name="line-3765"></a> \{\n\
<a name="line-3766"></a> \\n\
<a name="line-3767"></a> \        if(!hs_init_count++) {\n\
<a name="line-3768"></a> \                jhc_alloc_init();\n\
<a name="line-3769"></a> \                jhc_hs_init();\n\
<a name="line-3770"></a> \                hs_set_argv(*argc,*argv);\n\
<a name="line-3771"></a> \#if JHC_isPosix\n\
<a name="line-3772"></a> \                struct utsname jhc_utsname;\n\
<a name="line-3773"></a> \                if(!uname(&amp;jhc_utsname)) {\n\
<a name="line-3774"></a> \                        jhc_options_arch = jhc_utsname.machine;\n\
<a name="line-3775"></a> \                        jhc_options_os   = jhc_utsname.sysname;\n\
<a name="line-3776"></a> \                }\n\
<a name="line-3777"></a> \#endif\n\
<a name="line-3778"></a> \                setlocale(LC_ALL,\"\");\n\
<a name="line-3779"></a> \        }\n\
<a name="line-3780"></a> \}\n\
<a name="line-3781"></a> \\n\
<a name="line-3782"></a> \void\n\
<a name="line-3783"></a> \hs_exit(void)\n\
<a name="line-3784"></a> \{\n\
<a name="line-3785"></a> \        if(!hs_init_count) {\n\
<a name="line-3786"></a> \                fprintf(stderr, \"hs_exit() called before hs_init()\\n\");\n\
<a name="line-3787"></a> \                abort();\n\
<a name="line-3788"></a> \        }\n\
<a name="line-3789"></a> \        if(!--hs_init_count) {\n\
<a name="line-3790"></a> \                jhc_alloc_fini();\n\
<a name="line-3791"></a> \                jhc_exit(0);\n\
<a name="line-3792"></a> \        }\n\
<a name="line-3793"></a> \}\n\
<a name="line-3794"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-3795"></a>
<a name="line-3796"></a><a name="rts_support_h"></a><span class='hs-comment'>-- | Generated from rts\/rts\/rts_support.h</span>
<a name="line-3797"></a><span class='hs-comment'>{-# NOINLINE rts_support_h #-}</span>
<a name="line-3798"></a><span class='hs-definition'>rts_support_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-3799"></a><span class='hs-definition'>rts_support_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-3800"></a> \#ifndef RTS_SUPPORT_H\n\
<a name="line-3801"></a> \#define RTS_SUPPORT_H\n\
<a name="line-3802"></a> \\n\
<a name="line-3803"></a> \#include &lt;setjmp.h&gt;\n\
<a name="line-3804"></a> \#include \"rts/cdefs.h\"\n\
<a name="line-3805"></a> \\n\
<a name="line-3806"></a> \extern jmp_buf jhc_uncaught;\n\
<a name="line-3807"></a> \A_UNUSED extern char *jhc_options_os;\n\
<a name="line-3808"></a> \A_UNUSED extern char *jhc_options_arch;\n\
<a name="line-3809"></a> \extern int jhc_argc;\n\
<a name="line-3810"></a> \extern char **jhc_argv;\n\
<a name="line-3811"></a> \extern char *jhc_progname;\n\
<a name="line-3812"></a> \\n\
<a name="line-3813"></a> \extern char jhc_c_compile[];\n\
<a name="line-3814"></a> \extern char jhc_command[];\n\
<a name="line-3815"></a> \extern char jhc_version[];\n\
<a name="line-3816"></a> \\n\
<a name="line-3817"></a> \void A_NORETURN A_UNUSED A_COLD jhc_exit(int n);\n\
<a name="line-3818"></a> \void A_NORETURN A_UNUSED A_COLD jhc_error(char *s);\n\
<a name="line-3819"></a> \void A_NORETURN A_UNUSED A_COLD jhc_case_fell_off(int n);\n\
<a name="line-3820"></a> \\n\
<a name="line-3821"></a> \#define jhc_setjmp(jb) setjmp(*(jb))\n\
<a name="line-3822"></a> \#define jhc_longjmp(jb) longjmp(*(jb),1)\n\
<a name="line-3823"></a> \\n\
<a name="line-3824"></a> \#define prim_umaxbound(t) ((t)~((t)0))\n\
<a name="line-3825"></a> \#define prim_maxbound(t) ((t)(~((t)1 &lt;&lt; (sizeof(t)*CHAR_BIT - 1))))\n\
<a name="line-3826"></a> \#define prim_minbound(t) ((t)(((t)1 &lt;&lt; (sizeof(t)*CHAR_BIT - 1))))\n\
<a name="line-3827"></a> \\n\
<a name="line-3828"></a> \#endif\n\
<a name="line-3829"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-3830"></a>
<a name="line-3831"></a><a name="gc_h"></a><span class='hs-comment'>-- | Generated from rts\/rts\/gc.h</span>
<a name="line-3832"></a><span class='hs-comment'>{-# NOINLINE gc_h #-}</span>
<a name="line-3833"></a><span class='hs-definition'>gc_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-3834"></a><span class='hs-definition'>gc_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-3835"></a> \#ifndef JHC_GC_H\n\
<a name="line-3836"></a> \#define JHC_GC_H\n\
<a name="line-3837"></a> \\n\
<a name="line-3838"></a> \#define _JHC_GC_NONE   0\n\
<a name="line-3839"></a> \#define _JHC_GC_JGC    1\n\
<a name="line-3840"></a> \#define _JHC_GC_BOEHM  2\n\
<a name="line-3841"></a> \#define _JHC_GC_REGION 3\n\
<a name="line-3842"></a> \\n\
<a name="line-3843"></a> \#ifndef _JHC_GC\n\
<a name="line-3844"></a> \#define _JHC_GC _JHC_GC_NONE\n\
<a name="line-3845"></a> \#endif\n\
<a name="line-3846"></a> \\n\
<a name="line-3847"></a> \void jhc_alloc_init(void);\n\
<a name="line-3848"></a> \void jhc_alloc_fini(void);\n\
<a name="line-3849"></a> \\n\
<a name="line-3850"></a> \#include \"rts/gc_none.h\"\n\
<a name="line-3851"></a> \#include \"rts/gc_jgc.h\"\n\
<a name="line-3852"></a> \\n\
<a name="line-3853"></a> \#endif\n\
<a name="line-3854"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-3855"></a>
<a name="line-3856"></a><a name="gc_none_c"></a><span class='hs-comment'>-- | Generated from rts\/rts\/gc_none.c</span>
<a name="line-3857"></a><span class='hs-comment'>{-# NOINLINE gc_none_c #-}</span>
<a name="line-3858"></a><span class='hs-definition'>gc_none_c</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-3859"></a><span class='hs-definition'>gc_none_c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-3860"></a> \#include &lt;stdlib.h&gt;\n\
<a name="line-3861"></a> \#include &lt;stdio.h&gt;\n\
<a name="line-3862"></a> \#include \"rts/gc.h\"\n\
<a name="line-3863"></a> \#include \"rts/profile.h\"\n\
<a name="line-3864"></a> \\n\
<a name="line-3865"></a> \#if _JHC_GC == _JHC_GC_BOEHM\n\
<a name="line-3866"></a> \\n\
<a name="line-3867"></a> \void hs_perform_gc(void) {\n\
<a name="line-3868"></a> \        GC_gcollect();\n\
<a name="line-3869"></a> \}\n\
<a name="line-3870"></a> \\n\
<a name="line-3871"></a> \void jhc_alloc_init(void) { GC_INIT(); }\n\
<a name="line-3872"></a> \void jhc_alloc_fini(void) { }\n\
<a name="line-3873"></a> \\n\
<a name="line-3874"></a> \#elif _JHC_GC == _JHC_GC_NONE\n\
<a name="line-3875"></a> \\n\
<a name="line-3876"></a> \// memory allocated in 1MB chunks.\n\
<a name="line-3877"></a> \#define JHC_MEM_CHUNK_SIZE (1 &lt;&lt; 20)\n\
<a name="line-3878"></a> \\n\
<a name="line-3879"></a> \static char initial_chunk[JHC_MEM_CHUNK_SIZE];\n\
<a name="line-3880"></a> \\n\
<a name="line-3881"></a> \static void *jhc_current_chunk = initial_chunk;\n\
<a name="line-3882"></a> \static unsigned mem_chunks,mem_offset;\n\
<a name="line-3883"></a> \\n\
<a name="line-3884"></a> \void jhc_alloc_init(void) {}\n\
<a name="line-3885"></a> \\n\
<a name="line-3886"></a> \void\n\
<a name="line-3887"></a> \jhc_alloc_fini(void) {\n\
<a name="line-3888"></a> \        if(_JHC_PROFILE) {\n\
<a name="line-3889"></a> \                fprintf(stderr, \"Memory Allocated: %u bytes\\n\", (JHC_MEM_CHUNK_SIZE*(mem_chunks)) + mem_offset);\n\
<a name="line-3890"></a> \                print_alloc_size_stats();\n\
<a name="line-3891"></a> \        }\n\
<a name="line-3892"></a> \}\n\
<a name="line-3893"></a> \\n\
<a name="line-3894"></a> \static void\n\
<a name="line-3895"></a> \jhc_malloc_grow(void) {\n\
<a name="line-3896"></a> \        void *c = malloc(JHC_MEM_CHUNK_SIZE);\n\
<a name="line-3897"></a> \        if(!c) {\n\
<a name="line-3898"></a> \                fputs(\"Out of memory!\\n\",stderr);\n\
<a name="line-3899"></a> \                abort();\n\
<a name="line-3900"></a> \        }\n\
<a name="line-3901"></a> \        mem_chunks++;\n\
<a name="line-3902"></a> \        jhc_current_chunk = c;\n\
<a name="line-3903"></a> \        mem_offset = 0;\n\
<a name="line-3904"></a> \}\n\
<a name="line-3905"></a> \\n\
<a name="line-3906"></a> \#define M_ALIGN(a,n) ((n) - 1 + ((a) - ((n) - 1) % (a)))\n\
<a name="line-3907"></a> \\n\
<a name="line-3908"></a> \static inline void * A_MALLOC\n\
<a name="line-3909"></a> \jhc_malloc_basic(size_t n) {\n\
<a name="line-3910"></a> \        n = M_ALIGN(sizeof(void *),n);\n\
<a name="line-3911"></a> \        if (n &gt; (JHC_MEM_CHUNK_SIZE - mem_offset))\n\
<a name="line-3912"></a> \                jhc_malloc_grow();\n\
<a name="line-3913"></a> \        void *ret = jhc_current_chunk + mem_offset;\n\
<a name="line-3914"></a> \        mem_offset += n;\n\
<a name="line-3915"></a> \        return ret;\n\
<a name="line-3916"></a> \}\n\
<a name="line-3917"></a> \\n\
<a name="line-3918"></a> \#if _JHC_DEBUG\n\
<a name="line-3919"></a> \\n\
<a name="line-3920"></a> \void * A_MALLOC\n\
<a name="line-3921"></a> \jhc_malloc_debug(size_t n,int line,int atomic) {\n\
<a name="line-3922"></a> \        alloc_count(n,atomic);\n\
<a name="line-3923"></a> \        void *ret = jhc_malloc_basic(n + sizeof(uintptr_t));\n\
<a name="line-3924"></a> \        *((uintptr_t *)ret) = line;\n\
<a name="line-3925"></a> \        return ret + sizeof(uintptr_t);\n\
<a name="line-3926"></a> \}\n\
<a name="line-3927"></a> \\n\
<a name="line-3928"></a> \#else\n\
<a name="line-3929"></a> \\n\
<a name="line-3930"></a> \void * A_MALLOC\n\
<a name="line-3931"></a> \jhc_malloc(size_t n) {\n\
<a name="line-3932"></a> \        alloc_count(n,0);\n\
<a name="line-3933"></a> \        return jhc_malloc_basic(n);\n\
<a name="line-3934"></a> \}\n\
<a name="line-3935"></a> \\n\
<a name="line-3936"></a> \#undef jhc_malloc_atomic\n\
<a name="line-3937"></a> \void * A_MALLOC\n\
<a name="line-3938"></a> \jhc_malloc_atomic(size_t n) {\n\
<a name="line-3939"></a> \        alloc_count(n,1);\n\
<a name="line-3940"></a> \        return jhc_malloc_basic(n);\n\
<a name="line-3941"></a> \}\n\
<a name="line-3942"></a> \\n\
<a name="line-3943"></a> \#endif\n\
<a name="line-3944"></a> \\n\
<a name="line-3945"></a> \#endif\n\
<a name="line-3946"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-3947"></a>
<a name="line-3948"></a><a name="gc_none_h"></a><span class='hs-comment'>-- | Generated from rts\/rts\/gc_none.h</span>
<a name="line-3949"></a><span class='hs-comment'>{-# NOINLINE gc_none_h #-}</span>
<a name="line-3950"></a><span class='hs-definition'>gc_none_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-3951"></a><span class='hs-definition'>gc_none_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-3952"></a> \#ifndef GC_NONE_H\n\
<a name="line-3953"></a> \#define GC_NONE_H\n\
<a name="line-3954"></a> \\n\
<a name="line-3955"></a> \#include &lt;stddef.h&gt;\n\
<a name="line-3956"></a> \#include \"rts/cdefs.h\"\n\
<a name="line-3957"></a> \\n\
<a name="line-3958"></a> \#define jhc_malloc_sanity(p,t) (1)\n\
<a name="line-3959"></a> \\n\
<a name="line-3960"></a> \#if _JHC_GC == _JHC_GC_BOEHM\n\
<a name="line-3961"></a> \\n\
<a name="line-3962"></a> \#include \"rts/profile.h\"\n\
<a name="line-3963"></a> \\n\
<a name="line-3964"></a> \#include &lt;gc/gc.h&gt;\n\
<a name="line-3965"></a> \\n\
<a name="line-3966"></a> \#define jhc_malloc GC_malloc\n\
<a name="line-3967"></a> \#define jhc_malloc_atomic GC_malloc_atomic\n\
<a name="line-3968"></a> \\n\
<a name="line-3969"></a> \#elif _JHC_GC == _JHC_GC_NONE\n\
<a name="line-3970"></a> \\n\
<a name="line-3971"></a> \#if _JHC_DEBUG\n\
<a name="line-3972"></a> \void * A_MALLOC jhc_malloc_debug(size_t n,int line,int atomic);\n\
<a name="line-3973"></a> \#define jhc_malloc(n) jhc_malloc_debug(n,__LINE__,0)\n\
<a name="line-3974"></a> \#define jhc_malloc_atomic(n) jhc_malloc_debug(n,__LINE__,1)\n\
<a name="line-3975"></a> \#else\n\
<a name="line-3976"></a> \void * A_MALLOC jhc_malloc(size_t n);\n\
<a name="line-3977"></a> \void * A_MALLOC jhc_malloc_atomic(size_t n);\n\
<a name="line-3978"></a> \#endif\n\
<a name="line-3979"></a> \\n\
<a name="line-3980"></a> \#endif\n\
<a name="line-3981"></a> \\n\
<a name="line-3982"></a> \#endif\n\
<a name="line-3983"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-3984"></a>
<a name="line-3985"></a><a name="jhc_rts_c"></a><span class='hs-comment'>-- | Generated from rts\/rts\/jhc_rts.c</span>
<a name="line-3986"></a><span class='hs-comment'>{-# NOINLINE jhc_rts_c #-}</span>
<a name="line-3987"></a><span class='hs-definition'>jhc_rts_c</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-3988"></a><span class='hs-definition'>jhc_rts_c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-3989"></a> \/*@Internals\n\
<a name="line-3990"></a> \\n\
<a name="line-3991"></a> \# The Run Time System\n\
<a name="line-3992"></a> \\n\
<a name="line-3993"></a> \Ajhc is very minimalist in that it does not have a precompiled run time system,\n\
<a name="line-3994"></a> \but rather generates what is needed as part of the compilation process.\n\
<a name="line-3995"></a> \However, back ends do have specific run-time representations of data, which can\n\
<a name="line-3996"></a> \be affected by things like the choice of garbage collector. The following\n\
<a name="line-3997"></a> \describes the general layout for the C based back-ends, but compiler options\n\
<a name="line-3998"></a> \such as garbage collection method or whether we do full program analysis, will\n\
<a name="line-3999"></a> \affect which features are used and whether certain optimized layouts are\n\
<a name="line-4000"></a> \possible.\n\
<a name="line-4001"></a> \\n\
<a name="line-4002"></a> \Unboxed values directly translate to values in the target language, an unboxed\n\
<a name="line-4003"></a> \Int will translate directly into an 'int' as an argument and an unboxed pointer\n\
<a name="line-4004"></a> \will be a raw pointer. Unboxed values have no special interpretation and are\n\
<a name="line-4005"></a> \_not_ followed by the garbage collector. If the target language does not\n\
<a name="line-4006"></a> \support a feature such as multiple return values, it will have to be simulated.\n\
<a name="line-4007"></a> \It would not be wrong to think of Grin code that only deals with unboxed values\n\
<a name="line-4008"></a> \to be isomorphic to C-- or C augmented with multiple return values.\n\
<a name="line-4009"></a> \\n\
<a name="line-4010"></a> \Boxed values have a standard representation and can be followed. Unlike some\n\
<a name="line-4011"></a> \other implementation, being boxed does not imply the object is located on the\n\
<a name="line-4012"></a> \heap. It may be on the stack, heap, or even embedded within the smart pointer\n\
<a name="line-4013"></a> \itself. Being boxed only means that the object may be represented by a smart\n\
<a name="line-4014"></a> \pointer, which may or may not actually be a pointer in the traditional sense.\n\
<a name="line-4015"></a> \\n\
<a name="line-4016"></a> \A boxed value in Ajhc is represented by a 'smart pointer' of c type sptr_t. a\n\
<a name="line-4017"></a> \smart pointer is the size of a native pointer, but can take on different roles\n\
<a name="line-4018"></a> \depending on a pair of tag bits, called the ptype.\n\
<a name="line-4019"></a> \\n\
<a name="line-4020"></a> \smart pointers take on a general form as follows:\n\
<a name="line-4021"></a> \\n\
<a name="line-4022"></a> \    -------------------------\n\
<a name="line-4023"></a> \    |    payload        | GL|\n\
<a name="line-4024"></a> \    -------------------------\n\
<a name="line-4025"></a> \\n\
<a name="line-4026"></a> \      G - if set, then the garbage collector should not treat value as a pointer to be followed\n\
<a name="line-4027"></a> \      L - lazy, this bit being set means the value is potentially not in WHNF\n\
<a name="line-4028"></a> \\n\
<a name="line-4029"></a> \A sptr_t on its own in the wild can only take on one of the following forms:\n\
<a name="line-4030"></a> \\n\
<a name="line-4031"></a> \    -------------------------\n\
<a name="line-4032"></a> \    |    whnf raw value | 10|\n\
<a name="line-4033"></a> \    -------------------------\n\
<a name="line-4034"></a> \\n\
<a name="line-4035"></a> \    -------------------------\n\
<a name="line-4036"></a> \    |    whnf location  | 00|\n\
<a name="line-4037"></a> \    -------------------------\n\
<a name="line-4038"></a> \\n\
<a name="line-4039"></a> \WHNF stands for 'Weak Head Normal Form' and means that the value is not a\n\
<a name="line-4040"></a> \suspended function and hence not a pointer to a thunk. It may be directly\n\
<a name="line-4041"></a> \examined and need not be evaluated. wptr_t is an alias for sptr_t that is\n\
<a name="line-4042"></a> \guarenteed to be of one of the above forms. It is used to improve safety for\n\
<a name="line-4043"></a> \when we can statically know that a value is WHNF and hence we can skip the\n\
<a name="line-4044"></a> \expensive 'eval'.\n\
<a name="line-4045"></a> \\n\
<a name="line-4046"></a> \The difference between the raw value and the whnf location is that the first\n\
<a name="line-4047"></a> \contains uninterpreted bits, while the second is a pointer to a location on the\n\
<a name="line-4048"></a> \heap or stack and hence the garbage collector should follow it. The format of\n\
<a name="line-4049"></a> \the memory pointed to by the whnf location is unspecified and dependent on the\n\
<a name="line-4050"></a> \actual type being represented.\n\
<a name="line-4051"></a> \\n\
<a name="line-4052"></a> \Partial (unsaturated) applications are normal WHNF values. Saturated\n\
<a name="line-4053"></a> \applications which may be 'eval'ed and updated are called thunks and must not\n\
<a name="line-4054"></a> \be pointed to by WHNF pointers. Their representation follows.\n\
<a name="line-4055"></a> \\n\
<a name="line-4056"></a> \    -------------------------\n\
<a name="line-4057"></a> \    |   lazy location   | 01|\n\
<a name="line-4058"></a> \    -------------------------\n\
<a name="line-4059"></a> \\n\
<a name="line-4060"></a> \A lazy location points to either a thunk, or a redirection to a WHNF value. A\n\
<a name="line-4061"></a> \lazy location is always a pointer to an allocated block of memory which always\n\
<a name="line-4062"></a> \begins with a restricted smart pointer. This restricted smart pointer is represented by\n\
<a name="line-4063"></a> \the C type alias 'fptr_t'. fptr_t's only occur as the first entry in a lazy\n\
<a name="line-4064"></a> \location, they never are passed around as objects in their own right.\n\
<a name="line-4065"></a> \\n\
<a name="line-4066"></a> \A fptr_t may be a whnf value or a code pointer. If a fptr_t is a whnf value (of one of\n\
<a name="line-4067"></a> \the two forms given above) then it is called a redirection, the lazy location should be\n\
<a name="line-4068"></a> \treated exactly as if it were the whnf given. This is used to redirect an evaluated\n\
<a name="line-4069"></a> \thunk to its computed value.\n\
<a name="line-4070"></a> \\n\
<a name="line-4071"></a> \A fptr_t may also be a 'code pointer' in which case the lazy location is called\n\
<a name="line-4072"></a> \a thunk. A code pointer is a pointer to executable machine code that evaluates\n\
<a name="line-4073"></a> \a closure and returns a wptr_t, the returned wptr_t is then generally written\n\
<a name="line-4074"></a> \over the code pointer, turning the thunk into a redirection. It is the\n\
<a name="line-4075"></a> \responsibility of the code pointed to to perform this redirection.\n\
<a name="line-4076"></a> \\n\
<a name="line-4077"></a> \    -------------------------\n\
<a name="line-4078"></a> \    |    code pointer   | 11|\n\
<a name="line-4079"></a> \    -------------------------\n\
<a name="line-4080"></a> \    |     data ...          |\n\
<a name="line-4081"></a> \\n\
<a name="line-4082"></a> \When debugging, the special code pointer BLACK_HOLE is also sometimes stored in\n\
<a name="line-4083"></a> \a fptr_t to detect certain run-time errors.\n\
<a name="line-4084"></a> \\n\
<a name="line-4085"></a> \Note that unlike other implementations, a fptr_t may _not_ be another lazy\n\
<a name="line-4086"></a> \location. you can not have chained redirections, a redirection is always a\n\
<a name="line-4087"></a> \redirection to a whnf value.\n\
<a name="line-4088"></a> \\n\
<a name="line-4089"></a> \    sptr_t - a tagged smart pointer, may contain a whnf value or a lazy location.\n\
<a name="line-4090"></a> \    wptr_t - a tagged smart pointer that contains a whnf value (either raw or a location)\n\
<a name="line-4091"></a> \    fptr_t - a tagged smart pointer, may contain a whnf value indicating a redirection, or a code pointer indicating a thunk.\n\
<a name="line-4092"></a> \\n\
<a name="line-4093"></a> \*/\n\
<a name="line-4094"></a> \\n\
<a name="line-4095"></a> \#include \"jhc_rts_header.h\"\n\
<a name="line-4096"></a> \\n\
<a name="line-4097"></a> \#if _JHC_GC == _JHC_GC_JGC\n\
<a name="line-4098"></a> \typedef wptr_t (*eval_fn)(gc_t gc,arena_t arena,node_t *node) A_STD;\n\
<a name="line-4099"></a> \#else\n\
<a name="line-4100"></a> \typedef wptr_t (*eval_fn)(node_t *node) A_STD;\n\
<a name="line-4101"></a> \#endif\n\
<a name="line-4102"></a> \\n\
<a name="line-4103"></a> \// like eval but you know the target is in WHNF or is a already evaluated indirection\n\
<a name="line-4104"></a> \static inline wptr_t A_STD A_UNUSED  A_HOT\n\
<a name="line-4105"></a> \follow(sptr_t s)\n\
<a name="line-4106"></a> \{\n\
<a name="line-4107"></a> \        assert(jhc_valid_lazy(s));\n\
<a name="line-4108"></a> \        if(IS_LAZY(s)) {\n\
<a name="line-4109"></a> \                sptr_t h = (sptr_t)(GETHEAD(FROM_SPTR(s)));\n\
<a name="line-4110"></a> \                assert(!IS_LAZY(h));\n\
<a name="line-4111"></a> \                return (wptr_t)h;\n\
<a name="line-4112"></a> \        }\n\
<a name="line-4113"></a> \        return (wptr_t)s;\n\
<a name="line-4114"></a> \}\n\
<a name="line-4115"></a> \\n\
<a name="line-4116"></a> \wptr_t A_STD A_UNUSED  A_HOT\n\
<a name="line-4117"></a> \#if _JHC_GC == _JHC_GC_JGC\n\
<a name="line-4118"></a> \eval(gc_t gc,arena_t arena,sptr_t s)\n\
<a name="line-4119"></a> \#else\n\
<a name="line-4120"></a> \eval(sptr_t s)\n\
<a name="line-4121"></a> \#endif\n\
<a name="line-4122"></a> \{\n\
<a name="line-4123"></a> \        assert(jhc_valid_lazy(s));\n\
<a name="line-4124"></a> \        if(IS_LAZY(s)) {\n\
<a name="line-4125"></a> \                assert(GET_PTYPE(s) == P_LAZY);\n\
<a name="line-4126"></a> \                void *ds = FROM_SPTR(s);\n\
<a name="line-4127"></a> \                sptr_t h = (sptr_t)(GETHEAD(ds));\n\
<a name="line-4128"></a> \                assert((fptr_t)h != BLACK_HOLE);\n\
<a name="line-4129"></a> \                if(IS_LAZY(h)) {\n\
<a name="line-4130"></a> \                        eval_fn fn = (eval_fn)FROM_SPTR(h);\n\
<a name="line-4131"></a> \                        assert(GET_PTYPE(h) == P_FUNC);\n\
<a name="line-4132"></a> \#if _JHC_DEBUG\n\
<a name="line-4133"></a> \                        GETHEAD(ds) = BLACK_HOLE;\n\
<a name="line-4134"></a> \#endif\n\
<a name="line-4135"></a> \                        fn = (eval_fn)SET_THUMB_BIT(fn);\n\
<a name="line-4136"></a> \#if _JHC_GC == _JHC_GC_JGC\n\
<a name="line-4137"></a> \                        wptr_t r = (*fn)(gc,arena,NODEP(ds));\n\
<a name="line-4138"></a> \#else\n\
<a name="line-4139"></a> \                        wptr_t r = (*fn)(NODEP(ds));\n\
<a name="line-4140"></a> \#endif\n\
<a name="line-4141"></a> \#if _JHC_DEBUG\n\
<a name="line-4142"></a> \                        assert(GETHEAD(ds) != BLACK_HOLE);\n\
<a name="line-4143"></a> \#endif\n\
<a name="line-4144"></a> \                        return r;\n\
<a name="line-4145"></a> \                }\n\
<a name="line-4146"></a> \                return (wptr_t)h;\n\
<a name="line-4147"></a> \        }\n\
<a name="line-4148"></a> \        assert(jhc_valid_whnf((wptr_t)s));\n\
<a name="line-4149"></a> \        return (wptr_t)s;\n\
<a name="line-4150"></a> \}\n\
<a name="line-4151"></a> \\n\
<a name="line-4152"></a> \#if _JHC_STANDALONE\n\
<a name="line-4153"></a> \int\n\
<a name="line-4154"></a> \main(int argc, char *argv[])\n\
<a name="line-4155"></a> \{\n\
<a name="line-4156"></a> \        hs_init(&amp;argc,&amp;argv);\n\
<a name="line-4157"></a> \        if (jhc_setjmp(&amp;jhc_uncaught))\n\
<a name="line-4158"></a> \                jhc_error(\"Uncaught Exception\");\n\
<a name="line-4159"></a> \        else\n\
<a name="line-4160"></a> \                _amain();\n\
<a name="line-4161"></a> \        hs_exit();\n\
<a name="line-4162"></a> \        return 0;\n\
<a name="line-4163"></a> \}\n\
<a name="line-4164"></a> \#endif\n\
<a name="line-4165"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-4166"></a>
<a name="line-4167"></a><a name="jhc_rts_h"></a><span class='hs-comment'>-- | Generated from rts\/rts\/jhc_rts.h</span>
<a name="line-4168"></a><span class='hs-comment'>{-# NOINLINE jhc_rts_h #-}</span>
<a name="line-4169"></a><span class='hs-definition'>jhc_rts_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-4170"></a><span class='hs-definition'>jhc_rts_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-4171"></a> \#ifndef JHC_RTS_H\n\
<a name="line-4172"></a> \#define JHC_RTS_H\n\
<a name="line-4173"></a> \\n\
<a name="line-4174"></a> \#include \"rts/profile.h\"\n\
<a name="line-4175"></a> \#include \"rts/gc.h\"\n\
<a name="line-4176"></a> \\n\
<a name="line-4177"></a> \struct sptr;\n\
<a name="line-4178"></a> \struct wptr;\n\
<a name="line-4179"></a> \struct fptr;\n\
<a name="line-4180"></a> \\n\
<a name="line-4181"></a> \// we use dummy structs here so the compiler will catch any attempt\n\
<a name="line-4182"></a> \// to use one type in anothers place\n\
<a name="line-4183"></a> \typedef struct sptr * sptr_t;\n\
<a name="line-4184"></a> \typedef struct sptr * wptr_t;\n\
<a name="line-4185"></a> \typedef struct fptr * fptr_t;\n\
<a name="line-4186"></a> \typedef uintptr_t     what_t;\n\
<a name="line-4187"></a> \\n\
<a name="line-4188"></a> \typedef struct node {\n\
<a name="line-4189"></a> \        fptr_t head;\n\
<a name="line-4190"></a> \        sptr_t rest[];\n\
<a name="line-4191"></a> \} A_MAYALIAS node_t;\n\
<a name="line-4192"></a> \\n\
<a name="line-4193"></a> \typedef struct dnode {\n\
<a name="line-4194"></a> \        what_t what;\n\
<a name="line-4195"></a> \        sptr_t rest[];\n\
<a name="line-4196"></a> \} A_MAYALIAS dnode_t;\n\
<a name="line-4197"></a> \\n\
<a name="line-4198"></a> \#define P_WHNF  0x0\n\
<a name="line-4199"></a> \#define P_LAZY  0x1\n\
<a name="line-4200"></a> \#define P_VALUE 0x2\n\
<a name="line-4201"></a> \#define P_FUNC  0x3\n\
<a name="line-4202"></a> \\n\
<a name="line-4203"></a> \#define IS_LAZY(x)     (bool)(((uintptr_t)(x)) &amp; 0x1)\n\
<a name="line-4204"></a> \#define IS_PTR(x)      (bool)(!(((uintptr_t)(x)) &amp; 0x2))\n\
<a name="line-4205"></a> \\n\
<a name="line-4206"></a> \#define FROM_SPTR(x)   (typeof (x))((uintptr_t)(x) &amp; ~0x3)  // remove a ptype from a smart pointer\n\
<a name="line-4207"></a> \#define GET_PTYPE(x)   ((uintptr_t)(x) &amp; 0x3)               // return the ptype associated with a smart pointer\n\
<a name="line-4208"></a> \#define TO_SPTR(t,x)   (typeof (x))((uintptr_t)(x) | (t))   // attach a ptype to a smart pointer\n\
<a name="line-4209"></a> \#define TO_SPTR_C(t,x) (typeof (x))((uintptr_t)(x) + (t))   // attach a ptype to a smart pointer, suitable for use by constant initialializers\n\
<a name="line-4210"></a> \\n\
<a name="line-4211"></a> \#define GETHEAD(x)   (NODEP(x)-&gt;head)\n\
<a name="line-4212"></a> \#define NODEP(x)     ((node_t *)(x))\n\
<a name="line-4213"></a> \#define DNODEP(x)    ((dnode_t *)(x))\n\
<a name="line-4214"></a> \\n\
<a name="line-4215"></a> \#define MKLAZY(fn)    TO_SPTR(P_LAZY,(sptr_t)fn)\n\
<a name="line-4216"></a> \#define MKLAZY_C(fn)  TO_SPTR_C(P_LAZY,(sptr_t)fn)\n\
<a name="line-4217"></a> \#define TO_FPTR(fn)   TO_SPTR_C(P_FUNC,(fptr_t)fn)\n\
<a name="line-4218"></a> \\n\
<a name="line-4219"></a> \#define RAW_SET_F(n)   ((wptr_t)(((intptr_t)(n) &lt;&lt; 2) | P_VALUE))\n\
<a name="line-4220"></a> \#define RAW_SET_UF(n)  ((wptr_t)(((uintptr_t)(n) &lt;&lt; 2) | P_VALUE))\n\
<a name="line-4221"></a> \#define RAW_GET_F(n)   ((intptr_t)(n) &gt;&gt; 2)\n\
<a name="line-4222"></a> \#define RAW_GET_UF(n)  ((uintptr_t)(n) &gt;&gt; 2)\n\
<a name="line-4223"></a> \\n\
<a name="line-4224"></a> \#define RAW_SET_16(w)  (wptr_t)(((uintptr_t)(w) &lt;&lt; 16) | P_VALUE)\n\
<a name="line-4225"></a> \#define RAW_GET_16(n)  ((intptr_t)(n) &gt;&gt; 16)\n\
<a name="line-4226"></a> \#define RAW_GET_U16(n) ((uintptr_t)(n) &gt;&gt; 16)\n\
<a name="line-4227"></a> \\n\
<a name="line-4228"></a> \// demote is always safe, we must only promote when we know the argument is a WHNF\n\
<a name="line-4229"></a> \#define PROMOTE(n)   ((wptr_t)(n))\n\
<a name="line-4230"></a> \#define DEMOTE(n)    ((sptr_t)(n))\n\
<a name="line-4231"></a> \\n\
<a name="line-4232"></a> \#define FETCH_TAG(x)      RAW_GET_U16(IS_PTR(x) ? FETCH_MEM_TAG(x) : (what_t)(x))\n\
<a name="line-4233"></a> \#define FETCH_RAW_TAG(x)  RAW_GET_U16(x)\n\
<a name="line-4234"></a> \#define SET_RAW_TAG(x)    RAW_SET_16(x)\n\
<a name="line-4235"></a> \#define FETCH_MEM_TAG(x)  (DNODEP(x)-&gt;what)\n\
<a name="line-4236"></a> \#define SET_MEM_TAG(x,v)  (DNODEP(x)-&gt;what = (what_t)RAW_SET_16(v))\n\
<a name="line-4237"></a> \\n\
<a name="line-4238"></a> \#define BLACK_HOLE TO_FPTR(0xDEADBEE0)\n\
<a name="line-4239"></a> \\n\
<a name="line-4240"></a> \wptr_t A_STD\n\
<a name="line-4241"></a> \#if _JHC_GC == _JHC_GC_JGC\n\
<a name="line-4242"></a> \eval(gc_t gc,arena_t arena,sptr_t s);\n\
<a name="line-4243"></a> \#else\n\
<a name="line-4244"></a> \eval(sptr_t s);\n\
<a name="line-4245"></a> \#endif\n\
<a name="line-4246"></a> \\n\
<a name="line-4247"></a> \// both promote and demote evaluate to nothing when debugging is not enabled\n\
<a name="line-4248"></a> \// otherwise, they check that their arguments are in the correct form.\n\
<a name="line-4249"></a> \#if _JHC_DEBUG\n\
<a name="line-4250"></a> \wptr_t A_STD promote(sptr_t s);\n\
<a name="line-4251"></a> \sptr_t A_STD demote(wptr_t s);\n\
<a name="line-4252"></a> \void   A_STD update(void *, wptr_t);\n\
<a name="line-4253"></a> \#else\n\
<a name="line-4254"></a> \#define promote(x) PROMOTE(x)\n\
<a name="line-4255"></a> \#define demote(x) DEMOTE(x)\n\
<a name="line-4256"></a> \inline static void update(void *t, wptr_t n) { GETHEAD(t) = (fptr_t)n; }\n\
<a name="line-4257"></a> \#endif\n\
<a name="line-4258"></a> \\n\
<a name="line-4259"></a> \#if _JHC_DEBUG &amp;&amp; _JHC_GC == _JHC_GC_JGC\n\
<a name="line-4260"></a> \bool jhc_valid_whnf(wptr_t s);\n\
<a name="line-4261"></a> \bool jhc_valid_lazy(sptr_t s);\n\
<a name="line-4262"></a> \#else\n\
<a name="line-4263"></a> \#define jhc_valid_whnf(x) true\n\
<a name="line-4264"></a> \#define jhc_valid_lazy(x) true\n\
<a name="line-4265"></a> \#endif\n\
<a name="line-4266"></a> \\n\
<a name="line-4267"></a> \#endif\n\
<a name="line-4268"></a> \\n\
<a name="line-4269"></a> \/*\n\
<a name="line-4270"></a> \ * Detail:\n\
<a name="line-4271"></a> \ * http://communities.mentor.com/community/cs/archives/arm-gnu/msg01904.html\n\
<a name="line-4272"></a> \ */\n\
<a name="line-4273"></a> \#ifdef _JHC_ARM_STAY_IN_THUMB_MODE\n\
<a name="line-4274"></a> \#define SET_THUMB_BIT(fn)    TO_SPTR(0x1,(sptr_t)fn)\n\
<a name="line-4275"></a> \#else\n\
<a name="line-4276"></a> \#define SET_THUMB_BIT(fn)    (fn)\n\
<a name="line-4277"></a> \#endif\n\
<a name="line-4278"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-4279"></a>
<a name="line-4280"></a><a name="lib_cbits_c"></a><span class='hs-comment'>-- | Generated from rts\/lib\/lib_cbits.c</span>
<a name="line-4281"></a><span class='hs-comment'>{-# NOINLINE lib_cbits_c #-}</span>
<a name="line-4282"></a><span class='hs-definition'>lib_cbits_c</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-4283"></a><span class='hs-definition'>lib_cbits_c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-4284"></a> \/* this file contains C only needed to help support the\n\
<a name="line-4285"></a> \ * standard libraries */\n\
<a name="line-4286"></a> \\n\
<a name="line-4287"></a> \#include &lt;stdio.h&gt;\n\
<a name="line-4288"></a> \\n\
<a name="line-4289"></a> \#include \"HsFFI.h\"\n\
<a name="line-4290"></a> \#include \"rts/cdefs.h\"\n\
<a name="line-4291"></a> \\n\
<a name="line-4292"></a> \HsInt jhc_stdrnd[2] A_UNUSED = { 1 , 1 };\n\
<a name="line-4293"></a> \HsInt jhc_data_unique A_UNUSED;\n\
<a name="line-4294"></a> \\n\
<a name="line-4295"></a> \HsBool A_UNUSED\n\
<a name="line-4296"></a> \jhc_wait_for_input(FILE *f,HsInt timeout) {\n\
<a name="line-4297"></a> \#if JHC_isPosix\n\
<a name="line-4298"></a> \        fd_set fds;\n\
<a name="line-4299"></a> \        FD_ZERO(&amp;fds);\n\
<a name="line-4300"></a> \        FD_SET(fileno(f),&amp;fds);\n\
<a name="line-4301"></a> \        struct timeval to = {  0, timeout * 1000 };\n\
<a name="line-4302"></a> \        int retval = select(1,&amp;fds,NULL,&amp;fds,&amp;to);\n\
<a name="line-4303"></a> \        if(retval)\n\
<a name="line-4304"></a> \                return HS_BOOL_TRUE;\n\
<a name="line-4305"></a> \        else\n\
<a name="line-4306"></a> \                return HS_BOOL_FALSE;\n\
<a name="line-4307"></a> \#else\n\
<a name="line-4308"></a> \        return HS_BOOL_FALSE;\n\
<a name="line-4309"></a> \#endif\n\
<a name="line-4310"></a> \}\n\
<a name="line-4311"></a> \\n\
<a name="line-4312"></a> \uint32_t\n\
<a name="line-4313"></a> \jhc_hash32(uint32_t key)\n\
<a name="line-4314"></a> \{\n\
<a name="line-4315"></a> \  int c2=0x27d4eb2d; // a prime or an odd constant\n\
<a name="line-4316"></a> \  key = (key ^ 61) ^ (key &gt;&gt; 16);\n\
<a name="line-4317"></a> \  key = key + (key &lt;&lt; 3);\n\
<a name="line-4318"></a> \  key = key ^ (key &gt;&gt; 4);\n\
<a name="line-4319"></a> \  key = key * c2;\n\
<a name="line-4320"></a> \  key = key ^ (key &gt;&gt; 15);\n\
<a name="line-4321"></a> \  return key;\n\
<a name="line-4322"></a> \}\n\
<a name="line-4323"></a> \\n\
<a name="line-4324"></a> \uint64_t jhc_hash64(uint64_t key)\n\
<a name="line-4325"></a> \{\n\
<a name="line-4326"></a> \  key = (~key) + (key &lt;&lt; 21); // key = (key &lt;&lt; 21) - key - 1;\n\
<a name="line-4327"></a> \  key = key ^ (key &gt;&gt; 24);\n\
<a name="line-4328"></a> \  key = (key + (key &lt;&lt; 3)) + (key &lt;&lt; 8); // key * 265\n\
<a name="line-4329"></a> \  key = key ^ (key &gt;&gt; 14);\n\
<a name="line-4330"></a> \  key = (key + (key &lt;&lt; 2)) + (key &lt;&lt; 4); // key * 21\n\
<a name="line-4331"></a> \  key = key ^ (key &gt;&gt; 28);\n\
<a name="line-4332"></a> \  key = key + (key &lt;&lt; 31);\n\
<a name="line-4333"></a> \  return key;\n\
<a name="line-4334"></a> \}\n\
<a name="line-4335"></a> \\n\
<a name="line-4336"></a> \uintptr_t\n\
<a name="line-4337"></a> \jhc_hashptr(uintptr_t key)\n\
<a name="line-4338"></a> \{\n\
<a name="line-4339"></a> \    if (sizeof(uintptr_t) == sizeof(uint32_t)) {\n\
<a name="line-4340"></a> \        return (uintptr_t)jhc_hash32((uint32_t)key);\n\
<a name="line-4341"></a> \    } else {\n\
<a name="line-4342"></a> \        return (uintptr_t)jhc_hash64((uint64_t)key);\n\
<a name="line-4343"></a> \    }\n\
<a name="line-4344"></a> \}\n\
<a name="line-4345"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-4346"></a>
<a name="line-4347"></a><a name="jhc_rts_header_h"></a><span class='hs-comment'>-- | Generated from rts\/jhc_rts_header.h</span>
<a name="line-4348"></a><span class='hs-comment'>{-# NOINLINE jhc_rts_header_h #-}</span>
<a name="line-4349"></a><span class='hs-definition'>jhc_rts_header_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-4350"></a><span class='hs-definition'>jhc_rts_header_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-4351"></a> \#include &lt;assert.h&gt;\n\
<a name="line-4352"></a> \#include &lt;errno.h&gt;\n\
<a name="line-4353"></a> \#include &lt;float.h&gt;\n\
<a name="line-4354"></a> \#include &lt;limits.h&gt;\n\
<a name="line-4355"></a> \#include &lt;locale.h&gt;\n\
<a name="line-4356"></a> \#include &lt;math.h&gt;\n\
<a name="line-4357"></a> \#include &lt;stdio.h&gt;\n\
<a name="line-4358"></a> \#include &lt;stdlib.h&gt;\n\
<a name="line-4359"></a> \#include &lt;string.h&gt;\n\
<a name="line-4360"></a> \#include &lt;time.h&gt;\n\
<a name="line-4361"></a> \#include &lt;unistd.h&gt;\n\
<a name="line-4362"></a> \#include &lt;wchar.h&gt;\n\
<a name="line-4363"></a> \#include &lt;setjmp.h&gt;\n\
<a name="line-4364"></a> \#ifndef __WIN32__\n\
<a name="line-4365"></a> \#ifdef __ARM_EABI__\n\
<a name="line-4366"></a> \#include &lt;malloc.h&gt;\n\
<a name="line-4367"></a> \#else\n\
<a name="line-4368"></a> \#include &lt;sys/select.h&gt;\n\
<a name="line-4369"></a> \#include &lt;sys/utsname.h&gt;\n\
<a name="line-4370"></a> \#endif\n\
<a name="line-4371"></a> \#include &lt;sys/times.h&gt;\n\
<a name="line-4372"></a> \#include &lt;sys/types.h&gt;\n\
<a name="line-4373"></a> \#include &lt;sys/param.h&gt;\n\
<a name="line-4374"></a> \#else\n\
<a name="line-4375"></a> \#include &lt;malloc.h&gt;\n\
<a name="line-4376"></a> \#endif\n\
<a name="line-4377"></a> \\n\
<a name="line-4378"></a> \#include \"HsFFI.h\"\n\
<a name="line-4379"></a> \#include \"sys/wsize.h\"\n\
<a name="line-4380"></a> \#include \"rts/cdefs.h\"\n\
<a name="line-4381"></a> \\n\
<a name="line-4382"></a> \#ifndef _JHC_DEBUG\n\
<a name="line-4383"></a> \#ifdef NDEBUG\n\
<a name="line-4384"></a> \#define _JHC_DEBUG 0\n\
<a name="line-4385"></a> \#else\n\
<a name="line-4386"></a> \#define _JHC_DEBUG 1\n\
<a name="line-4387"></a> \#endif\n\
<a name="line-4388"></a> \#endif\n\
<a name="line-4389"></a> \\n\
<a name="line-4390"></a> \#ifndef _JHC_STANDALONE\n\
<a name="line-4391"></a> \#define _JHC_STANDALONE 1\n\
<a name="line-4392"></a> \#endif\n\
<a name="line-4393"></a> \\n\
<a name="line-4394"></a> \#ifndef JHC_STATUS\n\
<a name="line-4395"></a> \#define JHC_STATUS 0\n\
<a name="line-4396"></a> \#endif\n\
<a name="line-4397"></a> \\n\
<a name="line-4398"></a> \#ifdef __WIN32__\n\
<a name="line-4399"></a> \#define JHC_isWindows   1\n\
<a name="line-4400"></a> \#define JHC_isBigEndian 0\n\
<a name="line-4401"></a> \#else\n\
<a name="line-4402"></a> \#define JHC_isWindows 0\n\
<a name="line-4403"></a> \#define JHC_isBigEndian (__BYTE_ORDER == __BIG_ENDIAN)\n\
<a name="line-4404"></a> \#endif\n\
<a name="line-4405"></a> \\n\
<a name="line-4406"></a> \#define JHC_isPosix (!JHC_isWindows &amp;&amp; !defined(__ARM_EABI__))\n\
<a name="line-4407"></a> \\n\
<a name="line-4408"></a> \// the program will provide the following\n\
<a name="line-4409"></a> \void _amain(void);\n\
<a name="line-4410"></a> \void jhc_hs_init(void);\n\
<a name="line-4411"></a> \extern const void * const nh_stuff[];\n\
<a name="line-4412"></a> \\n\
<a name="line-4413"></a> \#include \"rts/profile.h\"\n\
<a name="line-4414"></a> \#include \"rts/rts_support.h\"\n\
<a name="line-4415"></a> \#include \"rts/gc.h\"\n\
<a name="line-4416"></a> \#include \"rts/jhc_rts.h\"\n\
<a name="line-4417"></a> \#include \"lib/lib_cbits.h\"\n\
<a name="line-4418"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-4419"></a>
<a name="line-4420"></a><a name="lib_cbits_h"></a><span class='hs-comment'>-- | Generated from rts\/lib\/lib_cbits.h</span>
<a name="line-4421"></a><span class='hs-comment'>{-# NOINLINE lib_cbits_h #-}</span>
<a name="line-4422"></a><span class='hs-definition'>lib_cbits_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-4423"></a><span class='hs-definition'>lib_cbits_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-4424"></a> \#ifndef LIB_CBITS_H\n\
<a name="line-4425"></a> \#define LIB_CBITS_H\n\
<a name="line-4426"></a> \\n\
<a name="line-4427"></a> \#include \"HsFFI.h\"\n\
<a name="line-4428"></a> \struct FILE;\n\
<a name="line-4429"></a> \\n\
<a name="line-4430"></a> \extern HsInt jhc_stdrnd[2];\n\
<a name="line-4431"></a> \extern HsInt jhc_data_unique;\n\
<a name="line-4432"></a> \HsBool jhc_wait_for_input(FILE *f,HsInt timeout);\n\
<a name="line-4433"></a> \\n\
<a name="line-4434"></a> \#ifdef __WIN32__\n\
<a name="line-4435"></a> \#define getchar_unlocked() getchar()\n\
<a name="line-4436"></a> \#define putchar_unlocked(x) putchar(x)\n\
<a name="line-4437"></a> \#define getc_unlocked(x) getc(x)\n\
<a name="line-4438"></a> \#define putc_unlocked(x,y) putc(x,y)\n\
<a name="line-4439"></a> \#endif\n\
<a name="line-4440"></a> \\n\
<a name="line-4441"></a> \inline static int A_UNUSED\n\
<a name="line-4442"></a> \jhc_utf8_getchar(void)\n\
<a name="line-4443"></a> \{\n\
<a name="line-4444"></a> \    return getchar_unlocked();\n\
<a name="line-4445"></a> \}\n\
<a name="line-4446"></a> \\n\
<a name="line-4447"></a> \inline static int A_UNUSED\n\
<a name="line-4448"></a> \jhc_utf8_getc(FILE *f)\n\
<a name="line-4449"></a> \{\n\
<a name="line-4450"></a> \    return getc_unlocked(f);\n\
<a name="line-4451"></a> \}\n\
<a name="line-4452"></a> \\n\
<a name="line-4453"></a> \inline static int A_UNUSED\n\
<a name="line-4454"></a> \jhc_utf8_putchar(int ch)\n\
<a name="line-4455"></a> \{\n\
<a name="line-4456"></a> \    return putchar_unlocked(ch);\n\
<a name="line-4457"></a> \}\n\
<a name="line-4458"></a> \\n\
<a name="line-4459"></a> \inline static int A_UNUSED\n\
<a name="line-4460"></a> \jhc_utf8_putc(int ch, FILE *f)\n\
<a name="line-4461"></a> \{\n\
<a name="line-4462"></a> \    return putc_unlocked(ch,f);\n\
<a name="line-4463"></a> \}\n\
<a name="line-4464"></a> \\n\
<a name="line-4465"></a> \#endif\n\
<a name="line-4466"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-4467"></a>
<a name="line-4468"></a><a name="gc_jgc_internal_h"></a><span class='hs-comment'>-- | Generated from rts\/rts\/gc_jgc_internal.h</span>
<a name="line-4469"></a><span class='hs-comment'>{-# NOINLINE gc_jgc_internal_h #-}</span>
<a name="line-4470"></a><span class='hs-definition'>gc_jgc_internal_h</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ByteString</span>
<a name="line-4471"></a><span class='hs-definition'>gc_jgc_internal_h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafePerformIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unsafePackAddress</span> <span class='hs-str'>"\
<a name="line-4472"></a> \#ifndef GC_JGC_INTERNAL_H\n\
<a name="line-4473"></a> \#define GC_JGC_INTERNAL_H\n\
<a name="line-4474"></a> \\n\
<a name="line-4475"></a> \#include \"rts/gc_jgc.h\"\n\
<a name="line-4476"></a> \#include \"sys/bitarray.h\"\n\
<a name="line-4477"></a> \#include \"sys/queue.h\"\n\
<a name="line-4478"></a> \\n\
<a name="line-4479"></a> \#if _JHC_GC == _JHC_GC_JGC\n\
<a name="line-4480"></a> \\n\
<a name="line-4481"></a> \struct s_arena {\n\
<a name="line-4482"></a> \        struct s_megablock *current_megablock;\n\
<a name="line-4483"></a> \        SLIST_HEAD(,s_block) free_blocks;\n\
<a name="line-4484"></a> \        unsigned block_used;\n\
<a name="line-4485"></a> \        unsigned block_threshold;\n\
<a name="line-4486"></a> \        SLIST_HEAD(,s_cache) caches;\n\
<a name="line-4487"></a> \        SLIST_HEAD(,s_block) monolithic_blocks;\n\
<a name="line-4488"></a> \        SLIST_HEAD(,s_megablock) megablocks;\n\
<a name="line-4489"></a> \        unsigned number_gcs;    // number of garbage collections\n\
<a name="line-4490"></a> \        unsigned number_allocs; // number of allocations since last garbage collection\n\
<a name="line-4491"></a> \        gc_t gc_stack_base;\n\
<a name="line-4492"></a> \};\n\
<a name="line-4493"></a> \\n\
<a name="line-4494"></a> \struct s_megablock {\n\
<a name="line-4495"></a> \        void *base;\n\
<a name="line-4496"></a> \        unsigned next_free;\n\
<a name="line-4497"></a> \        SLIST_ENTRY(s_megablock) next;\n\
<a name="line-4498"></a> \};\n\
<a name="line-4499"></a> \\n\
<a name="line-4500"></a> \struct s_block {\n\
<a name="line-4501"></a> \        SLIST_ENTRY(s_block) link;\n\
<a name="line-4502"></a> \        unsigned char flags;  // defined in rts/constants.h\n\
<a name="line-4503"></a> \        unsigned char color;  // offset in words to first entry.\n\
<a name="line-4504"></a> \        union {\n\
<a name="line-4505"></a> \                // A normal block.\n\
<a name="line-4506"></a> \                struct {\n\
<a name="line-4507"></a> \                        unsigned char num_ptrs;\n\
<a name="line-4508"></a> \                        unsigned char size;\n\
<a name="line-4509"></a> \                        unsigned short num_free;\n\
<a name="line-4510"></a> \                        unsigned short next_free;\n\
<a name="line-4511"></a> \                } pi;\n\
<a name="line-4512"></a> \                // A monolithic block.\n\
<a name="line-4513"></a> \                struct {\n\
<a name="line-4514"></a> \                        unsigned num_ptrs;\n\
<a name="line-4515"></a> \                } m;\n\
<a name="line-4516"></a> \        } u;\n\
<a name="line-4517"></a> \        bitarray_t used[];\n\
<a name="line-4518"></a> \};\n\
<a name="line-4519"></a> \\n\
<a name="line-4520"></a> \struct s_cache {\n\
<a name="line-4521"></a> \        SLIST_ENTRY(s_cache) next;\n\
<a name="line-4522"></a> \        SLIST_HEAD(,s_block) blocks;\n\
<a name="line-4523"></a> \        SLIST_HEAD(,s_block) full_blocks;\n\
<a name="line-4524"></a> \        unsigned char color;\n\
<a name="line-4525"></a> \        unsigned char size;\n\
<a name="line-4526"></a> \        unsigned char num_ptrs;\n\
<a name="line-4527"></a> \        unsigned char flags;\n\
<a name="line-4528"></a> \        unsigned short num_entries;\n\
<a name="line-4529"></a> \        struct s_arena *arena;\n\
<a name="line-4530"></a> \#if _JHC_PROFILE\n\
<a name="line-4531"></a> \        unsigned allocations;\n\
<a name="line-4532"></a> \#endif\n\
<a name="line-4533"></a> \};\n\
<a name="line-4534"></a> \#endif\n\
<a name="line-4535"></a> \#endif\n\
<a name="line-4536"></a> \"</span><span class='hs-cpp'>#</span>
<a name="line-4537"></a>
<a name="line-4538"></a>
<a name="line-4539"></a>
</pre></body>
</html>
